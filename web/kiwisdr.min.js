

/* web/extensions/ext.min.js */
var extint={ws:null,extname:null,param:null,override_pb:!1,displayed:!1,help_displayed:!1,current_ext_name:null,using_data_container:!1,default_w:525,default_h:300,prev_mode:null,seq:0,no_lockout:["noise_blank","noise_filter","ant_switch","iframe","colormap","devl"],excl_devl:["sig_gen","devl","s4285"]},devl={in1:1,in2:0,in3:0};function ext_switch_to_client(e,t,n){recv_websocket(extint.ws,n),ext_send("SET ext_switch_to_client="+e+" first_time="+(t?1:0)+" rx_chan="+rx_chan),w3_call(e+"_focus")}function ext_send(e,t){null==t&&(t=extint.ws);try{return t.send(e),0}catch(e){console.log("CATCH ext_send('"+s+"') ex="+e),kiwi_trace()}}function ext_panel_show(e,t,n){extint_panel_show(e,t,n)}function ext_set_data_height(e){var t=w3_el("id-ext-data-container");e?t&&(t.style.height=px(e)):t&&(t.style.height="")}function ext_set_controls_width_height(e,t){panel_set_width_height("ext-controls",e,t)}var EXT_SAVE=!0,EXT_NO_SAVE=!1;function ext_get_cfg_param(e,t,n){var _;e=w3_add_toplevel(e);try{_=getVarFromString(e)}catch(e){_=null}return null!=_&&null!=_||null==t||(_=t,setVarFromString(e,_),null!=n&&n!=EXT_SAVE||cfg_save_json(e,extint.ws)),_}function ext_get_cfg_param_string(e,t,n){return decodeURIComponent(ext_get_cfg_param(e,t,n))}function ext_set_cfg_param(e,t,n){e=w3_add_toplevel(e),setVarFromString(e,t),null!=n&&n==EXT_SAVE&&cfg_save_json(e,extint.ws)}function ext_get_freq_range(){var e=cfg.freq_offset;return{lo_kHz:cfg.sdr_hu_lo_kHz+e,hi_kHz:cfg.sdr_hu_hi_kHz+e,offset_kHz:e}}var extint_isAdmin_cb,extint_authkey_cb,ext_zoom={TO_BAND:0,IN:1,OUT:-1,ABS:2,WHEEL:3,NOM_IN:8,MAX_IN:9,MAX_OUT:-9},extint_ext_is_tuning=!1;function ext_tune(e,t,n,_,i,o){var a=null!=i&&null!=o;extint_ext_is_tuning=!0,freqmode_set_dsp_kHz(e,t),a&&ext_set_passband(i,o),null!=n?zoom_step(n,_):zoom_step(ext_zoom.TO_BAND),extint_ext_is_tuning=!1}function ext_get_freq_Hz(){return{displayed:freq_displayed_Hz,carrier:freq_car_Hz,passband_center:freq_passband_center()}}function ext_get_freq(){return freq_displayed_Hz}function ext_get_freq_kHz(){return(freq_displayed_Hz/1e3).toFixed(2)}function ext_get_carrier_freq(){return freq_car_Hz}function ext_get_passband_center_freq(){return freq_passband_center()}function ext_get_mode(){return cur_mode}function ext_is_IQ_or_stereo_mode(){return"drm"==cur_mode||"iq"==cur_mode||"sas"==cur_mode}function ext_get_prev_mode(){return extint.prev_mode}function ext_set_mode(e,t,n){var _="drm"==e;_&&(extint.prev_mode=cur_mode),demodulator_analog_replace(e,t);var i=w3_opt(n,"open_ext",!1),o=w3_opt(n,"no_drm_proc",!1),a="undefined"!=typeof drm&&drm.active;o||(_&&i?a?toggle_panel("ext-controls",1):extint_open("drm"):!_&&a&&(extint_panel_hide(),demodulator_analog_replace(e,t)))}function ext_get_passband(){var e=demodulators[0];return{low:e.low_cut,high:e.high_cut}}function ext_set_passband(e,t,n,_){var i=demodulators[0],o=i.filter;null==e&&(e=i.low_cut),null==t&&(t=i.high_cut);Math.abs(t-e);e=e<o.low_cut_limit?o.low_cut_limit:e,t=t>o.high_cut_limit?o.high_cut_limit:t;var a=!1;Math.abs(t-e)>=o.min_passband&&e<t&&(i.low_cut=e,i.high_cut=t,a=!0),isArg(n)&&n&&a&&(passbands[cur_mode].last_lo=e,passbands[cur_mode].last_hi=t),null!=_&&null!=_&&(_*=1e3,freq_car_Hz=freq_dsp_to_car(_)),extint_ext_is_tuning=!0,demodulator_set_offset_frequency(0,freq_car_Hz-center_freq),extint_ext_is_tuning=!1}function ext_get_tuning(){return{low:demod.low_cut,high:demod.high_cut,mode:cur_mode,freq_dial_kHz:freq_displayed_Hz/1e3}}function ext_get_zoom(){return zoom_level}function ext_get_optbar(){return readCookie("last_optbar")}function ext_set_optbar(e){extint.optbars[e]&&(writeCookie("last_optbar",e),w3_el("id-nav-"+e).click())}function ext_hasCredential(e,t,n,_){var i;"mfg"==e&&(e="admin"),"admin"==e?(deleteCookie("admin"),deleteCookie("admin-pwd"),i=""):i=(i=readCookie(e))?decodeURIComponent(i):"",extint_pwd_cb=t,extint_pwd_cb_param=n,ext_valpwd(e,i,_)}function ext_valpwd(e,t,n){t=encodeURIComponent(t),"admin"!=e&&writeCookie(e,t),extint_conn_type=e,t=""!=t?t:"#";var _=null,i=readCookie("iplimit"),o=kiwi_url_param(["pwd","password"],"","");""!=o?_=o:i&&""!=i&&(_=i),_=_?" ipl="+_:"",null!=kiwi_url_param(["p","prot","protected"],"true",null)&&"admin"!=e&&(e="prot"),ext_send("SET auth t="+e+" p="+t+_,n)}function ext_isAdmin(e){extint_isAdmin_cb=e,ext_send("SET is_admin")}function ext_get_authkey(e){ext_send("SET get_authkey"),extint_authkey_cb=e}extint.optbars={"optbar-wf":0,"optbar-audio":1,"optbar-agc":2,"optbar-users":3,"optbar-status":4,"optbar-off":5};var extint_adc_clock_Hz=0;function ext_adc_clock_Hz(){return extint_adc_clock_Hz}var extint_adc_gps_clock_corr=0;function ext_adc_gps_clock_corr(){return extint_adc_gps_clock_corr}var extint_adc_clock_nom_Hz=0;function ext_adc_clock_nom_Hz(){return extint_adc_clock_nom_Hz}var extint_srate=0;function ext_sample_rate(){return extint_srate}var extint_audio_data_cb=null;function ext_register_audio_data_cb(e){extint_audio_data_cb=e}function ext_unregister_audio_data_cb(){extint_audio_data_cb=null}function ext_param(){var e=extint.param;return extint.param=null,e}function ext_panel_set_name(e){extint.current_ext_name=e}function ext_mobile_info(e){var t=window.innerWidth,n=window.innerHeight,_={width:t,height:n};_.wh_unchanged=e&&e.width==t&&e.height==n?1:0;var i=t<n||mobile_laptop_test?1:0;return _.orient_unchanged=e&&e.isPortrait==i?1:0,_.isPortrait=i?1:0,_.iPad=i&&t<=768?1:0,_.small=i&&t<768?1:0,_.narrow=i&&n<=600?1:0,_}function extint_news(e){var t=w3_el("id-news");t.style.width="400px",t.style.height="300px",t.style.visibility="visible",t.style.zIndex=9999,w3_innerHTML("id-news-inner",e)}function ext_panel_init(){w3_el("id-panels-container").innerHTML+='<div id="id-ext-controls" class="class-panel" data-panel-name="ext-controls" data-panel-pos="bottom-left" data-panel-order="0" data-panel-size="'+extint.default_w+","+extint.default_h+'"></div>';var e=w3_el("id-ext-data-container");e.style.zIndex=100,(e=w3_el("id-ext-controls")).innerHTML=w3_div("id-ext-controls-container w3-relative|width:100%;height:100%;")+w3_div("id-ext-controls-vis class-vis")+w3_div("id-ext-controls-help cl-ext-help",w3_button('id-ext-controls-help-btn w3-green w3-small w3-padding-small w3-disabled||onclick="extint_help_click()"',"help")),w3_el("id-kiwi-body").addEventListener("keyup",function(e){"Escape"==e.key&&extint.displayed&&!confirmation.displayed&&1!=w3_call(extint.current_ext_name+"_escape_key_cb")&&w3_el("id-ext-controls-close").click()},!0)}function extint_panel_show(e,t,n,_){var i;extint.using_data_container=!!t,extint.using_data_container?(toggle_or_set_spec(toggle_e.SET,0),w3_hide("id-top-container"),w3_show_block(w3_innerHTML("id-ext-data-container",t))):(w3_hide("id-ext-data-container"),spectrum_display||w3_show_block("id-top-container")),1==extint.help_displayed&&(confirmation_panel_close(),extint.help_displayed=!1),(i=w3_el("id-ext-controls-close")).onclick=function(){toggle_panel("ext-controls"),extint_panel_hide()},w3_el("id-ext-controls").style.zIndex=150,w3_attribute("id-ext-controls-close-img","src","icons/close.24.png"),(i=w3_el("id-ext-controls-container")).innerHTML=e,n&&n(),(i=w3_el("id-ext-controls")).style.zIndex=150,w3_visible(i,!0),i.panelShown=1,toggle_or_set_hide_panels(0),w3_el("id-confirmation-container").style.height="",_=isDefined(_)?_:w3_call(extint.current_ext_name+"_help",!1),w3_set_props("id-ext-controls-help-btn","w3-disabled",isUndefined(_)||0==_),w3_show_hide("id-ext-controls-help-btn","off"!=_),extint.displayed=!0}function ext_panel_displayed(e){return extint.displayed&&(!e||e==extint.current_ext_name)}function ext_panel_redisplay(e){w3_innerHTML("id-ext-controls-container",e)}function extint_panel_hide(){extint.using_data_container&&(w3_hide("id-ext-data-container"),w3_show_block("id-top-container"),extint.using_data_container=!1,1==extint.help_displayed&&(confirmation_panel_close(),extint.help_displayed=!1)),w3_visible("id-ext-controls",!1),extint_blur_prev(1),w3_select_value("id-select-ext",-1),resize_waterfall_container(!0),freqset_select(),extint.displayed=!1}function extint_help_click(){w3_contains("id-ext-controls-help-btn","w3-disabled")||(console.log(extint.current_ext_name+"_help_click CLICKED"),extint.help_displayed=w3_call(extint.current_ext_name+"_help",!0))}function extint_environment_changed(e){setTimeout(function(){extint.current_ext_name&&w3_call(extint.current_ext_name+"_environment_changed",e),w3_call("injection_environment_changed",e)},100)}var extint_pwd_cb=null,extint_pwd_cb_param=null,extint_conn_type=null;function extint_valpwd_cb(e){extint_pwd_cb&&extint_pwd_cb(e,extint_pwd_cb_param)}function extint_open_ws_cb(){ext_hasCredential("kiwi",null,null),setTimeout(function(){setInterval(function(){ext_send("SET keepalive")},5e3)},5e3)}function extint_connect_server(){return extint.ws=open_websocket("EXT",extint_open_ws_cb,null,extint_msg_cb),extint.ws}function extint_msg_cb(e,t){switch(e[0]){case"keepalive":break;case"ext_client_init":console.log("ext_client_init is_locked="+ +e[1]),extint_focus(+e[1]);break;default:return!1}return!0}function extint_blur_prev(e){null!=extint.current_ext_name&&(w3_call(extint.current_ext_name+"_blur"),recv_websocket(extint.ws,null),e&&ext_set_controls_width_height(),extint.current_ext_name=null,time_display_setup("id-topbar-right-container")),extint.ws&&ext_send("SET ext_blur="+rx_chan)}function extint_focus(e){var t=extint.current_ext_name;if(console.log("extint_focus: loading "+t+".js"),e&&!extint.no_lockout.includes(t))return extint_panel_show(w3_text("w3-medium w3-text-css-yellow","Cannot use extensions while <br> another channel is in DRM mode."),null,null,"off"),void ext_set_controls_width_height(300,75);kiwi_load_js_dir("extensions/"+t+"/"+t,[".js",".css"],function(){console.log("extint_focus: calling "+t+"_main()"),ext_set_controls_width_height(),w3_call(t+"_main")},function(e){if(console.log("extint_focus: "+t+" loaded="+e),e){extint_panel_show("loading extension...",null,null,"off"),ext_set_controls_width_height(325,45),kiwi.is_locked&&console.log("==== IS_LOCKED =================================================")}})}var extint_names,extint_first_ext_load=!0;function extint_select(e){extint_blur_prev(0),e=+e,w3_select_value("id-select-ext",e);var t,n=w3_el("id-select-ext").childNodes[e+1].innerHTML.toLowerCase();console.log("extint_select val="+e+" name="+n),extint_names_enum(function(e,_,i,o){i.toLowerCase().includes(n)&&(console.log("extint_select HIT id="+i+" id_en="+o+" i="+e+" value="+_),t=e)}),extint.current_ext_name=extint_names[t],extint_first_ext_load?(extint.ws=extint_connect_server(),extint_first_ext_load=!1):ext_send("SET ext_is_locked_status")}function extint_list_json(e){extint_names=JSON.parse(decodeURIComponent(e))}function extint_names_enum(e){var t,n;for(t=n=0;t<extint_names.length;t++){var _=extint_names[t];if(dbgUs||!extint.excl_devl.includes(_)){"wspr"==_&&(_="WSPR");var i=_;"cw_decoder"==i&&(i="cw"),"SSTV"==i&&(i="sstv"),"TDoA"==i&&(i="tdoa"),e(t,n,_,i),n++}}}function extint_select_build_menu(){var e="";return extint_names&&isArray(extint_names)&&extint_names_enum(function(t,n,_,i){var o=ext_get_cfg_param(i+".enable");console.log("extint_select_menu id_en="+i+" en="+o),(null==o||kiwi.is_local[rx_chan])&&(o=!0),"DRM"==_&&(kiwi.DRM_enable=o),e+="<option value="+dq(n)+" kiwi_idx="+dq(t)+" "+(o?"":"disabled")+">"+_+"</option>"}),e}function extint_open(e,t){e=e.toLowerCase();var n=0;extint_names_enum(function(_,i,o,a){var l=ext_get_cfg_param(a+".enable");(null==l||kiwi.is_local[rx_chan])&&(l=!0),!n&&l&&o.toLowerCase().includes(e)&&(t?setTimeout(function(){extint_select(i)},t):extint_select(i),n=1)})}function extint_audio_data(e,t){isFunction(extint_audio_data_cb)&&extint_audio_data_cb(e,t)}




/* web/kiwi/kiwi.min.js */
var kiwi={is_local:[],loaded_files:{},WSPR_rgrid:"",GPS_fixes:0,wf_fps:0,inactivity_panel:!1,is_multi_core:0,modes_l:["am","amn","usb","lsb","cw","cwn","nbfm","iq","drm","usn","lsn","sam","sal","sau","sas"],modes_u:[],modes_s:{},RX4_WF4:0,RX8_WF2:1,RX3_WF3:2,RX14_WF0:3,cmap_s:["Kiwi","CuteSDR","grey","linear","turbo","SdrDx","custom 1","custom 2","custom 3","custom 4"],cmap_e:{kiwi:0,CuteSDR:1,greyscale:2,linear:3,turbo:4,SdrDx:5,custom_1:6,custom_2:7,custom_3:8,custom_4:9},aper_s:["man","auto"],aper_e:{man:0,auto:1}};kiwi.modes_l.forEach(function(e,i){kiwi.modes_u.push(e.toUpperCase()),kiwi.modes_s[e]=i});var rx_chans,wf_chans,wf_chans_real,rx_chan,conn_type,timestamp,gmap,WATERFALL_CALIBRATION_DEFAULT=-13,SMETER_CALIBRATION_DEFAULT=-13,try_again="",seriousError=!1,types=["active","watch-list","sub-band","DGPS","special event","interference","masked"],types_s={active:0,watch_list:1,sub_band:2,DGPS:3,special_event:4,interference:5,masked:6},type_colors={0:"cyan",16:"lightPink",32:"aquamarine",48:"lavender",64:"violet",80:"violet",96:"lightGrey"},optbar_prefix_color="w3-text-css-orange",dbgUs=!1,dbgUsFirst=!0;function kiwi_bodyonload(e){if(""!=e)kiwi_serious_error(e);else{initCookie("ident","").startsWith("ZL/KF6VO")&&(dbgUs=!0),"undefined"==(conn_type=html("id-kiwi-container").getAttribute("data-type"))&&(conn_type="kiwi"),console.log("conn_type="+conn_type),w3int_init();var i=new Date;timestamp=i.getTime(),extint.ws="kiwi"==conn_type?owrx_ws_open_snd(kiwi_open_ws_cb,{conn_type:conn_type}):kiwi_ws_open(conn_type,kiwi_open_ws_cb,{conn_type:conn_type})}}function kiwi_open_ws_cb(e){"kiwi"!=e.conn_type&&setTimeout(function(){setInterval(function(){ext_send("SET keepalive")},5e3)},5e3),seriousError||ext_hasCredential(e.conn_type,kiwi_valpwd1_cb,e)}function kiwi_load_js_polled(e,i){return e.started||(kiwi_load_js(i,function(){e.finished=!0}),e.started=!0,e.finished=!1),e.finished}function kiwi_load_js_dir(e,i,t,r){for(var s=0;s<i.length;s++)i[s]=e+i[s];kiwi_load_js(i,t,r)}function kiwi_load_js(e,i,t){console.log("DYNLOAD START"),e.push("kiwi/kiwi_js_load.js"),console.log(e);var r=!1;e.forEach(function(t){if(kiwi.loaded_files[t])console.log("already loaded: "+t);else{if(t.includes("kiwi_js_load.js")){if(!r)return}else kiwi.loaded_files[t]=1,r=!0;var s,o=!1;t.endsWith(".js")||t.includes("/js?key=")?((s=document.createElement("script")).src=t,s.type="text/javascript","kiwi/kiwi_js_load.js"==t&&(s.kiwi_js=e[0],s.kiwi_cb=i)):t.endsWith(".css")?((s=document.createElement("link")).rel="stylesheet",s.href=t,s.type="text/css"):o=!0,o?console.log("UNKNOWN FILETYPE "+t):(s.async=!1,document.head.appendChild(s),console.log("loading "+t))}}),console.log("DYNLOAD FINISH"),r?t&&w3_call(t,!0):(t&&w3_call(t,!1),i&&w3_call(i))}function kiwi_ask_pwd(e){console.log("kiwi_ask_pwd chan_no_pwd="+chan_no_pwd+" client_public_ip="+client_public_ip);var i="";e&&chan_no_pwd&&(i="All channels busy that don't require a password ("+chan_no_pwd+"/"+rx_chans+")<br>"),kiwi_url_param(["p","prot","protected"],!0,!1)&&e&&(i="You have requested a password protected channel<br>"),kiwi_show_msg("KiwiSDR: software-defined receiver <br>"+i+"<form name='pform' style='display:inline-block' action='#' onsubmit='ext_valpwd(\""+conn_type+"\", this.pwd.value); return false;'>"+try_again+w3_input('w3-label-inline w3-label-not-bold/kiwi-pw|padding:1px|name="pwd" size=40 onclick="this.focus(); this.select()"',"Password:")+"</form>"),document.pform.pwd.focus(),document.pform.pwd.select()}var override_freq,override_mode,override_zoom,override_max_dB,override_min_dB,override_9_10,body_loaded=!1;function kiwi_valpwd1_cb(e,i){if(!seriousError)if(1==e)kiwi_ask_pwd("kiwi"==i.conn_type),try_again="Try again. ";else{if(2==e)return void kiwi_show_msg("Still determining local interface address.<br>Please try reloading page in a few moments.");if(3==e)return void kiwi_show_msg("Admin connections not allowed from this ip address.");if(4==e)return void kiwi_show_msg("No admin password set. Can only connect from same local network as Kiwi.<br>Client ip = "+client_public_ip);if(5==e)return void kiwi_show_msg("Multiple connections from the same ip address not allowed.<br>Client ip = "+client_public_ip);0==e&&("kiwi"==i.conn_type?extint.ws=owrx_ws_open_wf(kiwi_open_ws_cb2,i):kiwi_valpwd2_cb(0,i))}}function kiwi_open_ws_cb2(e){ext_hasCredential(e.conn_type,kiwi_valpwd2_cb,e)}function kiwi_valpwd2_cb(e,i){if(!seriousError)if(kiwi_show_msg(""),body_loaded)console.log("kiwi_valpwd2_cb: body_loaded previously!");else{body_loaded=!0,"kiwi"!=i.conn_type&&(w3_hide("id-kiwi-msg-container"),w3_show_block("id-kiwi-container"),w3_el("id-kiwi-body").style.overflow="hidden");try{kiwi_init(),w3_call(i.conn_type+"_main")}catch(e){console.log("EX: "+e),console.log("kiwi_valpwd2_cb: no interface routine for "+i.conn_type+"?")}}}function kiwi_init(){}function kiwi_xdLocalStorage_init(){if(dbgUs){for(var e=[],i=0;i<5;i++)e[i]=dbgUs&&0==i?"http://kiwisdr.com/pkgs/xdLocalStorage/xdLocalStorage-min.html":"http://pub"+i+".kiwisdr.com:8073/pkgs/xdLocalStorage/xdLocalStorage-min.html";xdLocalStorageHA.init({iframeUrls:e,initCallback:function(){console.log("xdLocalStorageHA READY")}})}}function kiwi_get_init_settings(){var e=null==init_frequency?7020:init_frequency;e=ext_get_cfg_param("init.freq",e,EXT_NO_SAVE),init_frequency=override_freq||e;var i=null==init_mode?kiwi.modes_s.lsb:kiwi.modes_s[init_mode];i=ext_get_cfg_param("init.mode",i,EXT_NO_SAVE),init_mode=override_mode||kiwi.modes_l[i],"drm"===init_mode&&(init_mode="am");var t=null==init_zoom?0:init_zoom;t=ext_get_cfg_param("init.zoom",t,EXT_NO_SAVE),init_zoom=override_zoom||t;var r=null==init_max_dB?-10:init_max_dB;r=ext_get_cfg_param("init.max_dB",r,EXT_NO_SAVE),init_max_dB=override_max_dB||r;var s=null==init_min_dB?-110:init_min_dB;s=ext_get_cfg_param("init.min_dB",s,EXT_NO_SAVE),init_min_dB=override_min_dB||s,console.log("INIT f="+init_frequency+" m="+init_mode+" z="+init_zoom+" min="+init_min_dB+" max="+init_max_dB),w3_call("init_scale_dB");var o=ext_get_cfg_param("rx_antenna"),n=w3_el("rx-antenna");null!=n&&o&&(n.innerHTML="Antenna: "+decodeURIComponent(o)),kiwi.WSPR_rgrid=ext_get_cfg_param_string("WSPR.grid","",EXT_NO_SAVE)}var cfg={},adm={};function cfg_save_json(e,i){var t;null!=i&&null!=i&&(e.startsWith("adm.")?(t=encodeURIComponent(JSON.stringify(adm)),i.send("SET save_adm="+t)):(t=encodeURIComponent(JSON.stringify(cfg)),i.send("SET save_cfg="+t)),console.log("cfg_save_json: DONE"))}var server_time_utc,server_time_local,server_time_tzid,server_time_tzname,server_tz,geo={geo:"",json:"",retry:0};function kiwi_geolocate(e){var i=kiwi_isFirefox();if(!(i&&i<=28)){var t;switch(null==e&&(e=(new Date).getSeconds()),e%=3){case 0:t="ipapi.co/json";break;case 1:t="extreme-ip-lookup.com/json";break;case 2:t="get.geojs.io/v1/ip/geo.json"}kiwi_ajax("https://"+t,function(i){void 0===i.AJAX_error?(console.log("GEOLOC "+t),console.log(i),geoloc_json(i)):geo.retry++<=3&&kiwi_geolocate(e+1)},null,5e3)}}function geoloc_json(e){if(null==e.AJAX_error){window.JSON&&window.JSON.stringify?geo.json=JSON.stringify(e):geo.json=e.toString();var i=e.country_name||e.country;"United States"==i&&e.region&&(i=e.region+", USA"),geo.geo="",e.city&&(geo.geo+=e.city),i&&(geo.geo+=(e.city?", ":"")+i),console.log("GEOLOC "+geo.geo)}}function kiwi_geo(){return encodeURIComponent(geo.geo)}function kiwi_geojson(){return encodeURIComponent(geo.json)}var time_display_current=!0;function time_display_cb(e){isUndefined(e.tu)||(server_time_utc=e.tu,server_time_local=e.tl,server_time_tzid=decodeURIComponent(e.ti),server_time_tzname=decodeURIComponent(e.tn).replace(/\\/g,"").replace(/_/g," "),server_tz=server_time_tzname,server_time_tzid&&(server_tz+=" ("+server_time_tzid+")"),time_display_started?time_display(time_display_current):(time_display_periodic(),time_display_started=!0))}function time_display(e){if(w3_el("id-time-display-text-inner")){var i=""==server_time_local||"null"==server_time_tzname;w3_set_innerHTML("id-time-display-UTC",server_time_utc||"?"),w3_set_innerHTML("id-time-display-local",i?"?":server_time_local),w3_set_innerHTML("id-time-display-tzname",i?"Lat/lon needed for local time":server_tz),w3_el("id-time-display-logo-inner").style.opacity=e?0:1,w3_el("id-time-display-inner").style.opacity=e?1:0}}function time_display_periodic(){time_display(time_display_current),time_display_current^=1,setTimeout(function(){time_display_periodic()},time_display_current?5e4:1e4)}var time_display_prev,time_display_started=!1;function time_display_setup(e){var i;0==e.startsWith("id-")&&(e+="-time-display"),time_display_prev&&(i=w3_el(time_display_prev))&&(i.innerHTML=""),time_display_prev=e,(i=w3_el(e)).innerHTML=w3_div("id-time-display-inner",w3_div("id-time-display-text-inner",w3_inline("",w3_div("id-time-display-UTC"),w3_div("cl-time-display-text-suffix","UTC")),w3_inline("",w3_div("id-time-display-local"),w3_div("cl-time-display-text-suffix","Local")),w3_div("id-time-display-tzname")))+w3_div("id-time-display-logo-inner",w3_div("id-time-display-logo-text","Powered by"),'<a href="https://github.com/ha7ilm/openwebrx" target="_blank"><img id="id-time-display-logo" src="gfx/openwebrx-top-logo.png" /></a>'),time_display(time_display_current)}function time_display_width(){return 200}function time_display_html(e){return w3_div(e+"-time-display|top:50px; background-color:black; position:relative;")}var perf_status_anim,perf_status_timeout,pref={},pref_default={p:"default-p"};function show_pref(){pref_load(function(){var e=w3_divs("w3-text-css-yellow/w3-tspace-16",w3_div("w3-medium w3-text-aqua","<b>User preferences</b>"),w3_col_percent("",w3_input("","Pref","pref.p",pref.p,"pref_p_cb","something"),30),w3_div("w3-show-inline-block w3-hspace-16",w3_button("","Export","pref_export_btn_cb"),w3_button("","Import","pref_import_btn_cb"),"<b>Status:</b> "+w3_div("id-pref-status w3-show-inline-block w3-snap-back")));extint_panel_hide(),ext_panel_set_name("show_pref"),ext_panel_show(e,null,show_pref_post),ext_set_controls_width_height(1024,250),freqset_select()})}function pref_p_cb(e,i){w3_string_cb(e,i),pref_save()}function pref_refresh_ui(){w3_set_value("pref.p",pref.p)}function pref_status(e,i){var t=w3_el("id-pref-status");if(perf_status_anim)return kiwi_clearTimeout(perf_status_timeout),w3_remove_then_add(t,"w3-fade-out","w3-snap-back"),void setTimeout(function(){perf_status_anim=!1,pref_status(e,i)},1e3);t.style.color=e,t.innerHTML=i,w3_remove_then_add(t,"w3-snap-back","w3-fade-out"),perf_status_anim=!0,perf_status_timeout=setTimeout(function(){t.innerHTML="",w3_remove_then_add(t,"w3-fade-out","w3-snap-back"),perf_status_anim=!1},1500)}function pref_export_btn_cb(e,i){console.log("pref_export_btn_cb"),pref_save(function(){console.log("msg_send pref_export"),msg_send("SET pref_export id="+encodeURIComponent(pref.id)+" pref="+encodeURIComponent(JSON.stringify(pref)))}),pref_status("lime","preferences exported")}function pref_import_btn_cb(e,i){console.log("pref_import_btn_cb");var t=ident_user||"_blank_";msg_send("SET pref_import id="+encodeURIComponent(t))}function pref_import_cb(e,i){var t=decodeURIComponent(e);console.log("pref_import_cb "+t),"null"!=t?(pref=JSON.parse(t),console.log(pref),pref_save(),pref_refresh_ui(),pref_status("lime","preferences successfully imported from RX"+i)):pref_status("yellow","no preferences previously exported")}function pref_load(e){var i=ident_user||"_blank_";xdLocalStorageHA.getItem("pref."+i,function(t){console.log("xdLocalStorage.getItem pref."+i),console.log(t),pref=null==t.value?pref_default:JSON.parse(t.value),console.log(pref),e&&e()})}function pref_save(e){var i=ident_user||"_blank_";pref.id=i;var t=JSON.stringify(pref);xdLocalStorageHA.setItem("pref."+i,t,function(t){console.log("xdLocalStorage.setItem pref."+i),console.log(t),e&&e()})}function show_pref_post(){console.log("show_pref_post")}function show_pref_blur(){console.log("show_pref_blur")}var ansi={colors:[[0,0,0],[194,54,33],[37,188,36],[173,173,39],[73,46,225],[211,56,211],[51,187,200],[203,204,205],[129,131,131],[252,57,31],[49,231,34],[234,236,35],[88,51,255],[249,53,248],[20,240,240],[233,235,235]]};function kiwi_output_msg(e,i,t){var r=w3_el(e);if(r){var s;try{s=decodeURIComponent(t.s)}catch(e){console.log("decodeURIComponent FAIL:"),console.log(t.s),s=t.s}t.init||(t.el=w3_appendElement(r,"pre",""),t.esc={s:"",state:0},t.sgr={span:0,bright:0,fg:null,bg:null},t.init=!0);var o="",n=w3_el(i),_=null;isUndefined(t.tstr)&&(t.tstr=""),isUndefined(t.col)&&(t.col=0),!t.process_return_alone||"\r"!=s.charAt(0)||1!=s.length&&"\n"==s.charAt(1)||(s=s.substring(1),t.tstr=o="",t.col=0),t.remove_returns&&(s=s.replace(/\r/g,""));for(var a=0;a<s.length;a++){var c=s.charAt(a);if("\f"==c){for(;r.firstChild;)r.removeChild(r.firstChild);t.el=w3_appendElement(r,"pre",""),t.tstr=o="",t.col=0}else if("\t"==c)for(o+="&nbsp;",t.col++;0!=(7&t.col);)o+="&nbsp;",t.col++;else if(""==c)t.esc.s="",t.esc.state=1;else if(1==t.esc.state)if(c<"@"||"["==c)t.esc.s+=c;else{t.esc.s+=c;var l=t.esc.s.charAt(0),d=t.esc.s.charAt(1),p=0;if("["==l)if("m"==c){for(var w,f=0,u=0,m=t.esc.s.substr(1).split(";"),g=m.length,b=0;b<g&&0==p;b++)if(0==(w=""==m[b]||"m"==m[b]?0:parseInt(m[b])))t.sgr.fg=t.sgr.bg=null,f=1;else if(isNaN(w))p=2;else if(1==w)t.sgr.bright=8;else if(2==w)t.sgr.bright=0;else if(22==w)t.sgr.bright=0;else if(7==w){var k=t.sgr.fg;t.sgr.fg=t.sgr.bg,t.sgr.bg=k,null==t.sgr.fg&&(t.sgr.fg=[255,255,255]),null==t.sgr.bg&&(t.sgr.bg=[0,0,0]),u=1}else if(27==w)t.sgr.fg=t.sgr.bg=null,u=1;else if(w>=30&&w<=37)t.sgr.fg=ansi.colors[w-30+t.sgr.bright],u=1;else if(w>=90&&w<=97)t.sgr.fg=ansi.colors[w-90+8],u=1;else if(39==w)t.sgr.fg=null,u=1;else if(w>=40&&w<=47)t.sgr.bg=ansi.colors[w-40+t.sgr.bright],u=1;else if(w>=100&&w<=107)t.sgr.bg=ansi.colors[w-100+8],u=1;else if(49==w)t.sgr.bg=null,u=1;else if(38==w||48==w){var v,h,x,y,S,T;3!=g||5!=parseInt(m[1])||isNaN(v=parseInt(m[2]))?5!=g||2!=parseInt(m[1])||isNaN(h=parseInt(m[2]))||isNaN(x=parseInt(m[3]))||isNaN(y=parseInt(m[4]))?p=2:(S=[h=w3_clamp(h,0,255),x=w3_clamp(x,0,255),y=w3_clamp(y,0,255)],38==w?t.sgr.fg=S:t.sgr.bg=S,u=1):(b+=2,v<=15?(S=ansi.colors[v],38==w?t.sgr.fg=S:t.sgr.bg=S,u=1):v<=231?(v-=16,v-=36*(h=Math.floor(v/36)),y=v-=6*(x=Math.floor(v/6)),S=[h=Math.floor(255*h/5),x=Math.floor(255*x/5),y=Math.floor(255*y/5)],38==w?t.sgr.fg=S:t.sgr.bg=S,u=1):v<=255?(S=[T=8+10*(v-232),T,T],38==w?t.sgr.fg=S:t.sgr.bg=S,u=1):p=2)}else p=2;f?t.sgr.span&&(o+="</span>",t.sgr.span=0):u?(t.sgr.span&&(o+="</span>"),o+='<span style="'+(t.sgr.fg?"color:"+kiwi_rgb(t.sgr.fg)+";":"")+(t.sgr.bg?"background-color:"+kiwi_rgb(t.sgr.bg)+";":"")+'">',t.sgr.span=1):p=2}else"K"==c?p="erase in line":"P"==c?p="del # chars":"?"==d?p="set/reset mode":"r"==c||(p="l"==c?"reset mode":"J"==c?"2"==d||"3"==d?"erase whole display":"1"==d?"erase start to cursor":2:"H"==c?"move row,col":"d"==c?"move row":"G"==c?"move col":2);else"("==l||(p=2);1===p?console.log("ESC "+JSON.stringify(t.esc.s)+" IGNORED"):2===p?console.log("ESC "+JSON.stringify(t.esc.s)+" UNKNOWN"):isString(p)&&console.log("ESC "+JSON.stringify(t.esc.s)+" "+p),t.esc.state=0}else(c>=" "&&c<="~"||"\n"==c)&&("<"==c?(o+="&lt;",t.col++):">"==c?(o+="&gt;",t.col++):("\n"!=c&&(o+=c,t.col++),"\n"!=c&&t.col!=t.ncol||(_=kiwi_isScrolledDown(n),t.tstr+=o,""==t.tstr&&(t.tstr="&nbsp;"),t.el.innerHTML=t.tstr,t.tstr=o="",t.el=w3_appendElement(r,"pre",""),t.col=0,w3_contains(n,"w3-scroll-down")&&(!t.scroll_only_at_bottom||t.scroll_only_at_bottom&&_)&&(n.scrollTop=n.scrollHeight))))}_=kiwi_isScrolledDown(n),t.tstr+=o,t.el.innerHTML=t.tstr,w3_contains(n,"w3-scroll-down")&&(!t.scroll_only_at_bottom||t.scroll_only_at_bottom&&_)&&(n.scrollTop=n.scrollHeight)}else console.log("kiwi_output_msg NOT_FOUND id="+e)}function gps_stats_cb(e,i,t,r,s,o){var n=(e?"yes":"pause")+", track "+i+", good "+t+", fixes "+r.toUnits();w3_el_softfail("id-msg-gps").innerHTML="GPS: acquire "+n,w3_innerHTML("id-status-gps",w3_text(optbar_prefix_color,"GPS"),w3_text("","acq "+n)),extint_adc_clock_Hz=1e6*s,extint_adc_gps_clock_corr=o,o&&(n=s.toFixed(6)+" ("+o.toUnits()+" avgs)",w3_el_softfail("id-msg-gps").innerHTML+=", ADC clock "+n,w3_innerHTML("id-status-adc",w3_text(optbar_prefix_color,"ADC clock "),w3_text("",n)))}function admin_stats_cb(e,i,t,r,s,o,n,_){if(null!=e){var a=w3_el("id-msg-errors");if(a&&(a.innerHTML="Stats: "+e.toUnits()+" dropped, "+i.toUnits()+" underruns, "+t.toUnits()+" sequence, "+r.toUnits()+" realtime"),a=w3_el("id-status-dp-hist")){for(var c="Datapump: ",l=0;l<s;l++)c+=(l?", ":"")+o[l].toUnits();a.innerHTML=c}if(a=w3_el("id-status-in-hist")){for(c="SoundInQ: ",l=0;l<n;l++)c+=(l?", ":"")+_[l].toUnits();a.innerHTML=c}}}function kiwi_too_busy(e){kiwi_show_msg("Sorry, the KiwiSDR server is too busy right now ("+e+(e>1?" users":" user")+' max). <br>Please check <a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> for more KiwiSDR receivers available world-wide.')}function kiwi_exclusive_use(){kiwi_show_msg('Sorry, this Kiwi has been locked for special use. <br>This happens when using an extension (e.g. DRM decoder) that requires all available resources. <br>Please check <a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> for more KiwiSDR receivers available world-wide. <br><br>申し訳ありませんが、このキーウィは特別な使用のためにロックされています。 <br>これは、利用可能なすべてのリソースを必要とする拡張機能（DRM デコーダーなど）を使用している場合に発生します。 <br>世界中で利用できる KiwiSDR レシーバーについては、<a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> を確認してください。')}function kiwi_ip_limit_pwd_cb(e){console.log("kiwi_ip_limit_pwd_cb pwd="+e),writeCookie("iplimit",encodeURIComponent(e)),window.location.reload(!0)}function kiwi_show_error_ask_exemption(e){kiwi_show_msg(e+='<br><br>If you have an exemption password from the KiwiSDR owner/admin <br> please enter it here: <form name="pform" style="display:inline-block" action="#" onsubmit="kiwi_ip_limit_pwd_cb(this.pinput.value); return false">'+w3_input('w3-label-inline w3-label-not-bold/kiwi-pw|padding:1px|name="pinput" size=40 onclick="this.focus(); this.select()"',"Password:")+"</form>"),document.pform.pinput.focus(),document.pform.pinput.select()}function kiwi_inactivity_timeout(e){kiwi_show_msg("Sorry, this KiwiSDR has an inactivity timeout after "+e+" minutes.<br>Reload the page to continue.")}function kiwi_24hr_ip_limit(e,i){kiwi_show_error_ask_exemption("Sorry, this KiwiSDR can only be used for "+e+' minutes every 24 hours by each IP address.<br>Please check <a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> for more KiwiSDR receivers available world-wide.')}function kiwi_password_entry_timeout(){kiwi_show_msg("Timeout. Please reload page to continue.")}function kiwi_up(e){seriousError||(w3_hide("id-kiwi-msg-container"),w3_show_block("id-kiwi-container"),w3_el("id-kiwi-body").style.overflow="hidden")}function kiwi_down(e,i,t){var r;1==(e=+e)?(r='Sorry, software update in progress. Please check back in a few minutes.<br>Or check <a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> for more KiwiSDR receivers available world-wide.',i>0&&i<9e3?r+="<br>Build: compiling file #"+i:9997==i?r+="<br>Build: linking":9998==i?r+="<br>Build: installing":9999==i&&(r+="<br>Build: done")):2==e?r="Backup in progress.":(null!=t&&""!=t||(t='Sorry, this KiwiSDR server is being used for development right now. <br>Please check <a href="http://rx.kiwisdr.com" target="_self">rx.kiwisdr.com</a> for more KiwiSDR receivers available world-wide.'),r=t),kiwi_show_msg(r)}var stats_interval=1e4,need_config=!0;function stats_init(){need_config&&(msg_send("SET GET_CONFIG"),need_config=!1),stats_update()}function stats_update(){msg_send("SET STATS_UPD ch="+rx_chan);var e=new Date,i=Math.ceil(e/stats_interval)*stats_interval-e;i<stats_interval/2&&(i+=stats_interval),setTimeout(stats_update,i)}function status_periodic(){w3_innerHTML("id-status-stats-cpu",kiwi_cpu_stats_str),w3_innerHTML("id-status-stats-xfer",kiwi_xfer_stats_str),w3_innerHTML("id-msg-stats-cpu",kiwi_cpu_stats_str_long),w3_innerHTML("id-msg-stats-xfer",kiwi_xfer_stats_str_long)}var kiwi_xfer_stats_str="",kiwi_xfer_stats_str_long="";function xfer_stats_cb(e,i,t,r,s){kiwi_xfer_stats_str=w3_text(optbar_prefix_color,"Net")+w3_text("","aud "+e.toFixed(0)+", wf "+i.toFixed(0)+", http "+r.toFixed(0)+", total "+s.toFixed(0)+" kB/s"),kiwi_xfer_stats_str_long="Network (all channels): audio "+e.toFixed(0)+" kB/s, waterfall "+i.toFixed(0)+" kB/s ("+t.toFixed(0)+" fps), http "+r.toFixed(0)+" kB/s, total "+s.toFixed(0)+" kB/s ("+(8*s).toFixed(0)+" kb/s)"}var kiwi_cpu_stats_str="",kiwi_cpu_stats_str_long="",kiwi_config_str="",kiwi_config_str_long="";function cpu_stats_cb(e,i,t,r){d%=100;var s=e.cc?e.cc:0,o=9*s/5+32,n=e.cc?e.cc>=60?"w3-text-css-red w3-bold":e.cc>=50?"w3-text-css-yellow":"w3-text-css-lime":"",_=s?s.toFixed(0)+"&deg;C "+o.toFixed(0)+"&deg;F ":"",a=e.cf>=1e3?(e.cf/1e3).toFixed(1)+" GHz":e.cf.toFixed(0)+" MHz";kiwi_cpu_stats_str=w3_text(optbar_prefix_color,"BB ")+w3_text("",e.cu[0]+","+e.cs[0]+","+e.ci[0]+" usi% ")+(s?w3_text(n,_):"")+w3_text("",a+" ")+w3_text(optbar_prefix_color,"FPGA")+w3_text("",t.toFixed(0)+"%"),kiwi.wf_fps=r;for(var c="",l="",d="",p=!0,w=0;w<e.cu.length;w++)c+=(p?"":" ")+e.cu[w]+"%",l+=(p?"":" ")+e.cs[w]+"%",d+=(p?"":" ")+e.ci[w]+"%",p=!1;var f="cpu";if(e.cu.length>1){f+="0";for(w=1;w<e.cu.length;w++)f+=" cpu"+w}kiwi_cpu_stats_str_long=w3_inline("",w3_text("w3-text-black","Beagle: "+f+" "+c+" usr | "+l+" sys | "+d+" idle,"+(s?"":" "))+(s?"&nbsp;"+w3_text(n+" w3-text-outline w3-large",_)+"&nbsp;":"")+w3_text("w3-text-black",a+", ")+w3_text("w3-text-black","FPGA eCPU: "+t.toFixed(0)+"%"));var u=i,m=Math.trunc(u%60);u=Math.trunc(u/60);var g=Math.trunc(u%60);u=Math.trunc(u/60);var b=Math.trunc(u%24),k=u=Math.trunc(u/24),v=" ";k&&(v+=k+"d:"),v+=b+":"+g.leadingZeros(2)+":"+m.leadingZeros(2),w3_innerHTML("id-status-config",w3_text(optbar_prefix_color,"Up"),w3_text("",v+", "+kiwi_config_str)),v=" | Uptime: ",k&&(v+=k+" "+(k>1?"days":"day")+" "),v+=b+":"+g.leadingZeros(2)+":"+m.leadingZeros(2);var h=""==server_time_local||"null"==server_time_tzname;server_time_utc&&(v+=" | UTC: "+server_time_utc),isDefined(server_time_tzname)&&(v+=" | Local: ",h||(v+=server_time_local+" "),v+=h?"Lat/lon needed for local time":server_tz),w3_innerHTML("id-msg-config",kiwi_config_str_long+v)}function config_str_update(e,i,t,r){kiwi_config_str="v"+t+"."+r+", "+e+" SDR ch, "+i+" GPS ch",w3_innerHTML("id-status-config",kiwi_config_str),kiwi_config_str_long="Config: v"+t+"."+r+", "+e+" SDR channels, "+i+" GPS channels",w3_innerHTML("id-msg-config",kiwi_config_str)}var config_net={};function config_cb(e,i,t,r,s,o,n,_,a,c,l){config_str_update(e,i,c,l);var d=w3_el("id-net-config");d&&(d.innerHTML=w3_div("",w3_col_percent("",w3_div("","Public IP address (outside your firewall/router): "+r+" [port "+s+"]"),50,w3_div("","Ethernet MAC address: "+a.toUpperCase()),30,w3_div("","KiwiSDR serial number: "+t),20),w3_col_percent("",w3_div("","Private IP address (inside your firewall/router): "+o+" [port "+n+"]"),50,w3_div("","Private netmask: /"+_),50)),config_net.pub_ip=r,config_net.pub_port=s,config_net.pvt_ip=r,config_net.pvt_port=n,config_net.mac=a,config_net.serno=t)}function update_cb(e,i,t,r,s,o,n,_,a,c,l){config_str_update(r,s,o,n);var d,p=w3_el("id-msg-update");p&&(d="Installed version: v"+o+"."+n+", built "+c+" "+l,d+=e?"<br>Cannot build, filesystem is FULL!":t?"<br>Update to version v"+ +_+"."+a+" in progress":i?"<br>Update check pending":-1==_?"<br>Error determining the latest version -- check log":o==_&&n==a?"<br>Running most current version":"<br>Available version: v"+_+"."+a,p.innerHTML=d)}var users_interval=2500,user_init=!1;function users_init(e){console.log("users_init #rx="+rx_chans);for(var i=0;i<rx_chans;i++)divlog("RX"+i+': <span id="id-user-'+i+'"></span> '+(e?w3_button("id-user-kick-"+i+" w3-small w3-white w3-border w3-border-red w3-round-large w3-padding-0 w3-padding-LR-8","Kick","status_user_kick_cb",i):""));users_update(),w3_call("users_setup"),user_init=!0}function users_update(){msg_send("SET GET_USERS"),setTimeout(users_update,users_interval)}function user_cb(e){e.forEach(function(e){var i="",t="",r=e.i,s=e.n,o=e.f,n=e.g,_=isDefined(e.a)&&""!=e.a?e.a+", ":"",a=e.m,c=e.z,l=e.t,d="";if(e.rt){var p=1==e.rt?" act":" 24h";d=" "+w3_text("w3-text-css-orange|vertical-align:bottom",e.rs+p)}var w=e.e;if(isDefined(s)){var f=kiwi_strip_tags(decodeURIComponent(s),"");""!=f&&(f='"'+f+'" ');var u="(null)"==n||""==n?"unknown location":decodeURIComponent(n);u="("+(_=_.replace(/::ffff:/,""))+u+") ";var m,g=(m=((m=o+1e3*cfg.freq_offset)/1e3).toFixed(m>1e8?1:2))+" kHz ",b='<a href="javascript:tune('+(o/1e3).toFixed(2)+","+sq(a)+","+c+');">';""!=w&&(w=decodeURIComponent(w)+" "),i=f+u,t=b+g+a+" z"+c+"</a> "+w+l+d}if(user_init){w3_innerHTML("id-user-"+r,i+t);var k="id-user-kick-"+r;w3_el(k)&&(""!=i?w3_show_inline_block(k):w3_hide(k)),w3_innerHTML("id-optbar-user-"+r,""!=i?i+"<br>"+t:"")}if(e.c){var v=w3_el("id-sam-carrier");v&&w3_innerHTML(v,"carrier "+e.c.toFixed(1)+" Hz")}if(r==rx_chan&&e.rn&&e.rn<=55&&!kiwi.inactivity_panel){confirmation_show_content("Inactivity timeout in one minute.<br>Close this panel to avoid disconnection.",350,55,function(){msg_send("SET inactivity_ack"),confirmation_panel_close(),kiwi.inactivity_panel=!1},"red"),kiwi.inactivity_panel=!0}e.rn>55&&kiwi.inactivity_panel&&(confirmation_panel_close(),kiwi.inactivity_panel=!1)})}var toggle_e={SET:1,SET_URL:2,FROM_COOKIE:4,WRITE_COOKIE:8};function kiwi_toggle(e,i,t,r){var s=null;if(e&toggle_e.SET_URL&&(null!=i||null!=i))s=i;else if(e&toggle_e.FROM_COOKIE&&null!=(s=readCookie(r))){var o=parseFloat(s);isNaN(o)||(s=o)}return null==s&&e&toggle_e.SET&&(s=i),null==s&&(s=t),s}function kiwi_plot_max(e){var i=bi[e];return 1024/(i.samplerate/i.plot_samplerate)}function kiwi_fft_mode(){setmaxdb(-30)}function kiwi_mapPinSymbol(e,i){return{path:"M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z",fillColor:e=e||"red",fillOpacity:1,strokeColor:i=i||"white",strokeWeight:1,scale:1}}var comp_ctr,chan_no_pwd,pref_import_ch,client_public_ip,reason_disabled="",version_maj=-1,version_min=-1,tflags={INACTIVITY:1,WF_SM_CAL:2,WF_SM_CAL2:4},kiwi_output_msg_p={scroll_only_at_bottom:!0,process_return_alone:!1};function kiwi_msg(e,i){var t=!0;switch(e[0]){case"version_maj":version_maj=parseInt(e[1]);break;case"version_min":version_min=parseInt(e[1]);break;case"client_public_ip":client_public_ip=e[1].replace(/::ffff:/,""),console.log("client public IP: "+client_public_ip);break;case"badp":console.log("badp="+e[1]),extint_valpwd_cb(parseInt(e[1]));break;case"chan_no_pwd":chan_no_pwd=parseInt(e[1]);break;case"rx_chans":rx_chans=parseInt(e[1]);break;case"wf_chans":wf_chans=parseInt(e[1]);break;case"wf_chans_real":wf_chans_real=parseInt(e[1]);break;case"rx_chan":rx_chan=parseInt(e[1]);break;case"load_cfg":var r=decodeURIComponent(e[1]);cfg=JSON.parse(r),owrx_cfg();break;case"load_adm":var s=decodeURIComponent(e[1]);adm=JSON.parse(s);break;case"request_dx_update":dx_update();break;case"mkr":dx_label_cb(JSON.parse(e[1]));break;case"user_cb":user_cb(JSON.parse(e[1]));break;case"config_cb":config_cb((o=JSON.parse(e[1])).r,o.g,o.s,o.pu,o.pe,o.pv,o.pi,o.n,o.m,o.v1,o.v2,o.ai);break;case"update_cb":update_cb((o=JSON.parse(e[1])).f,o.p,o.i,o.r,o.g,o.v1,o.v2,o.p1,o.p2,decodeURIComponent(o.d),decodeURIComponent(o.t));break;case"stats_cb":try{var o;null!=(o=JSON.parse(e[1])).ce&&cpu_stats_cb(o,o.ct,o.ce,o.fc),xfer_stats_cb(o.ac,o.wc,o.fc,o.ah,o.as),extint_srate=o.sr,gps_stats_cb(o.ga,o.gt,o.gg,o.gf,o.gc,o.go),o.gr&&(kiwi.WSPR_rgrid=decodeURIComponent(o.gr),kiwi.GPS_fixes=o.gf),admin_stats_cb(o.ad,o.au,o.ae,o.ar,o.an,o.ap,o.an2,o.ai),time_display_cb(o)}catch(i){console.log("<"+e[1]+">"),console.log("kiwi_msg() stats_cb: JSON parse fail"),console.log(i)}break;case"status_msg_text":kiwi_output_msg_p.s=e[1],kiwi_output_msg("id-output-msg","id-output-msg",kiwi_output_msg_p);break;case"status_msg_html":var n=decodeURIComponent(e[1]);w3_innerHTML("id-status-msg",n),w3_innerHTML("id-msg-status",n);break;case"is_admin":extint_isAdmin_cb(e[1]);break;case"is_local":var _=e[1].split(",");console.log("kiwi_msg rx_chan="+_[0]+" is_local="+_[1]),kiwi.is_local[+_[0]]=+_[1];break;case"is_multi_core":kiwi.is_multi_core=1;break;case"authkey_cb":extint_authkey_cb(e[1]);break;case"down":kiwi_down(e[1],comp_ctr,reason_disabled);break;case"too_busy":kiwi_too_busy(parseInt(e[1]));break;case"exclusive_use":kiwi_exclusive_use();break;case"inactivity_timeout":kiwi_inactivity_timeout(e[1]);break;case"ip_limit":_=decodeURIComponent(e[1]).split(",");kiwi_24hr_ip_limit(parseInt(_[0]),_[1]);break;case"password_timeout":kiwi_password_entry_timeout();break;case"comp_ctr":comp_ctr=e[1];break;case"reason_disabled":reason_disabled=decodeURIComponent(e[1]);break;case"sample_rate":extint_srate=parseFloat(e[1]);break;case"pref_import_ch":pref_import_ch=+e[1];break;case"pref_import":pref_import_cb(e[1],pref_import_ch);break;case"adc_clk_nom":extint_adc_clock_nom_Hz=+e[1];break;default:t=!1}return t}function kiwi_debug(e){console.log(e),msg_send("SET dbug_msg="+encodeURIComponent(e))}function divlog(e,i){isDefined(i)&&i&&(e='<span class="class-error">'+e+"</span>"),w3_el_softfail("id-debugdiv").innerHTML+=e+"<br />"}function kiwi_show_msg(e){html("id-kiwi-msg").innerHTML=e,""==e?(w3_hide("id-kiwi-msg-container"),w3_el("id-kiwi-body").style.overflow="hidden"):(w3_hide("id-kiwi-container"),w3_show_block("id-kiwi-msg-container"),w3_el("id-kiwi-body").style.overflow="scroll")}function kiwi_server_error(e){kiwi_show_msg('Hmm, there seems to be a problem. <br>The server reported the error: <span style="color:red">'+e+"</span>"),seriousError=!0}function kiwi_serious_error(e){kiwi_show_msg(e),seriousError=!0,console.log(e)}function kiwi_trace(e){e&&console.log("console.trace: "+e);try{console.trace()}catch(e){}}function kiwi_trace_mobile(e){alert(e+" "+Error().stack)}




/* web/kiwi/kiwi_ui.min.js */
var DX_MODE=15,DX_TYPE=240,DX_TYPE_SFT=4,DX_FLAG=65280,dxo={};function dx_update_check(o){if(-1!=(o=+o)){console.log("### dx_update_check idx="+o),dxo.gid=o;var d=dxo.tags[o];dxo.tag=d;var _=function(d){return w3_get_value("dxo."+d+"_"+o)};dxo.f=+_("f"),dxo.o=+_("o"),console.log("dxo:"),console.log(dxo);var x=dxo.m;x|=dxo.y<<DX_TYPE_SFT,dxo.f-=cfg.freq_offset,dxo.f<0&&(dxo.f=0),console.log("SET DX_UPD g="+dxo.gid+" f="+dxo.f+" lo="+dxo.lo.toFixed(0)+" hi="+dxo.hi.toFixed(0)+" o="+dxo.o.toFixed(0)+" m="+x+" t="+d+" i="+dxo.i+" n="+dxo.n+" p="+dxo.p)}}function dx_num_cb(o,d,_){if(!_){var x=w3_remove_trailing_index(o,"_");w3_num_cb(x.el,d),dx_update_check(x.idx)}}function dx_sel_cb(o,d,_){if(!_){console.log("dx_sel_cb path="+o+" val="+d+" first="+_);var x=w3_remove_trailing_index(o,"_");w3_string_cb(x.el,d),dx_update_check(x.idx)}}function dx_string_cb(o,d,_){if(!_){var x=w3_remove_trailing_index(o,"_");w3_string_cb(x.el,d),dx_update_check(x.idx)}}function dx_passband_cb(o,d,_){if(!_){var x=d.split(/[,\s]/),i=x.length;if(console.log("dx_passband_cb path="+o+" val="+d+" a.len="+i),console.log(x),1==i&&""!=x[0]){var e=Math.round(x[0].parseFloatWithUnits("kM")/2);dxo.lo=-e,dxo.hi=e}else i>=1&&""!=x[0]&&""!=x[i-1]?(dxo.lo=Math.round(x[0].parseFloatWithUnits("kM")),dxo.hi=Math.round(x[i-1].parseFloatWithUnits("kM"))):dxo.lo=dxo.hi=0;console.log("dx_passband_cb lo="+dxo.lo+" hi="+dxo.hi),dx_update_check(w3_remove_trailing_index(o,"_").idx)}}

/* web/kiwi/kiwi_util.min.js */
function isUndefined(i){return void 0===i}function isDefined(i){return void 0!==i}function isNull(i){return null===i}function isNumber(i){return"number"==typeof i}function isBoolean(i){return"boolean"==typeof i}function isString(i){return"string"==typeof i}function isArray(i){return Array.isArray(i)}function isFunction(i){return"function"==typeof i}function isObject(i){return"object"==typeof i}function isArg(i){return!isUndefined(i)&&!isNull(i)}try{String.prototype.includes||(String.prototype.includes=function(i){return this.indexOf(i)>=0})}catch(i){console.log("kiwi_util: String.prototype.includes")}try{String.prototype.startsWith||(String.prototype.startsWith=function(i){return 0==this.indexOf(i)})}catch(i){console.log("kiwi_util: String.prototype.startsWith")}try{String.prototype.endsWith||(String.prototype.endsWith=function(i,e){return(void 0===e||e>this.length)&&(e=this.length),this.substring(e-i.length,e)===i})}catch(i){console.log("kiwi_util: String.prototype.endsWith")}var kiwi_iOS,kiwi_OSX,kiwi_linux,kiwi_Windows,kiwi_android,kiwi_safari,kiwi_firefox,kiwi_chrome,kiwi_opera,kiwi_smartTV,kiwi_util={};function kiwi_is_iOS(){return kiwi_iOS}function kiwi_isOSX(){return kiwi_OSX}function kiwi_isWindows(){return kiwi_Windows}function kiwi_isLinux(){return kiwi_linux}function kiwi_isAndroid(){return kiwi_android}function kiwi_isMobile(){return kiwi_isAndroid()||kiwi_is_iOS()}function kiwi_isSafari(){return kiwi_safari?kiwi_safari[1]:NaN}function kiwi_isFirefox(){return kiwi_firefox?kiwi_firefox[1]:NaN}function kiwi_isChrome(){return kiwi_chrome?kiwi_chrome[1]:NaN}function kiwi_isOpera(){return kiwi_opera?kiwi_opera[1]:NaN}function kiwi_isSmartTV(){return kiwi_smartTV?kiwi_smartTV[1]:NaN}document.onreadystatechange=function(){if("complete"==document.readyState){var i=navigator.userAgent;console.log(i),kiwi_iOS=i.includes("iPhone")||i.includes("iPad"),kiwi_OSX=i.includes("OS X"),kiwi_linux=i.includes("Linux"),kiwi_Windows=i.includes("Win"),kiwi_android=i.includes("Android"),kiwi_safari=/safari\/([0-9]+)/i.exec(i),kiwi_browserVersion=/version\/([0-9]+)/i.exec(i),kiwi_firefox=/firefox\/([0-9]+)/i.exec(i),kiwi_chrome=/chrome\/([0-9]+)/i.exec(i),(kiwi_opera=/opera\/([0-9]+)/i.exec(i))||(kiwi_opera=/OPR\/([0-9]+)/i.exec(i)),kiwi_smartTV=/SmartTV\/([0-9]+)/i.exec(i),console.log("iOS="+kiwi_iOS+" OSX="+kiwi_OSX+" Linux="+kiwi_linux+" Windows="+kiwi_Windows+" android="+kiwi_android),kiwi_opera?kiwi_chrome=kiwi_safari=null:kiwi_chrome?kiwi_safari=null:kiwi_safari&&kiwi_browserVersion&&(kiwi_safari[1]=kiwi_browserVersion[1]),console.log("safari="+kiwi_isSafari()+" firefox="+kiwi_isFirefox()+" chrome="+kiwi_isChrome()+" opera="+kiwi_isOpera()),"undefined"!=typeof kiwi_check_js_version?kiwi_ajax("/VER","kiwi_version_cb"):"undefined"!=typeof kiwi_bodyonload&&kiwi_bodyonload("")}};var kiwi_version_fail=!1;function kiwi_version_cb(i){version_maj=i.maj,version_min=i.min;var e="";kiwi_check_js_version.forEach(function(i){i.VERSION_MAJ==version_maj&&i.VERSION_MIN==version_min||(0==kiwi_version_fail&&(e="Your browser is trying to use incorrect versions of the KiwiSDR Javascript files.<br>Please clear your browser cache and try again.<br>Or click the button below to continue anyway.<br><br>v"+version_maj+"."+version_min+": KiwiSDR server<br>",kiwi_version_fail=!0),e+="v"+i.VERSION_MAJ+"."+i.VERSION_MIN+": "+i.file+"<br>")}),kiwi_version_fail&&(e+="<br>"+w3_button("w3-css-yellow","Continue anyway","kiwi_version_continue_cb")),kiwi_bodyonload(e)}function kiwi_version_continue_cb(){seriousError=!1,kiwi_bodyonload("")}function sq(i){return"'"+i+"'"}function dq(i){return'"'+i+'"'}function arrayBufferToString(i){return String.fromCharCode.apply(null,new Uint8Array(i))}function arrayBufferToStringLen(e,r){var n=new Uint8Array(e),t=String();for(r=Math.min(r,n.length),i=0;i<r;i++)t+=String.fromCharCode(n[i]);return t}function getFirstChars(i,e){arrayBufferToStringLen(i,e)}function kiwi_inet4_d2h(i){var e=i.split(".");return(255&e[0])<<24|(255&e[1])<<16|(255&e[2])<<8|255&e[3]}function kiwi_h2n_32(i,e){var r;switch(e){case 0:r=i>>24;break;case 1:r=i>>16;break;case 2:r=i>>8;break;case 3:r=i;break;default:r=0}return 255&r}function kiwi_ip_str(i){var e="";return isNumber(i)?e=kiwi_h2n_32(i,0)+"."+kiwi_h2n_32(i,1)+"."+kiwi_h2n_32(i,2)+"."+kiwi_h2n_32(i,3):isArray(i)?e=i[3]+"."+i[2]+"."+i[1]+"."+i[0]:isObject(i)&&(e=i.a+"."+i.b+"."+i.c+"."+i.d),e}function kiwi_clearTimeout(i){try{clearTimeout(i)}catch(i){}}function kiwi_clearInterval(i){try{clearInterval(i)}catch(i){}}Number.prototype.leadingZeros=function(i){var e=String(this);for(isNumber(i)||(i=2);e.length<i;)e="0"+e;return e},String.prototype.leadingZeros=function(i){var e=String(this);for(isNumber(i)||(i=2);e.length<i;)e="0"+e;return e},String.prototype.fieldWidth=function(i){var e=String(this);if(!isNumber(i))return e;for(;e.length<i;)e=" "+e;return e},String.prototype.filterInt=function(){var i=String(this);return/^(\-|\+)?([0-9]+|Infinity)$/.test(i)?Number(i):NaN},String.prototype.withSign=function(){var i=this;return Number(i)<0?i:"+"+i},String.prototype.positiveWithSign=function(){var i=this;return Number(i)<=0?i:"+"+i},Number.prototype.toHex=function(i){isNumber(i)||(i=0);var e=i<0?0:1;i=Math.abs(i);for(var r=Number(this),n=(r>>>=0).toString(16);n.length<i;)n="0"+n;return e&&(n="0x"+n),n},Number.prototype.toUnits=function(){var i=Number(this);return i<1e3?i.toString():i<1e6?(i/1e3).toFixed(1)+"k":i<1e9?(i/1e6).toFixed(1)+"M":(i/1e9).toFixed(1)+"G"},String.prototype.parseFloatWithUnits=function(i,e){var r=String(this),n=parseFloat(r);return isNaN(n)?NaN:(i&&!i.includes("k")||new RegExp("([-0-9.]*k)").test(r)&&(n*=1e3,e&&(n*=e)),i&&!i.includes("M")||new RegExp("([-0-9.]*M)").test(r)&&(n*=1e6,e&&(n*=e)),n)},Number.prototype.withSign=function(){var i=Number(this),e=i.toString();return i<0?e:"+"+e};var littleEndian=function(){var i=new ArrayBuffer(2);return new DataView(i).setInt16(0,256,!0),256===new Int16Array(i)[0]}();function _nochange(i){if(0!=arguments.length)return void 0===i}function _default(i){return 0==arguments.length?NaN:isNaN(i)}function _change(i){return!_nochange(i)&&!_default(i)}function console_log(){for(var i,e=0;e<arguments.length;e++){var r=arguments[e];0==e?i=r+": ":i+="arg"+(e-1)+"="+r+" "}console.log("CONSOLE_LOG "+i)}function console_log_fqn(){for(var i,e=0;e<arguments.length;e++){var r=arguments[e];if(0==e)i=r+": ";else{var n;try{n=getVarFromString(r)}catch(i){n="[not defined]"}var t=r.lastIndexOf(".");i+=(-1==t?r:r.substr(t+1))+"="+n+" "}}console.log("FQN "+i)}function console_log_dbgUs(){if(dbgUs){s="";for(var i=0;i<arguments.length;i++)s+=arguments[i].toString();console.log(s)}}function kiwi_log(i){setTimeout(function(i){console.log(i)},1,i)}function kiwi_rateLimit(i,e){var r=!1;return function(){if(!r){r=!0;var n=arguments;setTimeout(function(){r=!1,i.apply(this,n)},e)}}}function kiwi_UTC_minutes(){var i=new Date;return 60*i.getUTCHours()+i.getUTCMinutes()}function kiwi_hh_mm(i){if(isNumber(i))return i;if(isString(i)){var e=i.split(":"),r=+e[0];if(e.length>1){var n=+e[1]/60;r=r<0?r-n:r+n}return"-0"!=e[0]&&"-00"!=e[0]||(r=-r),r}return null}function kiwi_clean_html(i){return i.replace(/\&/g,"&amp;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;")}function kiwi_clean_newline(i){return i.replace(/[\r\n\f\v]/g,"").replace(/\t/g," ")}function kiwi_isScrolledDown(i){return i.scrollHeight-i.scrollTop===i.clientHeight}function kiwi_url_origin(){var i;try{i=window.location.origin}catch(e){i=(i=this.location.href).split("?")[0]}return i}function kiwi_url_param(i,e,r){var n=isArray(i);null==e&&(e=!0),null==r&&(r=null);var t=window.location&&window.location.search&&window.location.search.substr(1);if(!t)return r;var o=r;return t.split("&").forEach(function(r){var t=r.split("=");n?i.forEach(function(i){i==t[0]&&(o=t.length>=2?t[1]:e)}):i==t[0]&&(o=t.length>=2?t[1]:e)}),o}var kiwiint_dummy_elem={};function html(i){var e=w3_el(i);try{e.value}catch(r){console.log("html('"+i+"')="+e+" FAILED"),dbgUs&&dbgUsFirst&&(dbgUsFirst=!1)}return null==e&&(e=kiwiint_dummy_elem),e}function px(i){if(!isArg(i)||""==i)return"0";var e=parseFloat(i);return isNaN(e)?(console.log("px num="+i),kiwi_trace(),"0"):e.toFixed(0)+"px"}function css_style(i,e){return getComputedStyle(i,null).getPropertyValue(e)}function css_style_num(i,e){var r=parseInt(css_style(i,e));return isNaN(r)&&(r=0),r}function html_LR_border_pad(i){return css_style_num(i,"border-left-width")+css_style_num(i,"border-right-width")+css_style_num(i,"padding-left")+css_style_num(i,"padding-right")}function cancelEvent(i){return(i=i||window.event).stopPropagation&&i.stopPropagation(),i.preventDefault&&i.preventDefault(),i.stopImmediatePropagation&&i.stopImmediatePropagation(),i.cancelBubble=!0,i.cancel=!0,i.returnValue=!1,!1}function ignore(i){return cancelEvent(i)}function kiwi_rgb(i,e,r){return null==i?"":(isArray(i)&&(e=i[1],r=i[2],i=i[0]),"rgb("+Math.floor(i)+","+Math.floor(e)+","+Math.floor(r)+")")}function hsl(i,e,r){return(e=Math.floor(e))<0&&(e=0),e>100&&(e=100),(r=Math.floor(r))<0&&(r=0),r>100&&(r=100),"hsl("+Math.round(i)+","+e+"%,"+r+"%)"}function createCookie(i,e,r){var n="";if(r){var t=new Date;t.setTime(t.getTime()+24*r*60*60*1e3),n="; expires="+t.toGMTString()}document.cookie=i+"="+e+n+"; path=/"}function readCookie(i,e){for(var r=i+"=",n=document.cookie.split(";"),t=0;t<n.length;t++){for(var o=n[t];" "==o.charAt(0);)o=o.substring(1,o.length);if(0==o.indexOf(r))return o.substring(r.length,o.length)}return isDefined(e)?e:null}function writeCookie(i,e){createCookie(i,e,15330)}function initCookie(i,e){var r=readCookie(i);return null==r?(writeCookie(i,e),e):r}function updateCookie(i,e){var r=readCookie(i);return(null==r||r!=e)&&(writeCookie(i,e),!0)}function deleteCookie(i){null!=readCookie(i)&&createCookie(i,0,-1)}function getVarFromString(e){var r=window,n=e.split(".");for(i=0;i<n.length-1;i++){var t=n[i];if(isUndefined(r=r[t]))throw console.log("getVarFromString: NO SCOPE "+e+" scope_name="+t),"no scope"}return r[n[n.length-1]]}function setVarFromString(e,r){var n=window,t=e.split(".");for(i=0;i<t.length-1;i++)null==n[t[i]]&&(n[t[i]]={}),n=n[t[i]];n[t[t.length-1]]=r}function getType(i){return i&&i.constructor&&i.constructor.name}function kiwi_parseQuery(i){var e=new Object;if(!i)return e;for(var r=i.split(/[;&]/),n=0;n<r.length;n++){var t=r[n].split("=");if(t&&2==t.length){var o=unescape(t[0]),a=unescape(t[1]);a=a.replace(/\+/g," "),e[o]=a}}return e}function kiwi_GETrequest(i,e,r){var n=w3_opt(r,"debug",0),t=document.createElement("iframe"),o=i+"_"+(new Date).toUTCString().substr(17,8);document.body.appendChild(t),t.style.display="none",t.contentWindow.name=o,w3_add(t,"id-kiwi_GETrequest");var a=document.createElement("form");return a.target=o,a.action=e,a.method="GET",w3_add(a,"id-kiwi_GETrequest"),n&&console.log("kiwi_GETrequest: "+o),{iframe:t,form:a,debug:n}}function kiwi_GETrequest_submit(i,e){var r=w3_opt(e,"no_submit",0),n=w3_opt(e,"gc",0);r?console.log("kiwi_GETrequest_submit: NO SUBMIT"):(document.body.appendChild(i.form),i.form.submit(),i.debug&&console.log("kiwi_GETrequest_submit: SUBMITTED")),n&&setTimeout(function(){document.body.removeChild(i.form),document.body.removeChild(i.iframe)},6e4)}function kiwi_GETrequest_param(i,e,r){var n=document.createElement("input");n.type="hidden",n.name=e,n.value=r,i.form.appendChild(n),i.debug&&console.log("kiwi_GETrequest_param: "+e+"="+r)}var ajax_state={DONE:4};function kiwi_ajax(i,e,r,n,t){kiwi_ajax_prim("GET",null,i,e,r,n,void 0,void 0,t)}function kiwi_ajax_progress(i,e,r,n,t,o,a){kiwi_ajax_prim("GET",null,i,e,r,n,t,o,a)}function kiwi_ajax_send(i,e,r,n,t,o){kiwi_ajax_prim("PUT",i,e,r,n,t,void 0,void 0,o)}var ajax_id=0,ajax_requests={};function kiwi_ajax_prim(i,e,r,n,t,o,a,s,u){var c;ajax_id++;var l=function(i){u&&console.log(i)};try{c=new XMLHttpRequest}catch(i){try{c=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{c=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){return!1}}}return c.kiwi_id=ajax_id,ajax_requests[ajax_id]={},ajax_requests[ajax_id].didTimeout=!1,ajax_requests[ajax_id].timer=-1,(o=o||0)&&(ajax_requests[ajax_id].timer=setTimeout(function(){var i=c.kiwi_id;ajax_requests[i].didTimeout=!0,ajax_requests[i].timer=-1,l("AJAX TIMEOUT occurred, recovered id="+i+" url="+r);var e={AJAX_error:"timeout"};isFunction(n)?n(e,t):isString(n)&&w3_call(n,e,t),c.abort(),delete ajax_requests[i]},Math.abs(o))),a&&(l("AJAX with progress_cb="+a),c.onprogress=function(){var i=c.responseText.toString()||"";l("XHR.onprogress="+i),isFunction(a)?a(i,s):isString(a)&&w3_call(a,i,s)}),c.onerror=function(i){l("XHR.onerror="+i),u&&console.log(i)},c.onabort=function(i){l("XHR.onabort="+i),u&&console.log(i)},c.onload=function(i){l("XHR.onload="+i),u&&console.log(i)},c.onloadstart=function(i){l("XHR.onloadstart="+i),u&&console.log(i)},c.onreadystatechange=function(){if(l("XHR.onreadystatechange readyState="+c.readyState),c.readyState!=ajax_state.DONE)return!1;var i=c.kiwi_id,e=ajax_requests[i].timer;if(l("AJAX ORSC ENTER recovered id="+i+" timer="+e+" cb="+n),-1!=e&&(l("AJAX ORSC CLEAR_TIMER recovered id="+i+" timer="+e),kiwi_clearTimeout(e),ajax_requests[i].timer=-1),ajax_requests[i].didTimeout)l("AJAX ORSC TIMED_OUT recovered id="+i);else{var o;if(l("XHR.status="+c.status),l("XHR.statusText="+c.statusText),l("XHR.responseType="+c.responseType),l("XHR.response="+c.response),l("XHR.responseText="+c.responseText),l("XHR.responseURL="+c.responseURL),u&&console.log(c),200!=c.status)l("AJAX bad status="+c.status+" url="+r),o={AJAX_error:"status",status:c.status};else{var a=c.responseText.toString();if(null==a&&(a=""),a.startsWith("<?xml"))o={XML:!0,text:a};else{var s=a.charAt(0);if("{"!=s&&"["!=s)l("AJAX: response didn't begin with JSON '{' or '[' ? "+a),o={AJAX_error:"JSON prefix",response:a};else try{for(;-1!=(cb=a.indexOf("\n//"));)ce=a.indexOf("\n",cb+3),a=a.slice(0,cb)+a.slice(ce),!0;o=JSON.parse(a),l("AJAX JSON response:"),l(a),l(o)}catch(i){l("AJAX response JSON.parse failed: <"+a+">"),l(i),o={AJAX_error:"JSON parse",JSON_ex:i.toString(),response:a}}}}l("AJAX ORSC CALLBACK recovered id="+i+" callback="+typeof n),isFunction(n)?n(o,t):isString(n)&&w3_call(n,o,t)}l("AJAX ORSC ABORT/DELETE"),c.abort(),delete ajax_requests[i]},o>=0&&(c.open(i,r,!0),l("AJAX SEND id="+ajax_id+" url="+r),c.send(e)),!0}function kiwi_scrollbar_width(){return kiwi_isOSX()?10:15}function kiwi_strip_tags(i,e){e=(((e||"")+"").toLowerCase().match(/<[a-z][a-z0-9]*>/g)||[]).join("");return i.replace(/<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi,"").replace(/<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,function(i,r){return e.indexOf("<"+r.toLowerCase()+">")>-1?i:""})}function kiwi_pie(i,e,r,n){var t=2*e;return'<svg width="'+t+'" height="'+t+'" viewbox="0 0 '+t+" "+t+'"><circle cx="'+e+'" cy="'+e+'" r="'+e+'" fill="'+r+'" /><path class="'+i+'" style="fill:'+n+'" transform="translate('+e+", "+e+')" /></svg>'}function kiwi_draw_pie(i,e,r){var n=360*r,t=n*Math.PI/180,o=Math.sin(t)*e,a=Math.cos(t)*-e,s=n>=180?1:0;360==n&&(s=1,o=-.1,a=-e);var u="M 0 0 v "+-e+" A "+e+" "+e+" 1 "+s+" 1 "+o+" "+a+" z";w3_iterate_classname(i,function(i){i.setAttribute("d",u)})}function enc(i){return i.replace(/./gi,function(i){return String.fromCharCode(3^i.charCodeAt(0))})}var sendmail=function(i,e){var r="mailto:"+enc(decodeURIComponent(i))+(isDefined(e)?"?subject="+e:"");window.location.href=r};function line_stroke(i,e,r,n,t,o,a,s){var u=Math.floor(r/2),c=e?r:a-t+1,l=e?s-o+1:r,_=t-(e?u:0),f=o-(e?0:u);i.fillStyle=n,i.fillRect(_,f,c,l)}var wsockets=[];function msg_send(i){for(var e=0;e<wsockets.length;e++){var r=wsockets[e].ws;if(r.up)try{return r.send(i),0}catch(e){return console.log("CATCH msg_send('"+i+"') ex="+e),kiwi_trace(),-1}}return-1}function open_websocket(i,e,r,n,t,o){if(!("WebSocket"in window&&"CLOSING"in WebSocket))return console.log("WEBSOCKET TEST"),kiwi_serious_error("Your browser does not support WebSocket, which is required for OpenWebRX to run. <br> Please use an HTML5 compatible browser."),null;var a=kiwi_url_origin().split("://")[1],s="ws://";"https:"===window.location.protocol&&(s="wss://");var u=window.location.href.includes("?no_wf")||window.location.href.includes("&no_wf");a=s+a+"/"+(u?"no_wf/":"kiwi/")+timestamp+"/"+i,u&&(wf.no_wf=!0);var c=new WebSocket(a);return wsockets.push({ws:c,name:i}),c.up=!1,c.stream=i,c.open_cb=e,c.open_cb_param=r,c.msg_cb=n,c.recv_cb=t,c.error_cb=o,c.onopen=function(){if(c.up=!0,c.open_cb)try{c.open_cb(c.open_cb_param)}catch(i){console.log(i)}},c.onmessage=function(i){try{on_ws_recv(i,c)}catch(i){console.log(i)}},c.onclose=function(i){c.up=!1,console.log("WS-CLOSE: "+c.stream)},c.binaryType="arraybuffer",c.onerror=function(i){if(c.error_cb)try{c.error_cb(i,c)}catch(i){console.log(i)}},c}var kiwi_flush_recv_input=!0;function recv_websocket(i,e){"SND"!=i.stream&&"W/F"!=i.stream&&(i.recv_cb=e,null==e&&(kiwi_flush_recv_input=!0))}function on_ws_recv(i,e){var r=i.data;if(r instanceof ArrayBuffer){if(!seriousError){var n=arrayBufferToStringLen(r,3);if("CLI"!=n){var t=!1;if("MSG"==n){var o=arrayBufferToString(r);params=o.substring(4).split(" ");for(var a=0;a<params.length;a++){var s=params[a].split("=");"EXT"==e.stream&&"EXT-STOP-FLUSH-INPUT"==s[0]&&(kiwi_flush_recv_input=!1),0==(t=kiwi_msg(s,e))&&e.msg_cb&&(t=e.msg_cb(s,e)),0==t&&console.log(">>> "+e.stream+": message not claimed: "+params[a])}}else!e.recv_cb||"EXT"==e.stream&&0!=kiwi_flush_recv_input||(e.recv_cb(r,e,n),isDefined(kiwi_gc_recv)&&kiwi_gc_recv&&(r=null))}}}else console.log("on_ws_recv: not an ArrayBuffer?")}window.onbeforeunload=function(){var i;for(i=0;i<wsockets.length;i++){var e=wsockets[i].ws;e&&(e.onclose=function(){},e.close())}};




/* web/kiwi/w3_util.min.js */
// Copyright (c) 2016-2019 John Seamons, ZL/KF6VO

/*

	///////////////////////////////////////
	// API summary
	///////////////////////////////////////
	
	                           integrated: L=label, T=text
	                           3=psa3()
	nav navdef

	label set_label

	link
   
	radio_button               T
	radio_button_get_param     T
	radio_unhighlight
	
	switch                     T     **Needs L added
	switch_set_value
	
	button                     T
	button_text                T
	icon
	
	input                      L3
	input_change
	input_get
	
	textarea                   L
	textarea_get_param         L
	
	checkbox                   L3
	checkbox_get_param         L
	checkbox_get
	checkbox_set
	
	select                     L3
	select_hier                L
	select_get_param           L
	select_enum
	select_value
	select_set_if_includes
	
	slider                     L3
	slider_set
	
	menu
	menu_items
	menu_popup
	menu_onclick
	
	inline                     3
	inline_percent             3
	divs                       3
	col_percent                3
	
	
	
	///////////////////////////////////////
	// Useful stuff
	///////////////////////////////////////
	
	<element attribute="attribute-values ..." inline-style-attribute="properties ...">
	"styles" refers to any style-attribute="properties ..." combination

	style properties set one of three ways:
		1) in an element as above
		
		2) in a .css:
		selector
		{
			property: property-value;
		}
		
		3) assigned by DOM:
		el.style.property = property-value;
	
	priority (specificity)
	
		[inline-style attribute], [id], [class, pseudo-class, attribute], [elements]
		
		The "count" at each level is determined by the number of specifiers, hence the "specific-ness"
		e.g. ul#nav li.active a => 0,1,1,3 with 3 due to the ul, li and a
		This would have priority over 0,1,1,2
	
	select (menu) behavior:
	   If you set the background-color inline then border reverts to the undesirable beveled appearance!

	in w3.css:
		w3-show-block
		w3-show-inline-block
		
		w3-section: margin TB 16px
		w3-container: padding TB 0.01em LR 16px
		w3-row:after: content: ""; display: table; clear: both
		w3-col: float left, width 100%
		w3-padding: T 8px, B 16px
		w3-row-padding: LR 8px
		w3-margin: TBLR 16px

	in w3_ext.css:
		w3-show-inline
		w3-valign
		w3-override-(colors)

	id="foo" on...(e.g. onclick)=func(this.id)


	Be sure to document our special side-effects:
	   w3-label-inline


	///////////////////////////////////////
	// Notes about HTML/DOM
	///////////////////////////////////////
	
	"Typically, the styles are merged, but when conflicts arise, the later declared style will generally win
	(unless the !important attribute is specified on one of the styles, in which case that wins).
	Also, styles applied directly to an HTML element take precedence over CSS class styles."
	
	window.
		inner{Width,Height}		does not include tool/scroll bars
		outer{Width,Height}		includes tool/scroll bars
	
	element.
		client{Width,Height}		viewable only; no: border, scrollbar, margin; yes: padding
		offset{Width,Height}		viewable only; includes padding, border, scrollbars

	
	///////////////////////////////////////
	// FIXME cleanups
	///////////////////////////////////////
	
	some routines that return nothing now could return el from internal w3_el() so
	   caller could do chained references (see w3_innerHTML(), w3_show() ...)
	
	needs uniform instantiation callbacks
	   - w3_nav
	   x w3_navdef
	   >>> w3_radio_button
	   >>> w3_switch
	   - w3_button (only 1 initial state)
	   - w3_icon
	   ??? w3_input(_psa): integrate, 
	   - w3_textarea
	   x w3_checkbox
	   x w3_select
	   x w3_slider
	   - w3_menu (no initial selection)
	
	unify color setting: style.color vs w3-color, w3-text-color
	uniform default/init control values
	preface internal routines/vars with w3int_...
	move some routines (esp HTML) out of kiwi_util.js into here?
	make all 'id-', 'cl-' use uniform
	collapse into one func the setting of cfg value and el/control current displayed value
	w3-valign vs w3-show-inline vs w3-show-inline-block

	x use DOM el.classList.f() instead of ops on el.className
	x normalize use of embedded labels
	
	
	///////////////////////////////////////
	// API users
	///////////////////////////////////////
	
	1) kiwisdr.com website content
	
	2) antenna switch extension is a user of API:
	   visible_block()
	   w3_divs()
	   w3_inline()                   only in OLDER versions of the ant_switch ext
	   w3_btn()
	   w3_radio_btn(yes/no)    DEP   w3_radio_button
	   w3_input_get_param()    DEP
	   w3_string_set_cfg_cb()
	   w3_highlight()
	   w3_unhighlight()
	   w3_radio_unhighlight()
	   var w3_highlight_time

*/


////////////////////////////////
// deprecated
////////////////////////////////

function visible_block() {}      // FIXME: used by antenna switch ext


////////////////////////////////
// util
////////////////////////////////

function w3_console_obj(obj, prefix)
{
   var s = prefix? (prefix + ' ') : '';
   if (isObject(obj))
      s += JSON.stringify(obj, null, 1);
   else
   if (isString(obj))
      s += '"'+ obj.toString() +'"';
   else
      s += obj.toString();
   console.log(s);
   if (isObject(obj)) console.log(obj);
}

function w3_strip_quotes(s)
{
	if (isString(s) && (s.indexOf('\'') != -1 || s.indexOf('\"') != -1))
		return s.replace(/'/g, '').replace(/"/g, '') + ' [quotes stripped]';
	return s;
}

function w3_esc_dq(s)
{
	if (isString(s) && s.indexOf('\"') != -1)
		return s.replace(/"/g, '&quot;');
	return s;
}

// a single-argument call that silently continues if func not found
function w3_call(func, arg0, arg1, arg2, arg3, arg4)
{
   var rv = undefined;

   if (!isArg(func)) return rv;
   
	try {
	   if (isString(func)) {
         var f = getVarFromString(func);
         //console.log('w3_call: '+ func +'() = '+ typeof(f));
         if (isFunction(f)) {
            //var args = Array.prototype.slice.call(arguments);
            rv = f(arg0, arg1, arg2, arg3, arg4);
         } else {
            //console.log('w3_call: getVarFromString(func) not a function: '+ func +' ('+ typeof(f) +')');
         }
      } else
	   if (isFunction(func)) {
         rv = func(arg0, arg1, arg2, arg3, arg4);
	   } else
	      console.log('w3_call: func not a string or function');
	} catch(ex) {
		console.log('w3_call: while in func this exception occured:');
		console.log(ex);
		//console.log('w3_call: '+ ex.toString());
		//console.log(ex.stack);
	}
	
	return rv;
}

function w3_first_value(v)
{
   //console.log('w3_first_value');
   //console.log(v);
   if (v == null)
      return 'null';

   var rv = null;
   var to_v = typeof(v);
   
   if (to_v === 'number' || to_v === 'boolean' || to_v === 'string') {
      //console.log('w3_first_value prim');
      rv = v;
   } else
   if (isArray(v)) {
      //console.log('w3_first_value array');
      rv = v[0];
   } else
   if (to_v === 'object') {   // first value in object no matter what the key
      //console.log('w3_first_value obj');
      rv = w3_obj_seq_el(v, 0);
   } else {
      //console.log('w3_first_value other');
      rv = to_v;
   }
   //console.log('w3_first_value rv='+ rv);
   return rv;
}

function w3_opt(opt, elem, default_val)
{
   //console.log('w3_opt opt:');
   //console.log(opt);
   if (isDefined(opt) && isDefined(opt[elem])) {
      //console.log('w3_opt elem='+ elem +' DEFINED rv='+ opt[elem]);
      return opt[elem];
   } else {
      //console.log('w3_opt elem='+ elem +' NOT DEFINED rv='+ default_val);
      return default_val;
   }
}

function w3_obj_num(o)
{
   if (isUndefined(o) || isNull(o) || isObject(o)) return o;
   if (isNumber(o)) return { num: o };
   if (isBoolean(o)) return { num: (o? 1:0) };
   if (isString(o)) return { num: parseFloat(o) };
   return o;
}

function w3_obj_seq_el(o, idx)
{
   var keys = Object.keys(o);
   return o[keys[idx]];
}

function w3_obj_enum(obj, func, opt)
{
   var key_match = w3_opt(opt, 'key_match', undefined);
   var value_match = w3_opt(opt, 'value_match', undefined);

   Object.keys(obj).forEach(function(key, i) {
      if (isDefined(key_match)) {
         if (key == key_match) func(key, i);
      } else
      if (isDefined(value_match)) {
         if (obj[key] == value_match) func(key, i);
      } else {
         func(key, i);
      }
   });
}

// arr:     [] string vals to iterate over
// s:       string val to match with startsWith() (case-insensitive)
// func:    (optional) called as func(arr-idx, val) only on first match
// returns: found = true|false
function w3_ext_param_array_match_str(arr, s, func)
{
   var found = false;
   arr.forEach(function(a_el, i) {
      var el = a_el.toString().toLowerCase();
      //console.log('w3_ext_param_array_match_str CONSIDER '+ i +' '+ el +' '+ s);
      if (!found && el.startsWith(s)) {
         //console.log('w3_ext_param_array_match_str MATCH '+ i);
         if (func) func(i, a_el.toString());
         found = true;
      }
   });
   return found;
}

// arr:     [] vals to iterate over
// n:       num val to match
// func:    (optional) called as func(arr-idx, val) only on first match
// returns: found = true|false
function w3_ext_param_array_match_num(arr, n, func)
{
   var found = false;
   arr.forEach(function(a_el, i) {
      var a_num = parseFloat(a_el);
      //console.log('w3_ext_param_array_match_num CONSIDER '+ i +' '+ a_num +' '+ n);
      if (!found && a_num == n) {
         //console.log('w3_ext_param_array_match_num MATCH '+ i);
         if (func) func(i, n);
         found = true;
      }
   });
   return found;
}

// param:   name[:val]
// s:       name.startsWith(s)   case-insensitive
// returns: { match:true|false, has_value:true|false, num:parseFloat(val), string:val }
function w3_ext_param(s, param)
{
   p = param.toLowerCase().split(':');
   if (s.startsWith(p[0])) {
      rv = { match: true };
      if (p.length > 1) {
         rv.has_value = true;
         rv.num = parseFloat(p[1]);
         rv.string = p[1];
      } else {
         rv.has_value = false;
         rv.num = 0;
         rv.string = '';
      }
      return rv;
   }
   return { match: false }
}

function w3_clamp(v, min, max, clamp_val)
{
   if (isObject(min)) {
      var o = min;
      try {
         if (typeof(o.clamp) === 'undefined') {
            v = Math.max(o.min, Math.min(o.max, v));
         } else {
            if (v < o.min || v > o.max) v = o.clamp;
         }
      } catch(ex) {
         console.log('w3_clamp: bad obj:');
         console.log(o);
         return undefined;
      }
   } else {
      if (clamp_val == undefined)
         v = Math.max(min, Math.min(max, v));
      else
         if (v < min || v > max) v = clamp_val;
   }
   
   return v;
}


////////////////////////////////
// HTML
////////////////////////////////

function w3_add_id(path)
{
   return path? (path.startsWith('id-')? path : ('id-'+ path)) : '';
}

// return document element reference either by id or name
function w3int_w3_el(id_name_class)
{
   if (!id_name_class || id_name_class == '') return null;
	var el = document.getElementById(id_name_class);
	if (el == null) {
		el = document.getElementsByName(id_name_class);		// 'name=' is deprecated
		if (el != null) el = el[0];	// use first from array
	}
	if (el == null) {
		el = document.getElementsByClassName(id_name_class);
		if (el != null) el = el[0];	// use first from array
	}
	return el;
}

function w3int_w3_els(id_name_class)
{
   if (!id_name_class || id_name_class == '') return null;
	var els = document.getElementById(id_name_class);
	var rv;
	if (els != null) {
	   rv = [els];
	} else {
      els = document.getElementsByName(id_name_class);		// 'name=' is deprecated
      if (els == null || els.length == 0) {
         els = document.getElementsByClassName(id_name_class);
      }
      rv = els;
   }
   if (rv.length == 0) rv = null;
	return rv;  // returns single-element array or iterable HTMLCollection
}

// allow an element-obj or element-id to be used
// try id without, then with, leading 'id-'; then including cfg prefix as a last resort
function w3_el(el_id)
{
	if (isString(el_id)) {
	   if (el_id == '') return null;
	   if (el_id == 'body') return document.body;
		var el = w3int_w3_el(el_id);
		if (el == null) {
			el = w3int_w3_el('id-'+ el_id);
			if (el == null) {
				el_id = w3_add_toplevel(el_id);
				el = w3int_w3_el(el_id);
				if (el == null) {
					el = w3int_w3_el('id-'+ el_id);
				}
			}
		}
		return el;
	}
	return (el_id);
}

function w3_els(el_id)
{
	if (isString(el_id)) {
	   if (el_id == '') return null;
	   if (el_id == 'body') return document.body;
		var els = w3int_w3_els(el_id);
		if (els == null) {
			els = w3int_w3_els('id-'+ el_id);
			if (els == null) {
				el_id = w3_add_toplevel(el_id);
				els = w3int_w3_els(el_id);
				if (els == null) {
					els = w3int_w3_els('id-'+ el_id);
				}
			}
		}
		return els;
	}
	return (el_id);
}

// w3_el(), but silently failing if element doesn't exist
function w3_el_softfail(id)
{
	var el = w3_el(id);
	var debug;
	try {
		debug = el.innerHTML;
	} catch(ex) {
		console.log('w3_el_softfail("'+ id +'") SOFTFAIL');
		/*
		if (dbgUs && dbgUsFirst) {
			kiwi_trace();
			dbgUsFirst = false;
		}
		*/
	}
	if (el == null) {
	   el = document.createElement('div');		// allow failures to proceed, e.g. assignments to innerHTML
	   el.id = id;
	   el.classList.add('NB-SOFTFAIL');
	   el.style.display = 'none';
	   document.body.appendChild(el);
	}
	return el;
}

// return id of element (i.e. 'id-*') if found
function w3_id(el_id)
{
	var el = w3_el(el_id);
	if (!el) return null;
	if (el.id && el.id.startsWith('id-')) return el.id;
	var done = false;
	var id = null;
	w3_iterate_classList(el, function(className, idx) {
      //console.log('w3_id CONSIDER '+ className);
	   if (className.startsWith('id-') && !done) {
	      id = className;
	      done = true;
	   }
	});
	return id;
}

// assign innerHTML, silently failing if element doesn't exist
function w3_innerHTML(id)
{
	var el = w3_el_softfail(id);
	var s = '';
	var narg = arguments.length;
   for (var i=1; i < narg; i++) {
      s += arguments[i];
   }
	el.innerHTML = s;
	return el;
}

function w3_set_innerHTML(id)
{
	var el = w3_el(id);
	if (!el) return null;
	var s = '';
	var narg = arguments.length;
   for (var i=1; i < narg; i++) {
      s += arguments[i];
   }
	el.innerHTML = s;
	return el;
}

function w3_get_innerHTML(id)
{
	var el = w3_el(id);
	if (!el) return null;
	return el.innerHTML;
}

function w3_iterate_classname(cname, func)
{
	var els = document.getElementsByClassName(cname);
	if (els == null) return;
	for (var i=0; i < els.length; i++) {      // els is a collection, can't use forEach()
		func(els[i], i);
	}
}

function w3_iterate_classList(el_id, func)
{
	var el = w3_el(el_id);
	if (el && el.classList) for (var i = 0; i < el.classList.length; i++) {     // el.classList is a collection, can't use forEach()
		func(el.classList.item(i), i);
	}
	return el;
}

function w3_appendElement(el_parent, el_type, html)
{
   var el_child = document.createElement(el_type);
   w3_innerHTML(el_child, html);
	w3_el(el_parent).appendChild(el_child);
	return el_child;
}

function w3_iterate_parent(el_id, func)
{
	var el = w3_el(el_id);
	var i = 0;
	
	do {
		if (func(el, i) != null)
		   break;
		el = el.parentNode;
		i++;
	} while (el);
}

// excludes text and comment nodes
function w3_iterate_children(el_id, func)
{
	var el = w3_el(el_id);
	
	for (var i=0; i < el.children.length; i++) {    // el.children is a collection, can't use forEach()
		var child_el = el.children[i];
		func(child_el, i);
	}
}

// excludes text and comment nodes
function w3_iterateDeep_children(el_id, func)
{
	var el = w3_el(el_id);
	
	for (var i=0; i < el.children.length; i++) {    // el.children is a collection, can't use forEach()
		var child_el = el.children[i];
		func(child_el);
		if (child_el.hasChildNodes)
			w3_iterateDeep_children(child_el, func);
	}
}

// includes text and comment nodes
function w3_iterate_childNodes(el_id, func)
{
	var el = w3_el(el_id);
	
	for (var i=0; i < el.childNodes.length; i++) {    // el.childNodes is a collection, can't use forEach()
		var child_el = el.childNodes[i];
		func(child_el, i);
	}
}

// bounding box measured from the origin of parent
function w3_boundingBox_children(el_id, debug)
{
	var bbox = { x1:1e99, x2:0, y1:1e99, y2:0, w:0, h:0 };
	w3_iterateDeep_children(el_id, function(el) {
		if (el.nodeName != 'DIV' && el.nodeName != 'IMG')
			return;
		var position = css_style(el, 'position');
		if (position == 'static')
		   return;
		if (el.offsetHeight == 0)
		   return;
		if (debug) console.log(el);
		//console.log(el.offsetParent);
		if (debug) console.log(el.nodeName +' el.oL='+ el.offsetLeft +' el.oW='+ el.offsetWidth +' el.oT='+ el.offsetTop +' el.oH='+ el.offsetHeight +' '+ position);

		bbox.x1 = Math.min(bbox.x1, el.offsetLeft);
		var x2 = el.offsetLeft + el.offsetWidth;
		bbox.x2 = Math.max(bbox.x2, x2);

		bbox.y1 = Math.min(bbox.y1, el.offsetTop);
		var y2 = el.offsetTop + el.offsetHeight;
		bbox.y2 = Math.max(bbox.y2, y2);
	});

	bbox.w = bbox.x2 - bbox.x1;
	bbox.h = bbox.y2 - bbox.y1;
	if (debug) console.log('BBOX x1='+ bbox.x1 +' x2='+ bbox.x2 +' y1='+ bbox.y1 +' y2='+ bbox.y2 +' w='+ bbox.w +' h='+ bbox.h);
	return bbox;
}

function w3_center_in_window(el_id, id)
{
	var el = w3_el(el_id);
	var rv = window.innerHeight/2 - el.clientHeight/2;
	//console.log('w3_center_in_window wh='+ window.innerHeight +' ch='+ el.clientHeight +' rv='+ rv + (id? (' '+ id) : ''));
	return rv;
}

// conditionally select field element
function w3_field_select(el_id, opts)
{
	var el = w3_el(el_id);
	el = (el && isFunction(el.select))? el : null;

   var trace = 0;
   if (trace) {
      var id = isObject(el_id)? el_id.id : el_id;
      console.log('w3_field_select id='+ id +' el='+ el +' v='+ (el? el.value:null));
      console.log(el);
      console.log(opts);
   }
   if (!el) return;
   
   var focus=0, select=0, blur=0;
   if (opts['mobile'] && kiwi_isMobile()) blur = 1; else focus = select = 1;
   if (opts['blur']) blur = 1;
   if (opts['focus_select']) focus = select = 1;
   if (opts['focus_only']) { focus = 1; select = 0; }
   if (opts['select_only']) select = 1;
   
   if (trace) console.log('w3_field_select focus='+ focus +' select='+ select +' blur='+ blur);
   if (focus) el.focus();
   if (select) el.select();
   if (blur) el.blur();
   if (trace) kiwi_trace();
}

// add, remove or check presence of class properties
function w3_add(el_id, props)
{
	var el = w3_el(el_id);
	//console.log('w3_add <'+ props +'>');
	if (!el || !props) return null;
	props = props.replace(/\s+/g, ' ').split(' ');
	props.forEach(function(p) {
	   el.classList.add(p);
	});
	return el;
}

function w3_remove(el_id, props)
{
	var el = w3_el(el_id);
	//console.log('w3_remove <'+ props +'>');
	if (!el || !props) return null;
	props = props.replace(/\s+/g, ' ').split(' ');
	props.forEach(function(p) {
	   el.classList.remove(p);
	});
	return el;
}

function w3_remove_wildcard(el_id, prefix)
{
	var el = w3_el(el_id);
	//console.log('w3_remove_wildcard <'+ prefix +'>');
	if (!el) return null;
	for (var i = 0; i < el.classList.length; i++) {    // el.classList is a collection, can't use forEach()
	   var cl = el.classList.item(i);
	   if (cl.startsWith(prefix)) el.classList.remove(cl);
	}
	return el;
}

function w3_set_props(el_id, props, val)
{
	if (val)
	   w3_add(el_id, props);
	else
	   w3_remove(el_id, props);
	return el_id;
}

function w3_remove_then_add(el_id, r_props, a_props)
{
	w3_remove(el_id, r_props);
	w3_add(el_id, a_props);
}

function w3_contains(el_id, prop)
{
	var el = w3_el(el_id);
	if (!el) return 0;
	var clist = el.classList;
	return (!clist || !clist.contains(prop))? 0:1;
}

function w3_parent_with(el_id, prop)
{
	var el = w3_el(el_id);
   if (!el) return;
	
	var found = null;
	w3_iterate_parent(el, function(parent) {
	   if (!found && w3_contains(parent, prop)) {
	      found = parent;
	   }
	});
	return found;
}

function w3_toggle(el_id, prop)
{
	var el = w3_el(el_id);
	if (!el) return;
	if (w3_contains(el, prop)) {
		w3_remove(el, prop);
		//console.log('w3_toggle: hiding '+ el_id);
	} else {
		w3_add(el, prop);
		//console.log('w3_toggle: showing '+ el_id);
	}
	return el;
}

function w3_appendAllClass(cname, prop)
{
	w3_iterate_classname(cname, function(el) { el.classList.add(prop); });
}
	
function w3_setAllHref(cname, href)
{
	w3_iterate_classname(cname, function(el) { el.href = href; });
}

// Can't simply do "el.style.display =" for these since things like
// w3-hide are declared "!important" by w3.css
// Must actually remove/insert them from the class property.
function w3_show(el_id, display)
{
	var el = w3_el(el_id);
	w3_remove(el, 'w3-hide');
	w3_add(el, display? display : 'w3-show-inline-block');
	return el;
}

function w3_attribute(el_id, name, val)
{
	var el = w3_el(el_id);
	if (el == null) return;
	var attr = document.createAttribute(name);
	attr.value = val;
	el.setAttributeNode(attr);
}

function w3_show_block(el_id)
{
   return w3_show(el_id, 'w3-show-block');
}

function w3_show_inline_block(el_id)
{
   return w3_show(el_id, 'w3-show-inline-block');
}

function w3_show_inline(el_id)
{
   return w3_show(el_id, 'w3-show-inline-new');
}

function w3_show_table_cell(el_id)
{
   return w3_show(el_id, 'w3-show-table-cell');
}

function w3_hide(el)
{
   //w3_console_obj(el, 'w3_hide BEGIN');
	var el = w3_iterate_classList(el, function(className, idx) {
      //console.log('w3_hide CONSIDER '+ className);
	   if (className.startsWith('w3-show-')) {
         //console.log('w3_hide REMOVE '+ className);
	      w3_remove(el, className);
	   }
	});
	w3_add(el, 'w3-hide');
   //w3_console_obj(el, 'w3_hide END');
	return el;
}

function w3_show_hide(el, show, display)
{
   var rv;
   //w3_console_obj(el, 'w3_show_hide BEGIN show='+ show);
   if (show) {
      rv = w3_show(el, display? display : 'w3-show-block');
   } else {
      rv = w3_hide(el);
   }
   //w3_console_obj(el, 'w3_show_hide END');
   return rv;
}

function w3_show_hide_inline(el, show)
{
   w3_show_hide(el, show, 'w3-show-inline-new');
}

function w3_visible(el_id, visible)
{
	var el = w3_el(el_id);
	el.style.visibility = visible? 'visible' : 'hidden';
	return el;
}

// our standard for confirming (highlighting) a control action (e.g.button push)
var w3_highlight_time = 250;
var w3_highlight_color = 'w3-selection-green';
var w3_selection_green = '#4CAF50';

function w3_highlight(el_id)
{
	var el = w3_el(el_id);
	//console.log('w3_highlight '+ el.id);
	w3_add(el, el.w3int_highlight_color || w3_highlight_color);
}

function w3_unhighlight(el_id)
{
	var el = w3_el(el_id);
	//console.log('w3_unhighlight '+ el.id);
	w3_remove(el, el.w3int_highlight_color || w3_highlight_color);
}

function w3_isHighlighted(el_id)
{
	var el = w3_el(el_id);
	return w3_contains(el, el.w3int_highlight_color || w3_highlight_color);
}

function w3_set_highlight_color(el_id, color)
{
	var el = w3_el(el_id);
	if (!el) return null;

	if (w3_isHighlighted(el)) {
	   w3_unhighlight(el);
	   el.w3int_highlight_color = color;
	   w3_highlight(el);
	} else {
	   el.w3int_highlight_color = color;
	}

	return el;
}

var w3_flag_color = 'w3-override-yellow';

function w3_flag(path)
{
	w3_add(w3_el(path), w3_flag_color);
}

function w3_unflag(path)
{
	w3_remove(w3_el(path), w3_flag_color);
}

// for when you don't want to w3_add(el_id, "[w3-text-color]")
// returns previous color
function w3_color(el_id, color, bkgColor, cond)
{
	var el = w3_el(el_id);
	if (!el) return null;
	var prev_fg = el.style.color;
	var prev_bg = el.style.backgroundColor;
	
	// remember that setting colors to '' restores default
	cond = (isUndefined(cond) || cond);
   if (isArg(color)) el.style.color = cond? color:'';
   if (isArg(bkgColor)) el.style.backgroundColor = cond? bkgColor:'';
	return { color: prev_fg, backgroundColor: prev_bg };
}

// returns previous color
function w3_background_color(el_id, color)
{
	var el = w3_el(el_id);
	var prev = el.style.backgroundColor;
	if (color != undefined && color != null) el.style.backgroundColor = color;
	return prev;
}

function w3_colors(el_id, colors)
{
   var el = w3_el(el_id);
   if (!el) return null;
   var ar = colors? colors.split(',') : null;
   var bg = null, fg = null;
   if (ar && ar.length > 0) bg = ar[0];
   if (ar && ar.length > 1) fg = ar[1];
   if (bg && bg.startsWith('w3-'))
      w3_add(el, bg);
   else
      el.style.backgroundColor = bg;
   if (fg && fg.startsWith('w3-'))
      w3_add(el, fg);
   else
      el.style.color = fg;
}

function w3_check_restart_reboot(el_id)
{
	var el = w3_el(el_id);
   if (!el) return;
	
	w3_iterate_parent(el, function(el) {
		if (w3_contains(el, 'w3-restart')) {
			w3_restart_cb();
			return el;
		}
		if (w3_contains(el, 'w3-reboot')) {
			w3_reboot_cb();
			return el;
		}
		return null;
	});
}

function w3_set_value(path, val)
{
	var el = w3_el(path);
	if (el) el.value = val;
}

function w3_set_decoded_value(path, val)
{
	//console.log('w3_set_decoded_value: path='+ path +' val='+ val);
	var el = w3_el(path);
	if (el) el.value = decodeURIComponent(val);
}

function w3_get_value(path)
{
	var el = w3_el(path);
	if (!el) return null;
	return el.value;
}

function w3_add_toplevel(path)
{
	if (!path.startsWith('cfg.') && !path.startsWith('adm.'))
		return 'cfg.'+ path;
	return path;
}

function w3_not_toplevel(path)
{
	if (path.startsWith('cfg.') || path.startsWith('adm.'))
		return path.substr(path.indexOf('.') + 1);
	return path;
}

function w3_basename(path)
{
	var i = path.lastIndexOf('.');
	if (i >= 0) {
		return path.substr(i+1);
	}
	return path;
}

function w3_psa3(psa3)
{
   //console.log('w3_psa3 in='+ psa3);
   psa3 = psa3 || '';
   arr = psa3.split('/');
   //console.log(arr);
   if (arr.length == 1)
      return { left:'', middle:'', right:arr[0] };
   else
   if (arr.length == 2)
      return { left:'', middle:arr[0], right:arr[1] };
   else
   if (arr.length == 3)
      return { left:arr[0], middle:arr[1], right:arr[2] };
   else
      return { left:'', middle:'', right:'' };
}

// psa = prop|style|attr
// => <div [class="[prop] [extra_prop]"] [style="[style] [extra_style]"] [attr] [extra_attr]>
function w3_psa(psa, extra_prop, extra_style, extra_attr)
{
	//console.log('psa_in=['+ psa +']');
	//console.log('extra_prop=['+ extra_prop +']');
	//console.log('extra_style=['+ extra_style +']');
	//console.log('extra_attr=['+ extra_attr +']');

   if (psa && psa.startsWith('class=')) {
      //console.log('#### w3_psa RECURSION ####');
      return psa;    // already processed
   }
   
   var hasPSA = function(s) { return (s && s != '')? s : ''; };
   var needsSP = function(s) { return (s && s != '')? ' ' : ''; };
	var a = psa? psa.split('|') : [];
	psa = '';

	var prop = hasPSA(a[0]);
	if (extra_prop) prop += needsSP(prop) + extra_prop;
	if (prop != '') psa = 'class='+ dq(prop);

	var style = hasPSA(a[1]);
	if (extra_style) style += needsSP(style) + extra_style;
	if (style != '') psa += needsSP(psa) +'style='+ dq(style);

	var attr = hasPSA(a[2]);
	if (extra_attr) attr += needsSP(attr) + extra_attr;
	if (attr != '') psa += needsSP(psa) + attr;

	//console.log('psa_out=['+ psa +']');
	return psa;
}

// like w3_psa() except returns in original psa format (i.e. not expanded to "class=...")
function w3_psa_mix(psa, extra_prop, extra_style, extra_attr)
{
	//console.log('mix_in=['+ psa +']');
	//console.log('extra_prop=['+ extra_prop +']');
	//console.log('extra_style=['+ extra_style +']');
	//console.log('extra_attr=['+ extra_attr +']');

   var hasPSA = function(s) { return (s && s != '')? s : ''; };
   var needsSP = function(s) { return (s && s != '')? ' ' : ''; };
   var needsSemi = function(s) { return (s && s != '')? '; ' : ''; };
	var a = psa? psa.split('|') : [];
	psa = '';

	var prop = hasPSA(a[0]);
	if (extra_prop) prop += needsSP(prop) + extra_prop;
	if (prop != '') psa += prop;

	var style = hasPSA(a[1]);
	if (extra_style) style += needsSemi(style) + extra_style;
	if (style != '') psa += '|'+ style;

	var attr = hasPSA(a[2]);
	if (extra_attr) attr += needsSP(attr) + extra_attr;
	if (attr != '') psa += '|' + attr;

	//console.log('mix_out=['+ psa +']');
	return psa;
}

function w3int_init()
{
}

function w3int_post_action()
{
   // if it exists, re-select the main page frequency field
   w3_call('freqset_select');
}

function w3_fillText(ctx, x, y, text, color, font, align, baseline)
{
   if (color) ctx.fillStyle = color;
   if (font) ctx.font = font;
   if (align) ctx.textAlign = align;
   if (baseline) ctx.textBaseline = baseline;
   var tw = ctx.measureText(text).width;
   ctx.fillText(text, x-tw/2, y);
}

function w3_copy_to_clipboard(val)
{
	var el = document.createElement("input");
	el.setAttribute('type', 'text');
	el.setAttribute('value', val);
   document.body.appendChild(el);
	el.select();
	document.execCommand("copy");
   document.body.removeChild(el);
}


////////////////////////////////
// nav
////////////////////////////////

function w3_click_nav(next_id, cb_next, cb_param)
{
   //console.log('w3_click_nav '+ next_id +' cb_next='+ cb_next +' cb_param='+ cb_param);
   //kiwi_trace();
	var next_id_nav = 'id-nav-'+ next_id;		// to differentiate the nav anchor from the nav container
	var cur_id = null;
	var next_el = null;
   var cb_prev = null;

	w3_iterate_children(w3_el(next_id_nav).parentNode, function(el, i) {
	   //console.log('w3_click_nav consider: nodename='+ el.nodeName);
	   if (el.nodeName != 'A') return;
	   //if (el.nodeName != 'DIV') return;

		//console.log('w3_click_nav consider: id='+ el.id +' ==? next_id_nav='+ next_id_nav +' el.className="'+ el.className +'"');
		if (w3_contains(el, 'w3int-cur-sel')) {
			cur_id = el.id.substring(7);		// remove 'id-nav-' added by w3int_anchor()

		   //console.log('w3_click_nav FOUND cur_id='+ cur_id);
			w3_remove(el, 'w3int-cur-sel');
			w3_iterate_classList(el, function(s, i) {
			   if (s.startsWith('id-nav-cb-'))
			      cb_prev = s.substring(10);
			});
		}

		if (el.id == next_id_nav) {
			next_el = el;
		}
	});

   // toggle visibility of current content
	if (cur_id)
		w3_toggle(cur_id, 'w3-show-block');
	if (cur_id && cb_prev) {
		//console.log('w3_click_nav BLUR cb_prev='+ cb_prev +' cur_id='+ cur_id);
		w3_call(cb_prev +'_blur', cur_id);
	}

   // make new nav item current and visible / focused
	if (next_el) {
		w3_add(next_el, 'w3int-cur-sel');
	   w3_check_restart_reboot(next_el);
	}

	w3_toggle(next_id, 'w3-show-block');
	if (cb_next != 'null') {
	   //console.log('w3_click_nav FOCUS cb_next='+ cb_next +' next_id='+ next_id);
      w3_call(cb_next +'_focus', next_id, cb_param);
   }
	//console.log('w3_click_nav cb_prev='+ cb_prev +' cur_id='+ cur_id +' cb_next='+ cb_next +' next_id='+ next_id);
}

// id = unique, cb = undefined => cb = id
// id = unique, cb = func
// id = unique, cb = null => don't want focus/blur callbacks
function w3int_anchor(psa, text, id, cb, isSelected)
{
   if (cb === undefined) cb = id;
   var nav_cb = cb? ('id-nav-cb-'+ cb) : '';
   //console.log('w3int_anchor id='+ id +' cb='+ cb +' nav_cb='+ nav_cb);

	// store id prefixed with 'id-nav-' so as not to collide with content container id prefixed with 'id-'
	var attr = 'id="id-nav-'+ id +'" onclick="w3_click_nav('+ sq(id) +', '+ sq(cb) +')"';
	//console.log('w3int_anchor psa: '+ psa);
	//console.log('w3int_anchor attr: '+ attr);
   var p = w3_psa(psa, nav_cb + (isSelected? ' w3int-cur-sel':''), '', attr);
//var p = w3_psa(psa, 'w3-show-inline '+ nav_cb + (isSelected? ' w3int-cur-sel':''), '', attr);
	//console.log('w3int_anchor p: '+ p);
	
	// store with id= instead of a class property so it's easy to find with el.id in w3_iterate_classname()
	// href of "javascript:void(0)" instead of "#" so page doesn't scroll to top on click
	var s = '<a '+ p +' href="javascript:void(0)">'+ text +'</a>';
//var s = w3_div(p, text);
	//console.log('w3int_anchor: '+ s);
	return s;
}

function w3_navbar(psa)
{
   var p = w3_psa(psa, 'w3-navbar');
	var s = '<nav '+ p +'>';
	var narg = arguments.length;
		for (var i=1; i < narg; i++) {
			s += arguments[i];
		}
	s += '</nav>';
	//console.log(s);
	return s;
}

function w3_sidenav(psa)
{
   var p = w3_psa(psa, 'w3-sidenav w3-static w3-left w3-sidenav-full-height w3-light-grey');
	var s = '<nav '+ p +'>';
	var narg = arguments.length;
		for (var i=1; i < narg; i++) {
			s += arguments[i];
		}
	s += '</nav>';
	//console.log(s);
	return s;
}

function w3_nav(psa, text, id, cb, isSelected)
{
	return w3int_anchor(psa, text, id, cb, isSelected);
}

function w3_navdef(psa, text, id, cb)
{
	// must wait until instantiated before manipulating 
	setTimeout(function() {
		//console.log('w3_navdef instantiate focus');
		w3_toggle(id, 'w3-show-block');
	}, w3_highlight_time);
	
	return w3int_anchor(psa, text, id, cb, true);
}


////////////////////////////////
// labels
////////////////////////////////

function w3_label(psa, text, path, extension)
{
   if (arguments.length >= 4) console.log('### w3_label ext='+ extension);
   if ((!psa || psa == '') && (!text || text == '') && (!extension || extension == '')) return '';
   
   // most likely already an embedded w3_label()
   if (text && text.startsWith('<label ')) return text;
   
   path = path? ('id-'+ path +'-label') : '';   // so w3_set_label() can find label
	//var inline = psa.includes('w3-label-inline');
	var p = w3_psa(psa, path);
	text = text? text : '';
	var s = '<label '+ p +'>'+ text + (extension? extension : '') +'</label>';
	//var s = '<label '+ p +'>'+ text + (extension? extension : '') + (inline? '':'<br>') +'</label>';
	//console.log('LABEL: psa='+ psa +' text=<'+ text +'> text?='+ (text?1:0) +' s=<'+ s +'>');
	return s;
}

function w3_set_label(label, path)
{
	w3_el(path +'-label').innerHTML = label;
}


////////////////////////////////
// link
////////////////////////////////

function w3int_link_click(ev, cb, cb_param)
{
   console.log('w3int_link_click cb='+ cb +' cb_param='+ cb_param);
   console.log(ev);
   var el = ev.currentTarget;
   console.log(el);
   w3_check_restart_reboot(el);

   // cb is a string because can't pass an object to onclick
   if (cb) {
      w3_call(cb, el, cb_param, /* first */ false);   // links don't really have first callback
   }

   w3int_post_action();
}

function w3_link(psa, url, inner, title, cb, cb_param)
{
   var qual_url = url;
   if (!url.startsWith('http://') && !url.startsWith('https://'))
      qual_url = 'http://'+ url;
   inner = inner || '';
   title = (title && title != '')? (' title='+ dq(title)) : '';

   // by default use pointer cursor if there is a callback
	var pointer = (cb && cb != '')? 'w3-pointer':'';
	cb_param = cb_param || 0;
	var onclick = cb? (' onclick="w3int_link_click(event, '+ sq(cb) +', '+ sq(cb_param) +')"') : '';

	var p = w3_psa(psa, pointer, '', 'href='+ dq(qual_url) +' target="_blank"'+ title + onclick);
	var s = '<a '+ p +'>'+ inner +'</a>';
	//console.log(s);
	return s;
}


////////////////////////////////
// buttons: radio
////////////////////////////////

var w3_SELECTED = true;
var w3_NOT_SELECTED = false;

function w3_radio_unhighlight(path)
{
	w3_iterate_classname('id-'+ path, function(el) { w3_unhighlight(el); });
}

function w3int_radio_click(ev, path, cb, cb_param)
{
	w3_radio_unhighlight(path);
	w3_highlight(ev.currentTarget);

	var idx = -1;
	w3_iterate_classname('id-'+ path, function(el, i) {
		if (w3_isHighlighted(el))
			idx = i;
		//console.log('w3int_radio_click CONSIDER path='+ path +' el='+ el +' idx='+ idx);
	});

	w3_check_restart_reboot(ev.currentTarget);

	// cb is a string because can't pass an object to onclick
	if (cb) {
		w3_call(cb, path, idx, /* first */ false, cb_param);   // radio buttons don't really have first callback
	}

   w3int_post_action();
}

// deprecated (still used by antenna switch ext)
function w3_radio_btn(text, path, isSelected, save_cb, prop)
{
	var prop = (arguments.length > 4)? arguments[4] : null;
	var _class = ' id-'+ path + (isSelected? (' '+ w3_highlight_color) : '') + (prop? (' '+prop) : '');
	var oc = 'onclick="w3int_radio_click(event, '+ sq(path) +', '+ sq(save_cb) +')"';
	var s = '<button class="w3-btn w3-ext-btn'+ _class +'" '+ oc +'>'+ text +'</button>';
	//console.log(s);
	return s;
}

function w3_radio_button(psa, text, path, isSelected, cb, cb_param)
{
	cb_param = cb_param || 0;
	var onclick = cb? ('onclick="w3int_radio_click(event, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"') : '';
	var p = w3_psa(psa, 'id-'+ path + (isSelected? (' '+ w3_highlight_color) : '') +' w3-btn w3-ext-btn', '', onclick);
	var s = '<button '+ p +'>'+ text +'</button>';
	//console.log(s);
	return s;
}

// used when current value should come from config param
function w3_radio_button_get_param(psa, text, path, selected_if_val, init_val, cb, cb_param)
{
	//console.log('w3_radio_button_get_param: '+ path);
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);
	
	// set default selection of button based on current value
	var isSelected = (cur_val == selected_if_val)? w3_SELECTED : w3_NOT_SELECTED;
	return w3_radio_button(psa, text, path, isSelected, cb, cb_param);
}


////////////////////////////////
// buttons: two button switch
////////////////////////////////

var w3_SWITCH_YES_IDX = 0, w3_SWITCH_NO_IDX = 1;

function w3_switch(psa, text_0, text_1, path, text_0_selected, cb, cb_param)
{
   //console.log('w3_switch psa='+ psa);
	var s =
		w3_radio_button(w3_psa_mix(psa, 'w3int-switch-0'), text_0, path, text_0_selected? 1:0, cb, cb_param) +
		w3_radio_button(w3_psa_mix(psa, 'w3int-switch-1'), text_1, path, text_0_selected? 0:1, cb, cb_param);
	return s;
}

// used when current value should come from config param
function w3_switch_get_param(psa, text_0, text_1, path, text_0_selected_if_val, init_val, cb, cb_param)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);

	// set default selection of button based on current value
	var text_0_selected = (cur_val == text_0_selected_if_val)? w3_SELECTED : w3_NOT_SELECTED;
	var s =
		w3_radio_button(w3_psa_mix(psa, 'w3int-switch-0'), text_0, path, text_0_selected? 1:0, cb, cb_param) +
		w3_radio_button(w3_psa_mix(psa, 'w3int-switch-1'), text_1, path, text_0_selected? 0:1, cb, cb_param);
	return s;
}

function w3_switch_set_value(path, switch_idx)
{
   var sw = 'w3int-switch-'+ switch_idx;
   //console.log('w3_switch_set_value: switch='+ sw +' path='+ path);
	w3_iterate_classname('id-'+ path, function(el, i) {
      //console.log('w3_switch_set_value: CONSIDER i='+ i);
      //console.log(el);
		if (w3_contains(el, sw)) {
		   //console.log('w3_switch_set_value: click()...');
		   //console.log(el);
			el.click();
		}
	});
}


////////////////////////////////
// buttons: single, clickable icon
////////////////////////////////

function w3int_button_click(ev, path, cb, cb_param)
{
   if (!w3_contains(path, 'w3-disabled')) {
      //console.log('w3int_button_click path='+ path +' cb='+ cb +' cb_param='+ cb_param);
      w3_check_restart_reboot(ev.currentTarget);
   
      // cb is a string because can't pass an object to onclick
      if (cb) {
         w3_call(cb, path, cb_param, /* first */ false);    // buttons don't really have first callback
      }
   }

   w3int_post_action();
}

var w3int_btn_grp_uniq = 0;

// deprecated (still used by older versions of antenna switch ext)
function w3_btn(text, cb)
{
   console.log('### DEPRECATED: w3_btn');
   return w3_button('', text, cb);
}

function w3_button(psa, text, cb, cb_param)
{
	var path = 'id-btn-grp-'+ w3int_btn_grp_uniq.toString();
	w3int_btn_grp_uniq++;
	cb_param = cb_param || 0;
	var onclick = cb? ('onclick="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"') : '';
	if (cb && psa.includes('w3-momentary')) {
	   onclick += ' onmousedown="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', 0)"';
	   onclick += ' ontouchstart="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', 0)"';
	}
	
	// w3-round-large listed first so its '!important' can be overriden by subsequent '!important's
	var default_style = psa.includes('w3-round-')? '' : ' w3-round-large';
   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.left);
	var psa_inner = w3_psa(psa3.right, path +' w3-btn w3-ext-btn'+ default_style, '', onclick);
	var s = '<button '+ psa_inner +'>'+ text +'</button>';
	if (psa_outer != '') s = '<div '+ psa_outer +'>'+ s +'</div>';
	//console.log(s);
	return s;
}

function w3_button_text(path, text, color_or_add_color, remove_color)
{
   var el = w3_el(path);
   if (!el) return null;
   el.innerHTML = text;
   if (color_or_add_color) {
      if (color_or_add_color.startsWith('w3-')) {
         w3_remove(el, remove_color);
         w3_add(el, color_or_add_color);
      } else
         el.style.color = color_or_add_color;
   }
   return el;
}

function w3_icon(psa, fa_icon, size, color, cb, cb_param)
{
   // by default use pointer cursor if there is a callback
	var pointer = (cb && cb != '')? ' w3-pointer':'';
	var path = 'id-btn-grp-'+ w3int_btn_grp_uniq.toString();
	w3int_btn_grp_uniq++;
	cb_param = cb_param || 0;

	var font_size = null;
	if (isNumber(size) && size >= 0) font_size = px(size);
	else
	if (isString(size)) font_size = size;
	font_size = font_size? (' font-size:'+ font_size +';') : '';

	color = (color && color != '')? (' color:'+ color) : '';
	var onclick = cb? ('onclick="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"') : '';
	if (cb && psa.includes('w3-momentary')) {
	   onclick += ' onmousedown="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', 0)"';
	   onclick += ' ontouchstart="w3int_button_click(event, '+ sq(path) +', '+ sq(cb) +', 0)"';
	}

	var p = w3_psa(psa, path + pointer +' fa '+ fa_icon, font_size + color, onclick);
	var s = '<i '+ p +'></i>';
	//console.log(s);
	return s;
}

/*

// prototype of callbacks using ev.currentTarget instead of path
// switch to using this someday

function w3int_icon_click(ev, cb, cb_param)
{
   console.log('w3int_icon_click cb='+ cb +' cb_param='+ cb_param);
   var el = ev.currentTarget;
   console.log(el);
   w3_check_restart_reboot(el);

   // cb is a string because can't pass an object to onclick
   if (cb) {
      w3_call(cb, el, cb_param, false);
   }

   w3int_post_action();
}

function w3_icon_cb2(psa, fa_icon, size, color, cb, cb_param)
{
   // by default use pointer cursor if there is a callback
	var pointer = (cb && cb != '')? ' w3-pointer':'';
	var path = 'id-btn-grp-'+ w3int_btn_grp_uniq.toString();
	w3int_btn_grp_uniq++;
	cb_param = cb_param || 0;

	var font_size = null;
	if (isNumber(size) && size >= 0) font_size = px(size);
	else
	if (isString(size)) font_size = size;
	font_size = font_size? (' font-size:'+ font_size +';') : '';

	color = (color && color != '')? (' color:'+ color) : '';
	var onclick = cb? ('onclick="w3int_icon_click(event, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"') : '';
	var p = w3_psa(psa, path + pointer +' fa '+ fa_icon, font_size + color, onclick);
	var s = '<i '+ p +'></i>';
	//console.log(s);
	return s;
}

*/


////////////////////////////////
// input
////////////////////////////////

// Detect empty lines (only \n) because onchange event not fired in that case.
// Also detect and process control character sequences.
function w3int_input_key(ev, path, cb)
{
   var k = ev.key.toUpperCase();
   var ctl = ev.ctrlKey;
	var el = w3_el(path);
   if (!el) return;
   //console.log('w3int_input_key k='+ k + (ctl? ' CTL ':'') +' val=<'+ el.value +'> cb='+ cb);
   cb = cb.split('|');

   if (ctl && 'CD\\'.includes(k) && cb[1]) {
      //console.log('w3int_input_key ^'+ k +' cb='+ cb[1]);
      w3_call(cb[1], k);
   }

   var input_any_change = w3_contains(el, 'w3-input-any-change');
	if (ev.key == 'Enter') {
      if (input_any_change) {
         // consider unchanged input value followed by Enter to be an input change
         //console.log('w3int_input_key: w3-input-any-change + Enter');
         w3_input_change(path, cb[0]);
      } else
	   if (el.value == '') {
         // cause empty input lines followed by Enter to send empty command to shell
         //console.log('w3int_input_key: empty line + Enter');
         w3_input_change(path, cb[0]);
      }
	}

   // if Delete key (Backspace) when entire value is selected then consider it an input change
	if (ev.key == 'Backspace' && input_any_change && el.selectionStart == 0 && el.selectionEnd == el.value.length) {
      //console.log('w3int_input_key Delete: len='+ el.value.length +' ss='+ el.selectionStart +' se='+ el.selectionEnd);
      el.value = '';
      w3_input_change(path, cb[0]);
	}
}

function w3_input_change(path, cb, cb_param)
{
	var el = w3_el(path);
	if (el) {
      //console.log('w3_input_change path='+ path);
      w3_check_restart_reboot(el);
      
      w3_highlight(el);
      setTimeout(function() {
         w3_unhighlight(el);
      }, w3_highlight_time);

      // cb is a string because can't pass an object to onclick
      if (cb) {
         cb = cb.split('|');
         //el.select();
         w3_call(cb[0], path, el.value, /* first */ false, cb_param);
      }
   }
	
   if (w3_contains(el, 'w3-retain-input-focus'))
	   w3_field_select(path, {mobile:1});     // select the field
   else
      w3int_post_action();
}

// no cb_param here because w3_input_change() passes the input value as the callback parameter
//
// NB: using w3_esc_dq(val) below eliminates the need to call admin_set_decoded_value() via
// admin tab *_focus() routines solely to work around the escaping of double quotes in the
// val issue.

function w3_input(psa, label, path, val, cb, placeholder)
{
	var id = w3_add_id(path);
	cb = cb || '';
	var phold = placeholder? (' placeholder="'+ placeholder +'"') : '';
	var onchange = path? (' onchange="w3_input_change('+ sq(path) +', '+ sq(cb) +')" onkeydown="w3int_input_key(event, '+ sq(path) +', '+ sq(cb) +')"') : '';
	var val = ' value='+ dq(w3_esc_dq(val) || '');
	var inline = psa.includes('w3-label-inline');
	var bold = !psa.includes('w3-label-not-bold');
	var spacing = (label != '' && inline)? ' w3int-margin-input' : '';

	// type="password" is no good because it forces the submit to be https which we don't support
	var type = 'type='+ (psa.includes('w3-password')? '"password"' : '"text"');

   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.left, inline? 'w3-show-inline-new':'');
   var psa_label = w3_psa_mix(psa3.middle, (label != '' && bold)? 'w3-bold':'');
	var psa_inner = w3_psa(psa3.right, 'w3-input w3-border w3-hover-shadow '+ id + spacing, '', type + phold);

	var s =
	   '<div '+ psa_outer +'>' +
         w3_label(psa_label, label, path) +
		   // NB: include id in an id= for benefit of keyboard shortcut field detection
         '<input id='+ dq(id) +' '+ psa_inner + val + onchange +'>' +
      '</div>';
	//if (path == 'Title') console.log(s);
	//w3int_input_set_id(id);
	return s;
}

/*
function w3int_input_set_id(id)
{
   console.log('### w3int_input_set_id el='+ id +' DO NOT USE');
   return;
	//if (id == '') return;
	//setTimeout(function() { w3int_input_set_id_timeout(id); }, 3000);
}

function w3int_input_set_id_timeout(id)
{
   var el = w3_el(id);
   //console.log('### w3int_input_set_id_timeout el='+ id +' CONSIDER');
   if (!el) return;
   if (el.id != '') {
      console.log('### w3int_input_set_id_timeout el='+ id +' id='+ id +' ALREADY SET?');
      return;
   }
   w3_iterate_classList(el, function(className, idx) {
	   if (className.startsWith('id-')) {
         console.log('### w3int_input_set_id_timeout el='+ id +' id='+ id +' SET --------');
	      el.id = className;
	   }
   });
}
*/

// used when current value should come from config param
function w3_input_get(psa, label, path, cb, init_val, placeholder)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);
	cur_val = decodeURIComponent(cur_val);
	//console.log('w3_input_get: path='+ path +' cur_val="'+ cur_val +'" placeholder="'+ placeholder +'"');
	return w3_input(psa, label, path, cur_val, cb, placeholder);
}

// DEPRECATED (still used by ant switch ext)
function w3_input_get_param(label, path, cb, init_val, placeholder)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);
	cur_val = decodeURIComponent(cur_val);
	//console.log('w3_input_get_param: path='+ path +' cur_val="'+ cur_val +'" placeholder="'+ placeholder +'"');
	return w3_input('', label, path, cur_val, cb, placeholder);
}


////////////////////////////////
// textarea
////////////////////////////////

function w3_textarea(psa, label, path, val, rows, cols, cb)
{
	var id = w3_add_id(path);
	var spacing = (label != '')? ' w3-margin-T-8' : '';
	var onchange = ' onchange="w3_input_change('+ sq(path) +', '+ sq(cb) +')" onkeydown="w3int_input_key(event, '+ sq(path) +', '+ sq(cb) +')"';
	var val = val || '';
	var p = w3_psa(psa, 'w3-input w3-border w3-hover-shadow '+ id + spacing, '', 'rows="'+ rows +'" cols="'+ cols +'"');

	var s =
	   w3_div('',
	      label,
		   '<textarea '+ p + onchange +'>'+ val +'</textarea>'
		);
	//if (label == 'Title') console.log(s);
	return s;
}

// used when current value should come from config param
function w3_textarea_get_param(psa, label, path, rows, cols, cb, init_val)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);
	cur_val = decodeURIComponent(cur_val);
	//console.log('w3_textarea_get_param: path='+ path +' cur_val="'+ cur_val +'"');
	return w3_textarea(psa, label, path, cur_val, rows, cols, cb);
}


////////////////////////////////
// checkbox
////////////////////////////////

function w3int_checkbox_change(path, cb, cb_param)
{
	var el = w3_el(path);
	w3_check_restart_reboot(el);
	
	// cb is a string because can't pass an object to onclick
	if (cb) {
	   //console.log('w3int_checkbox_change el='+ el +' checked='+ el.checked);
		//el.select();
		w3_highlight(el);
		setTimeout(function() {
			w3_unhighlight(el);
		}, w3_highlight_time);
		w3_call(cb, path, el.checked, /* first */ false, cb_param);
	}

   if (w3_contains(el, 'w3-retain-input-focus'))
	   w3_field_select(path, {mobile:1});     // select the field
   else
      w3int_post_action();
}

function w3_checkbox(psa, label, path, checked, cb, cb_param)
{
	var id = w3_add_id(path);
	var onchange = ' onchange="w3int_checkbox_change('+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"';
	var checked_s = checked? ' checked' : '';
	var inline = psa.includes('w3-label-inline');
	var left = psa.includes('w3-label-left');
	var bold = !psa.includes('w3-label-not-bold');
	var spacing = (label != '' && inline)? (left? ' w3-margin-L-8' : ' w3-margin-R-8') : '';

   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.left, inline? 'w3-show-inline-new':'');
   var psa_label = w3_psa_mix(psa3.middle, (label != '' && bold)? 'w3-bold':'');
	var psa_inner = w3_psa(psa3.right, 'w3-input w3-width-auto w3-border w3-pointer w3-hover-shadow '+ id + spacing, '', 'type="checkbox"');

   var ls = w3_label(psa_label, label, path);
   var cs = '<input '+ psa_inner + checked_s + onchange +'>';
	var s =
	   '<div '+ psa_outer +'>' +
	      (left? (ls + cs) : (cs + ls)) +
      '</div>';

	// run the callback after instantiation with the initial control value
	if (cb)
		setTimeout(function() {
			//console.log('w3_checkbox: initial callback: '+ cb +'('+ sq(path) +', '+ checked +')');
			w3_call(cb, path, checked, /* first */ true, cb_param);
		}, 500);

	//if (label == 'Title') console.log(s);
	return s;
}

// used when current value should come from config param
function w3_checkbox_get_param(psa, label, path, cb, init_val)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? null : init_val);
	//console.log('w3_checkbox_get_param: path='+ path +' cur_val="'+ cur_val +'"');
	return w3_checkbox(psa, label, path, cur_val, cb);
}

function w3_checkbox_get(path)
{
   var el = w3_el(path);
   if (!el) return;
	return (el.checked? true:false);
}

function w3_checkbox_set(path, checked)
{
   var el = w3_el(path);
   //console.log('w3_checkbox_set path='+ path +' el=...');
   //console.log(el);
   if (!el) return;
	el.checked = checked? true:false;
}


////////////////////////////////
// select
////////////////////////////////

var W3_SELECT_SHOW_TITLE = -1;

function w3int_select_change(ev, path, cb, cb_param)
{
	var el = ev.currentTarget;
	w3_check_restart_reboot(el);

	// cb is a string because can't pass an object to onclick
	if (cb) {
		w3_call(cb, path, el.value, /* first */ false, cb_param);
	}
	
   w3int_post_action();
}

function w3int_select(psa, label, title, path, sel, opts_s, cb, cb_param)
{
	var id = w3_add_id(path);
	var first = '';

	if (title != '') {
		first = '<option value="-1" '+ ((sel == W3_SELECT_SHOW_TITLE)? 'selected':'') +' disabled>' + title +'</option>';
	} else {
		if (sel == W3_SELECT_SHOW_TITLE) sel = 0;
	}
	
	var inline = psa.includes('w3-label-inline');
	var bold = !psa.includes('w3-label-not-bold');
	var spacing = (label != '' && !inline)? ' w3-margin-T-8' : '';
	if (inline) spacing += ' w3-margin-left';
	if (cb == undefined) cb = '';
	var onchange = 'onchange="w3int_select_change(event, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"';

   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.left, inline? 'w3-show-inline-new':'');
   var psa_label = w3_psa_mix(psa3.middle, (label != '' && bold)? 'w3-bold':'');
	var psa_inner = w3_psa(psa3.right, id +' w3-pointer'+ spacing, '', onchange);

	var s =
	   '<div '+ psa_outer +'>' +
         w3_label(psa_label, label, path) +
         // need <br> because both <label> and <select> are inline elements
         ((!inline && label != '')? '<br>':'') +
         '<select '+ psa_inner +'>'+ first + opts_s +'</select>' +
      '</div>';

	// run the callback after instantiation with the initial control value
	if (cb && sel != W3_SELECT_SHOW_TITLE)
		setTimeout(function() {
			//console.log('w3_select: initial callback: '+ cb +'('+ sq(path) +', '+ sel +')');
			w3_call(cb, path, sel, /* first */ true, cb_param);
		}, 500);

	//console.log(s);
	return s;
}

function w3int_select_options(sel, opts)
{
   var s = '';
   
   // 'min:max'
   // range of integers (increment one assumed)
   if (isString(opts)) {
      var rng = opts.split(':');
      if (rng.length == 2) {
         var min = +rng[0];
         var max = +rng[1];
         var idx = 0;
         for (var i = min; i <= max; i++) {
            s += '<option value='+ dq(idx) +' '+ ((idx == sel)? 'selected':'') +'>'+ i +'</option>';
            idx++;
         }
      }
   } else

   // [ n, n ... ]
   // [ 's', 's', n, 's' ... ]
   // [ 's', n, { first_key:x, key:x ... }, n ... ]
   // mixed array of strings, numbers or take first object key as menu option
   if (isArray(opts)) {
      //for (var i=0; i < opts.length; i++) {
      //   var obj = opts[i];
      opts.forEach(function(obj, i) {
         if (isObject(obj)) {
            var keys = Object.keys(obj);
            obj = obj[keys[0]];
         }
         s += '<option value='+ dq(i) +' '+ ((i == sel)? 'selected':'') +'>'+ obj +'</option>';
      });
   } else

   // { key0:opt0, key1:opt1 ... }
   // object: enumerate sequentially like an array using keys values as the menu options
   if (isObject(opts)) {
      w3_obj_enum(opts, function(key, i) {
         s += '<option value='+ dq(i) +' '+ ((i == sel)? 'selected':'') +'>'+ opts[key] +'</option>';
      });
   }
   
   return s;
}

function w3_select(psa, label, title, path, sel, opts, cb, cb_param)
{
   var s = w3int_select_options(sel, opts);
   return w3int_select(psa, label, title, path, sel, s, cb, cb_param);
}

// hierarchical -- menu entries interspersed with disabled (non-selectable) headers
// { key0:[fv0, fv1 ...], key1:[fv0, fv1 ...] ... }
// object: enumerate sequentially like an array using:
//    object keys as the disabled menu entries
//    arrays as the menu options
//       array elements are w3_first_value()'s e.g. int, string, first array value etc.
function w3_select_hier(psa, label, title, path, sel, opts, cb, cb_param)
{
   var s = '';
   var idx = 0;
   if (!isObject(opts)) return;

   w3_obj_enum(opts, function(key, i) {
      as = key.split('\\');
      as.forEach(function(e) {
         s += '<option value='+ dq(idx++) +' disabled>'+ e +'</option> ';
      });
      var a = opts[key];
      if (!isArray(a)) return;

      a.forEach(function(el, j) {
         var v = w3_first_value(el);
         s += '<option value='+ dq(idx++) +' id="id-'+ i +'-'+ j +'">'+ v.toString() +'</option> ';
      });
   });
   
   /*
   var keys = Object.keys(opts);
   for (var i=0; i < keys.length; i++) {
      var key = keys[i];
      s += '<option value='+ dq(idx++) +' disabled>'+ key +'</option> ';
      var a = opts[key];
      if (!isArray(a)) continue;

      for (var j=0; j < a.length; j++) {
         var v = w3_first_value(a[j]);
         s += '<option value='+ dq(idx++) +' id="id-'+ i +'-'+ j +'">'+ v.toString() +'</option> ';
      }
   }
   */
   
   return w3int_select(psa, label, title, path, sel, s, cb, cb_param);
}

// conditional -- individual menu entries can be enabled/disabled
// [ ['s', 1|0], ... ]
function w3_select_conditional(psa, label, title, path, sel, opts, cb, cb_param)
{
   var s = '';
   var idx = 0;
   if (!isArray(opts)) return;

   opts.forEach(function(el) {
      if (isArray(el))
         s += '<option value='+ dq(idx++) +' '+ (el[1]? '':'disabled') +'>'+ el[0] +'</option> ';
   });
   
   return w3int_select(psa, label, title, path, sel, s, cb, cb_param);
}

function w3_select_set_disabled(path, value, disabled)
{
   w3_iterate_children('id-'+ path, function(el, i) {
      //console.log('w3_select_set_disabled['+i+']');
      //console.log(el);
      if (el.value == value) el.disabled = disabled? true:false;
   });
}

// used when current value should come from config param
function w3_select_get_param(psa, label, title, path, opts, cb, init_val)
{
	var cur_val = ext_get_cfg_param(path, (init_val == undefined)? 0 : init_val);
	return w3_select(psa, label, title, path, cur_val, opts, cb);
}

function w3_select_enum(path, func)
{
   var path = w3_el(path);
   if (!path) return;
	w3_iterate_children(path, func);
}

function w3_select_value(path, idx, opt)
{
   if (w3_opt(opt, 'all')) {
      var els = w3_els(path);
      if (!els) return;
      for (var i = 0; i < els.length; i++) {
         els[i].value = idx;
      }
   } else {
      var el = w3_el(path);
      if (!el) return;
      el.value = idx;
   }
}

function w3_select_set_if_includes(path, s)
{
   var found = false;
   var re = RegExp(s);
   w3_select_enum(path, function(option) {
      //console.log('w3_select_set_if_includes s=['+ s +'] consider=['+ option.innerHTML +']');
      if (re.test(option.innerHTML)) {
         if (!found) {
            w3_select_value(path, option.value);
            //console.log('w3_select_set_if_includes TRUE');
            found = true;
         }
      }
   });
   return found;
}


////////////////////////////////
// slider
////////////////////////////////

function w3int_slider_change(ev, complete, path, cb, cb_param)
{
	var el = ev.currentTarget;
	w3_check_restart_reboot(el);
	
	// cb is a string because can't pass an object to onclick
	if (cb) {
	   //console.log('w3int_slider_change path='+ path +' el.value='+ el.value);
		w3_call(cb, path, el.value, complete, /* first */ false, cb_param);
	}
	
	if (complete)
	   w3int_post_action();
}

// deprecated
function w3_slider_old(label, path, val, min, max, step, save_cb)
{
	if (val == null)
		val = '';
	else
		val = w3_strip_quotes(val);
	var oc = 'oninput="w3int_slider_change(event, 0, '+ sq(path) +', '+ sq(save_cb) +')" ';
	// change event fires when the slider is done moving
	var os = 'onchange="w3int_slider_change(event, 1, '+ sq(path) +', '+ sq(save_cb) +')" ';
	var label_s = w3_label('w3-bold', label, path);
	var s =
		label_s +'<br>'+
		'<input id="id-'+ path +'" class="" value=\''+ val +'\' ' +
		'type="range" min="'+ min +'" max="'+ max +'" step="'+ step +'" '+ oc + os +'>';

	// run the callback after instantiation with the initial control value
	if (save_cb)
		setTimeout(function() {
			//console.log('w3_slider: initial callback: '+ save_cb +'('+ sq(path) +', '+ val +')');
			w3_call(save_cb, path, val, /* complete */ true, /* first */ true);
		}, 500);

	//if (path == 'iq.pll_bw') console.log(s);
	return s;
}

function w3_slider(psa, label, path, val, min, max, step, cb, cb_param)
{
	var id = w3_add_id(path);
	var inline = psa.includes('w3-label-inline');
	var bold = !psa.includes('w3-label-not-bold');
	var spacing = (label != '' && inline)? ' w3-margin-L-8' : '';
	if (inline) spacing += ' w3-margin-left';

	value = (val == null)? '' : w3_strip_quotes(val);
	value = 'value='+ dq(value);
	cb_param = cb_param || 0;
	var oc = ' oninput="w3int_slider_change(event, 0, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"';
	// change event fires when the slider is done moving
	var os = ' onchange="w3int_slider_change(event, 1, '+ sq(path) +', '+ sq(cb) +', '+ sq(cb_param) +')"';

   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.left, inline? 'w3-show-inline-new':'');
   var psa_label = w3_psa_mix(psa3.middle, (label != '' && bold)? 'w3-bold':'');
	var psa_inner = w3_psa(psa3.right, id + spacing, '', value +
      ' type="range" min='+ dq(min) +' max='+ dq(max) +' step='+ dq(step) + oc + os);

	var s =
	   '<div '+ psa_outer +'>' +
         w3_label(psa_label, label, path) +
         // need <br> because both <label> and <input-range> are inline elements
         ((!inline && label != '')? '<br>':'') +
         '<input '+ psa_inner +'>' +
      '</div>';

	// run the callback after instantiation with the initial control value
	if (cb)
		setTimeout(function() {
			//console.log('w3_slider: initial callback: '+ cb +'('+ sq(path) +', '+ val +')');
			w3_call(cb, path, val, /* complete */ true, /* first */ true, cb_param);
		}, 500);

	//if (path == 'iq.pll_bw') console.log(s);
	return s;
}

function w3_slider_set(path, val, cb)
{
   w3_set_value(path, val);
   w3_call(cb, path, val, /* complete */ true, /* first */ false);
}

function w3_slider_setup(path, min, max, step, val)
{
   var el = w3_el(path);
   if (!el) return el;
   //console.log('w3_slider_setup path='+ path +' min='+ min +' max='+ max +' step='+ step +' val='+ val);
   el.min = min;
   el.max = max;
   el.step = step;
   el.value = val;
   return el;
}


////////////////////////////////
// menu
////////////////////////////////

function w3_menu(psa, cb)
{
	var id = psa.replace(/\s+/g, ' ').split(' |')[0];
   cb = cb || '';
   //console.log('w3_menu id='+ id +' psa='+ psa);

   var onclick = 'onclick="w3int_menu_onclick(event, '+ sq(id) +', '+ sq(cb) +')"' +
      ' oncontextmenu="w3int_menu_onclick(event, '+ sq(id) +', '+ sq(cb) +')"';
	var p = w3_psa(psa, 'w3-menu w3-round-large', '', onclick);
   var s = '<div '+ p +'></div>';
   //console.log('w3_menu s='+ s);
   w3_el('id-w3-main-container').innerHTML += s;
}

// menu items can be in argument list or passed as an array
function w3_menu_items(id, arr)
{
   //console.log('w3_menu_items id='+ id);

   var s = '';
   var idx = 0, prop, attr;
   var items;

   if (isArray(arr)) {
      items = arr;
   } else {
      // isObject(arr)
      items = [];
      for (var i=1; i < arguments.length; i++)
         items.push(arguments[i]);
   }

   for (var i=0; i < items.length; i++) {
      if (items[i] == '<hr>') {
         prop = 'w3-menu-item-hr';
         attr = '';
      } else
      if (items[i].charAt(0) == '!') {    // first char == '!' hack to disable menu item
         prop = 'w3-menu-item-disabled';
         attr = 'id='+ dq(idx);
         items[i] = items[i].substr(1);
         idx++;
      } else {
         prop = 'w3-menu-item';
         attr = 'id='+ dq(idx);
         idx++;
      }
      s += w3_div(prop +'||'+ attr, items[i]);
   }
   
   //console.log(s);
   w3_el(id).innerHTML = s;
}

function w3_menu_popup(id, x, y)
{
   //console.log('w3_menu_popup id='+ id +' x='+ x +' y='+ y);
   var el = w3_el(id);
	if (x == -1) x = window.innerWidth/2;
	if (y == -1) y = window.innerHeight/2;
   el.style.top = px(y);
   el.style.left = px(x);
   el.style.visibility = 'visible';
   el.w3_menu_x = x;

	// close menu if escape key while menu is displayed
	w3int_menu_close_cur_id = id;
	window.addEventListener("keyup", w3int_menu_close, false);
	window.addEventListener("click", w3int_menu_close, false);
}

function w3int_menu_onclick(ev, id, cb)
{
   //console.log('w3int_menu_onclick id='+ id +' cb='+ cb);
   //if (ev != null) event_dump(ev, "MENU");
   var el = w3_el(id);
   el.style.visibility = 'hidden';

   window.removeEventListener("keyup", w3int_menu_close, false);
   window.removeEventListener("click", w3int_menu_close, false);

   if (ev != null && cb != null) {
      var _id = ev.target.id;
      var idx = +_id;
      if (_id == '' || isNaN(idx)) _id = ev.target.parentNode.id;
      idx = +_id;
      if (_id == '' || isNaN(idx)) idx = -1;
      w3_call(cb, idx, el.w3_menu_x);
   }

   // allow right-button to select menu items
	if (ev != null) {
      //console.log('w3int_menu_onclick: cancelEvent()');
	   return cancelEvent(ev);
	}
}

var w3int_menu_close_cur_id;

// close menu if escape key pressed or a click outside of the menu
function w3int_menu_close(evt)
{
   //event_dump(evt, 'MENU-CLOSE');
   if ((evt.type == 'keyup' && evt.key == 'Escape') ||
      (evt.type == 'click' && evt.button != 2 )) {
      //console.log('w3int_menu_close '+ evt.type +' button='+ evt.button);
      w3int_menu_onclick(null, w3int_menu_close_cur_id);
   }
}


////////////////////////////////
// standard callbacks
////////////////////////////////

function w3_num_cb(path, val)
{
	var v = parseFloat(val);
	if (val == '') v = 0;
	if (isNaN(v)) {
	   //console.log('w3_num_cb path='+ path);
	   w3_set_value(path, 0);
	   v = 0;
	}
	//console.log('w3_num_cb: path='+ path +' val='+ val +' v='+ v);
	setVarFromString(path, v);
}

function w3_bool_cb(path, val)
{
	v = +val;
	//console.log('w3_bool_cb: path='+ path +' val='+ val +' v='+ v);
	setVarFromString(path, v);
}

function w3_string_cb(path, val)
{
	//console.log('w3_string_cb: path='+ path +' val='+ val);
	setVarFromString(path, val.toString());
}

function w3_num_set_cfg_cb(path, val, first)
{
	var v = parseFloat(val);
	if (isNaN(v)) v = 0;
	
	// if first time don't save, otherwise always save
	var save = (first != undefined)? (first? false : true) : true;
	ext_set_cfg_param(path, v, save);
}

function w3_bool_set_cfg_cb(path, val, first)
{
	var v;
	if (val == true || val == 1) v = true; else
	if (val == false || val == 0) v = false; else
	   v = false;
	
	// if first time don't save, otherwise always save
	var save = (first != undefined)? (first? false : true) : true;
	ext_set_cfg_param(path, v, save);
}

function w3_string_set_cfg_cb(path, val, first)
{
	//console.log('w3_string_set_cfg_cb: path='+ path +' '+ typeof(val) +' "'+ val +'" first='+ first);
	
	// if first time don't save, otherwise always save
	var save = (first != undefined)? (first? false : true) : true;
	ext_set_cfg_param(path, encodeURIComponent(val.toString()), save);
}

function w3_remove_trailing_index(path, sep)
{
   sep = sep || '-';    // optional separator, e.g. if negative indicies are used
   var re = new RegExp('(.*)'+ sep +'([-]?[0-9]+)');
	var el = re.exec(path);      // remove trailing -nnn
   //console.log('w3_remove_trailing_index path='+ path +' el='+ el);
	var idx;
	if (!el) {
	   idx = -1;
	   el = path;
	} else {
	   idx = el[2];
	   el = el[1];
	}
	return { el:el, idx:idx };
}


////////////////////////////////
// tables
////////////////////////////////

// caller can choose more specific table type, e.g. w3-table-fixed
// FIXME: deprecated, only still used in admin GPS
function w3_table(psa)
{
	var p = w3_psa(psa, 'w3-table w3-table-default');
	var s = '<table '+ p +'>';
		for (var i=1; i < arguments.length; i++) {
			s += arguments[i];
		}
	s += '</table>';
	//console.log(s);
	return s;
}

function w3_table_heads(psa)
{
	var p = w3_psa(psa, 'w3-table-head');
	var s = '';
	for (var i=1; i < arguments.length; i++) {
	   if (arguments[i] == null) continue;
		s += '<th '+ p +'>';
		s += arguments[i];
		s += '</th>';
	}
	//console.log(s);
	return s;
}

function w3_table_row(psa)
{
	var p = w3_psa(psa, 'w3-table-row');
	var s = '<tr '+ p +'>';
		for (var i=1; i < arguments.length; i++) {
	      if (arguments[i] == null) continue;
			s += arguments[i];
		}
	s += '</tr>';
	//console.log(s);
	return s;
}

function w3_table_cells(psa)
{
	var p = w3_psa(psa, 'w3-table-cell');
	var s = '';
	for (var i=1; i < arguments.length; i++) {
	   if (arguments[i] == null) continue;
		s += '<td '+ p +'>';
		s += arguments[i];
		s += '</td>';
	}
	//console.log(s);
	return s;
}


////////////////////////////////
// containers
////////////////////////////////

function w3_inline(psa, attr)
{
	var narg = arguments.length;
   
   if (psa == '' && attr == '' && narg > 2) {
      console.log('### w3_inline OLD API DEPRECATED');
      var args = Array.prototype.splice.call(arguments, 0);
      args.splice(0, 1);
      return w3_inline.apply(null, args);
   } else {
      var psa3 = w3_psa3(psa);
      var psa_outer = w3_psa(psa3.middle, 'w3-show-inline-new');
      var psa_inner = w3_psa(psa3.right);
      var s = '<div w3d-inlo '+ psa_outer +'>';
      for (var i = 1; i < narg; i++) {
         var psa;
         var a = arguments[i];
         
         // merge a pseudo psa specifier into the next argument
         // i.e. 'w3-*', w3_*('w3-psa') => w3_*('w3-* w3-psa')
         var psa_merge = false;
         if (a.startsWith('w3-') || a.startsWith('id-')) {
            psa = w3_psa(psa3.right, a);
            i++;
            a = arguments[i];
            psa_merge = true;
         } else {
            psa = psa_inner;
         }
         
         // If the psa is null, and the arg is a div, don't wrap it with our usual enclosing div.
         // This solves the "w3_inline() + w3-hide" problem where our extra div
         // added by w3_inline isn't the one with the w3-hide, and causes unwanted spacing when
         // using w3_inline('w3-halign-space-between/').
         if (psa3.right == '' && !psa_merge && a.startsWith('<div '))
            s += a;
         else
            s += '<div w3d-inli-'+ (i-1) +' '+ psa +'>'+ a + '</div>';
      }
      s += '</div>';
      //console.log(s);
      return s;
   }
}

function w3_inline_percent(psa)
{
   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.middle, 'w3-show-inline-new');
	var narg = arguments.length;
	var total = 0;
	var s = '<div w3d-inlpo '+ psa_outer +'>';
		for (var i = 1; i < narg; i += 2) {
		   var style;
		   if (i+1 < narg) {
		      style = 'width:'+ arguments[i+1] +'%';
		      total += arguments[i+1];
		   } else {
		      style = 'width:'+ (100 - total) +'%';
		   }
			s += '<div w3d-inlpi-'+ ((i-1)/2) +' '+ w3_psa(psa3.right, '', style) +'>'+ arguments[i] + '</div>';
		}
	s += '</div>';
	//console.log(s);
	return s;
}

function w3_div(psa)
{
   var p = w3_psa(psa);
	var s = '<div w3d-div '+ p +'>';
	var narg = arguments.length;
		for (var i=1; i < narg; i++) {
			s += arguments[i];
		}
	s += '</div>';
	//console.log(s);
	return s;
}

function w3_span(psa)
{
   var p = w3_psa(psa, 'w3-show-span');
	var s = '<div w3d-span '+ p +'>';
	var narg = arguments.length;
		for (var i=1; i < narg; i++) {
			s += arguments[i];
		}
	s += '</div>';
	//console.log(s);
	return s;
}

function w3_divs(psa, attr)
{
   var narg = arguments.length;
   var s;

   if (psa == '' && attr == '') {
      console.log('### w3_divs OLD API 1 DEPRECATED');
      //console.log('prop=<'+ psa +'> attr=<'+ attr +'>');
      //kiwi_trace();
      s = w3_div.apply(null, Array.prototype.splice.call(arguments, 1));
      //console.log(s);
      return s;
   } else
   if (psa != '' && attr == '' && narg > 2) {
      console.log('### w3_divs OLD API 2 DEPRECATED');
      //console.log('prop=<'+ psa +'> attr=<'+ attr +'>');
      //kiwi_trace();
      var args = Array.prototype.splice.call(arguments, 0);
      args.splice(1, 1);
      s = w3_div.apply(null, args);
      //console.log(s);
      return s;
   } else
   if (psa == '' && attr && attr.startsWith('w3-') && narg > 2) {
      console.log('### w3_divs OLD API 3 DEPRECATED');
      //console.log('prop=<'+ psa +'> attr=<'+ attr +'>');
      //kiwi_trace();
      var args = Array.prototype.splice.call(arguments, 0);
      args.splice(0, 1);
      s = w3_divs.apply(null, args);
      //console.log(s);
      return s;
   } else
   if (psa != '' && attr && attr.startsWith('w3-') && narg > 2) {
      console.log('### w3_divs OLD API 4 DEPRECATED');
      //console.log('prop=<'+ psa +'> attr=<'+ attr +'>');
      //kiwi_trace();
      var args = Array.prototype.splice.call(arguments, 2);
      args.splice(0, 0, arguments[0] +'/'+ arguments[1]);
      s = w3_divs.apply(null, args);
      //console.log(s);
      return s;
   } else {
      var psa3 = w3_psa3(psa);
      var psa_outer = w3_psa(psa3.middle);
      var psa_inner = w3_psa(psa3.right);
      s = '<div w3d-divso '+ psa_outer +'>';
         for (var i=1; i < narg; i++) {
            s += '<div w3d-divsi-'+ (i-1) +' '+ psa_inner +'>'+ arguments[i] + '</div>';
         }
      s += '</div>';
      //console.log(s);
      return s;
   }
}

function w3_col_percent(psa)
{
   var psa3 = w3_psa3(psa);
   var psa_outer = w3_psa(psa3.middle, 'w3-row');
	var narg = arguments.length;
	var s = '<div w3d-colpo '+ psa_outer +'>';
		for (var i = 1; i < narg; i += 2) {
		   var prop, style;
		   if (i+1 < narg) {
		      prop = 'w3-col';
		      style = 'width:'+ arguments[i+1] +'%';
		   } else {
		      prop = 'w3-rest';
		      style = '';
		   }
			s += '<div w3d-colpi-'+ ((i-1)/2) +' '+ w3_psa(psa3.right, prop, style) +'>'+ arguments[i] + '</div>';
		}
	s += '</div>';
	//console.log(s);
	return s;
}

// the w3-text makes it inline-block, so no surrounding w3_inline() needed
function w3_text(psa, text)
{
	var s = w3_div(w3_psa_mix(psa, 'w3-text', 'padding:0 4px 0 0; background-color:inherit'), text? text:' ');
	//console.log(s);
	return s;
}

function w3_code(prop_outer, prop_inner)
{
	var narg = arguments.length;
	var s = '<pre class="'+ prop_outer +'"><code>';
		for (var i=2; i < narg; i++) {
			s += '<div class="'+ prop_inner +'">'+ arguments[i] + '</div>';
		}
	s += '</code></pre>';
	//console.log(s);
	return s;
}

function w3_half(prop_row, prop_col, left, right, prop_left, prop_right)
{
	if (prop_left == undefined) prop_left = '';
	if (prop_right == undefined) prop_right = '';

	var s =
	'<div class="w3-row '+ prop_row +'">' +
		'<div class="w3-col w3-half '+ prop_col + prop_left +'">' +
			left +
		'</div>' +
		'<div class="w3-col w3-half '+ prop_col + prop_right +'">' +
			(right? right:'') +
		'</div>' +
	'</div>';
	//console.log(s);
	return s;
}

function w3_third(prop_row, prop_col, left, middle, right)
{
	var s =
	'<div class="w3-row '+ prop_row +'">' +
		'<div class="w3-col w3-third '+ prop_col +'">' +
			left +
		'</div>' +
		'<div class="w3-col w3-third '+ prop_col +'">' +
			(middle? middle:'') +
		'</div>' +
		'<div class="w3-col w3-third '+ prop_col +'">' +
			(right? right:'') +
		'</div>' +
	'</div>';
	//console.log(s);
	return s;
}

function w3_quarter(prop_row, prop_col, left, middleL, middleR, right)
{
	var s =
	'<div class="w3-row '+ prop_row +'">' +
		'<div class="w3-col w3-quarter '+ prop_col +'">' +
			left +
		'</div>' +
		'<div class="w3-col w3-quarter '+ prop_col +'">' +
			(middleL? middleL:'') +
		'</div>' +
		'<div class="w3-col w3-quarter '+ prop_col +'">' +
			(middleR? middleR:'') +
		'</div>' +
		'<div class="w3-col w3-quarter '+ prop_col +'">' +
			(right? right:'') +
		'</div>' +
	'</div>';
	//console.log(s);
	return s;
}

function w3_canvas(psa, w, h, opt)
{
   var s = '';
   var pad = w3_opt(opt, 'pad', null);
   var pad_top = w3_opt(opt, 'pad_top', 0);
   var pad_bot = w3_opt(opt, 'pad_bottom', 0);
   if (!isNull(pad)) pad_top = pad_bot = pad;
   pad = pad_top + pad_bot;
   if (pad) {
      //w -= pad*2; h -= pad*2;
      s += sprintf(' padding-top:%dpx; padding-bottom:%dpx;', pad_top, pad_bot);
   }

   var left = w3_opt(opt, 'left', '');
   if (left != '') s += sprintf(' left:%dpx;', left);
   var right = w3_opt(opt, 'right', '');
   if (right != '') s += sprintf(' right:%dpx;', right);
   var top = w3_opt(opt, 'top', '');
   if (top != '') s += sprintf(' top:%dpx;', top);

   s = '<canvas '+ w3_psa(psa, null, 'position:absolute;'+ s, sprintf('width="%d" height="%d"', w, h)) +'></canvas>';
	//console.log(s);
	return s;
}





/* web/openwebrx/openwebrx.min.js */
/*

OpenWebRX (c) Copyright 2013-2014 Andras Retzler <randras@sdr.hu>

This file is part of OpenWebRX.

    OpenWebRX is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenWebRX is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenWebRX. If not, see <http://www.gnu.org/licenses/>.

*/

// Copyright (c) 2015 - 2018 John Seamons, ZL/KF6VO

var owrx = {
   mobile: null,
   
   last_freq: -1,
   last_mode: '',
   last_locut: -1,
   last_hicut: -1,
   
   last_mode_el: null,
   dseq: 0,
   
   touch_hold_pressed: false,
   tuning_locked: 0,
   
   dx_click_gid_last: undefined,
};

// key freq concepts:
//		all freqs in Hz
//		center_freq is center of entire sampled bandwidth (e.g. 15 MHz)
//		offset_frequency (-bandwidth/2 .. bandwidth/2) = center_freq - freq
//		freq = center_freq + offset_frequency

// constants, passed from server
var bandwidth;
var center_freq;
var wf_fft_size;

// UI geometry
var height_top_bar_parts = 67;
var height_spectrum_canvas = 200;

var cur_mode;
var wf_fps, wf_fps_max;

var ws_snd, ws_wf;

var spectrum_show = 0, spectrum_param = -1;
var gen_freq = 0, gen_attn = 0;
var squelch_threshold = 0;
var wf_rate = '';
var wf_mm = '';
var wf_compression = 1;
var debug_v = 0;		// a general value settable from the URI to be used during debugging
var sb_trace = 0;
var kiwi_gc = 1;
var kiwi_gc_snd = 0;
var kiwi_gc_wf = -1;
var kiwi_gc_recv = -1;
var kiwi_gc_wspr = -1;
var override_ext = null;
var muted_initially = 0;
var peak_initially = null;
var param_nocache = false;
var nocache = false;
var param_ctrace = false;
var ctrace = false;
var no_clk_corr = false;
var override_pbw = '';
var override_pbc = '';
var nb_click = false;
var no_geoloc = false;
var mobile_laptop_test = false;

var freq_memory = [];
var freq_memory_pointer = -1;

var wf_rates = { '0':0, 'off':0, '1':1, '1hz':1, 's':2, 'slow':2, 'm':3, 'med':3, 'f':4, 'fast':4 };

var okay_waterfall_init = false;

function kiwi_main()
{
	override_freq = parseFloat(readCookie('last_freq'));
	override_mode = readCookie('last_mode');
	override_zoom = parseFloat(readCookie('last_zoom'));
	override_9_10 = parseFloat(readCookie('last_9_10'));
	override_max_dB = parseFloat(readCookie('last_max_dB'));
	override_min_dB = parseFloat(readCookie('last_min_dB'));
	
	var f_cookie = readCookie('freq_memory');
	if (f_cookie) {
	   freq_memory = JSON.parse(f_cookie);
	   freq_memory_pointer = freq_memory.length-1;
   }
	
	console.log('LAST f='+ override_freq +' m='+ override_mode +' z='+ override_zoom
		+' 9_10='+ override_9_10 +' min='+ override_min_dB +' max='+ override_max_dB);

	// process URL query string parameters
	var num_win = 16;     // FIXME: should really be rx_chans, but that's not available yet 
	console.log('URL: '+ window.location.href);
	
	var qs_parse = function(s) {
		var qd = {};
		if (s) s.split("&").forEach(function(item) {
			var a = item.split("=");
			qd[a[0]] = a[1]? a[1] : 1;		// &foo& shorthand for &foo=1&
		});
		return qd;
	}
	
	var q = window.location.search && window.location.search.substr(1);		// skip initial '?'
	var qs = [], qd = [];
	for (w = 1; w <= num_win; w++) {
		var win = '&win'+ (w+1) +'&';
		qs[w] = q && q.split(win)[0];
		q     = q && q.split(win)[1];
		qd[w] = qs_parse(qs[w]);
		qd[w].WID = w;
		//console.log(qd[w]);
	}

	var host = window.location.href.split('?')[0];
	g_qs_idx = 2;     // NB: global var
	for (w = 2; w <= num_win; w++) {
      if (qs[w]) {
         setTimeout(function() {
               var url = host +'?'+ qs[g_qs_idx];
               g_qs_idx++;
               //console.log('OPEN '+ url);
               var win = window.open(url, '_blank');
               //console.log(win);
               if (win == null)
                  alert('Do you have popups blocked for this site? '+ url);
            }, (w-1) * 2000
         );
      }
	}
	
	// reminder about how advanced features of RegExp work:
	// x*			matches x 0 or more times
	// x+			matches x 1 or more times
	// x?			matches x 0 or 1 time
	// (x)		capturing parens, stores in array beginning at [1]
	// (?:x)y	non-capturing parens, allows y to apply to multi-char x
	//	x|y		alternative (or)
	// x? x* x+	0/1, >=0, >=1 occurrences of x

	var q = qd[1];
	//console.log('this window/tab:');
	//console.log(q);
	
	s = 'f'; if (q[s]) {
		var p = new RegExp('([0-9.,kM]*)([\/:][-0-9.,k]*)?([^z]*)?z?([0-9]*)').exec(q[s]);
      // 'k' suffix is simply ignored since default frequencies are in kHz
      if (p[1]) override_freq = p[1].replace(',', '.').parseFloatWithUnits('M', 1e-3);
      if (p[1]) console.log('p='+ p[1] +' override_freq='+ override_freq);
      if (p[2]) console.log('override_pbw/pbc='+ p[2]);
		if (p[2] && p[2].charAt(0) == '/') override_pbw = p[2].substr(1);     // remove leading '/'
		if (p[2] && p[2].charAt(0) == ':') override_pbc = p[2].substr(1);     // remove leading ':'
		if (p[3]) override_mode = p[3].toLowerCase();
		if (p[4]) override_zoom = p[4];
		//console.log('### f=['+ q[s] +'] len='+ p.length +' f=['+ p[1] +'] p=['+ p[2] +'] m=['+ p[3] +'] z=['+ p[4] +']');
	}

	s = 'ext'; if (q[s] && isString(q[s])) {
	   var ext = q[s].split(',');
		override_ext = ext[0];
		extint.param = ext.slice(1).join(',');
		console.log('URL: ext='+ override_ext +' ext_p='+ extint.param);
	}

	s = 'pbw'; if (q[s]) override_pbw = q[s];
	s = 'pb'; if (q[s]) override_pbw = q[s];
	s = 'pbc'; if (q[s]) override_pbc = q[s];
	s = 'sp'; if (q[s]) spectrum_show = q[s];
	s = 'spp'; if (q[s]) spectrum_param = parseFloat(q[s]);
	s = 'vol'; if (q[s]) { volume = parseInt(q[s]); volume = Math.max(0, volume); volume = Math.min(400, volume); }
	s = 'mute'; if (q[s]) muted_initially = parseInt(q[s]);
	s = 'wf'; if (q[s]) wf_rate = q[s];
	s = 'wfm'; if (q[s]) wf_mm = q[s];
	s = 'cmap'; if (q[s]) wf.cmap_override = w3_clamp(parseInt(q[s]), 0, kiwi.cmap_s.length - 1, 0);
	s = 'sqrt'; if (q[s]) wf.sqrt = w3_clamp(parseInt(q[s]), 0, 4, 0);
	s = 'peak'; if (q[s]) peak_initially = parseInt(q[s]);
	s = 'no_geo'; if (q[s]) no_geoloc = true;
	s = 'keys'; if (q[s]) shortcut.keys = q[s];
	// 'no_wf' is handled in kiwi_util.js

   // development
	s = 'sqth'; if (q[s]) squelch_threshold = parseFloat(q[s]);
	s = 'click'; if (q[s]) nb_click = true;
	s = 'nocache'; if (q[s]) { param_nocache = true; nocache = parseInt(q[s]); }
	s = 'ncc'; if (q[s]) no_clk_corr = parseInt(q[s]);
	s = 'wfdly'; if (q[s]) waterfall_delay = parseFloat(q[s]);
	s = 'wf_comp'; if (q[s]) wf_compression = parseInt(q[s]);
	s = 'gen'; if (q[s]) gen_freq = parseFloat(q[s]);
	s = 'attn'; if (q[s]) gen_attn = parseInt(q[s]);
	s = 'blen'; if (q[s]) audio_buffer_min_length_sec = parseFloat(q[s])/1000;
	s = 'audio'; if (q[s]) audio_meas_dly_ena = parseFloat(q[s]);
	s = 'gc'; if (q[s]) kiwi_gc = parseInt(q[s]);
	s = 'gc_snd'; if (q[s]) kiwi_gc_snd = parseInt(q[s]);
	s = 'gc_wf'; if (q[s]) kiwi_gc_wf = parseInt(q[s]);
	s = 'gc_recv'; if (q[s]) kiwi_gc_recv = parseInt(q[s]);
	s = 'gc_wspr'; if (q[s]) kiwi_gc_wspr = parseInt(q[s]);
	s = 'ctrace'; if (q[s]) { param_ctrace = true; ctrace = parseInt(q[s]); }
	s = 'mobile'; if (q[s]) mobile_laptop_test = true;
	s = 'v'; if (q[s]) console.log('URL: debug_v = '+ (debug_v = q[s]));

	if (kiwi_gc_snd == -1) kiwi_gc_snd = kiwi_gc;
	if (kiwi_gc_wf == -1) kiwi_gc_wf = kiwi_gc;
	if (kiwi_gc_recv == -1) kiwi_gc_recv = kiwi_gc;
	if (kiwi_gc_wspr == -1) kiwi_gc_wspr = kiwi_gc;
	console.log('GC: snd='+ kiwi_gc_snd +' wf='+ kiwi_gc_wf +' recv='+ kiwi_gc_recv +' wspr='+ kiwi_gc_wspr);
	
	if (wf_mm != '') {
	   wf_mm = wf_mm.split(',');
	   var m = parseInt(wf_mm[0]);
	   if (!isNaN(m) && m >= -190 && m <= -30) override_min_dB = m;
	   if (wf_mm.length >= 2) {
	      m = parseInt(wf_mm[1]);
	      if (!isNaN(m) && m >= -100 && m <= 20) override_max_dB = m;
	   }
	}

	kiwi_xdLocalStorage_init();
	kiwi_get_init_settings();
	if (!no_geoloc) kiwi_geolocate();

	init_rx_photo();
	right_click_menu_init();
	keyboard_shortcut_init();
	confirmation_panel_init();
	ext_panel_init();
	place_panels();
	init_panels();
   okay_waterfall_init = true;
	confirmation_panel_init2();
	smeter_init();
	time_display_setup('id-topbar-right-container');
	
	window.setInterval(send_keepalive, 5000);
	window.addEventListener("resize", openwebrx_resize);
        
   if (param_nocache) {
      //msg_send("SET nocache="+ (nocache? 1:0));
      console.log('### nocache='+ (nocache? 1:0));
   }
   if (param_ctrace) {
      //msg_send("SET ctrace="+ (ctrace? 1:0));
      console.log('### ctrace='+ (ctrace? 1:0));
   }

	// FIXME: eliminate most of these
	snd_send("SERVER DE CLIENT openwebrx.js SND");
	snd_send("SET dbug_v="+ debug_v);

   if (gen_attn != 0) {
      var dB = gen_attn;
      var ampl_gain = Math.pow(10, -dB/20);		// use the amplitude form since we are multipling a signal
      gen_attn = 0x01ffff * ampl_gain;
      console.log('### GEN dB='+ dB +' ampl_gain='+ ampl_gain +' attn='+ gen_attn +' / '+ gen_attn.toHex());
   }
   
   if (gen_freq || gen_attn)
	   set_gen(gen_freq, gen_attn);

	snd_send("SET mod=am low_cut=-4000 high_cut=4000 freq=1000");
	set_agc();
	snd_send("SET browser="+navigator.userAgent);
	
	wf_send("SERVER DE CLIENT openwebrx.js W/F");
	wf_send("SET send_dB=1");
	// fixme: okay to remove this now?
	wf_send("SET zoom=0 start=0");
	wf_send("SET maxdb=0 mindb=-100");
	if (wf_compression == 0) wf_send('SET wf_comp=0');
	wf_speed = wf_rates[wf_rate];
	//console.log('wf_rate="'+ wf_rate +'" wf_speed='+ wf_speed);
	if (wf_speed == undefined) wf_speed = WF_SPEED_FAST;
	wf_send('SET wf_speed='+ wf_speed);
}

var ptype = { HIDE:0, POPUP:1, TOGGLE:2 };
var popt = { CLOSE:-1, PERSIST:0 };
var visBorder = 10;
var visIcon = 24;

var readme_color = 'blueViolet';

var show_news = false;
//var news_color = '#bf00ff';
//var news_color = '#40ff00';
var news_color = '#ff00bf';

function init_panels()
{
	init_panel_toggle(ptype.TOGGLE, 'id-control', false, popt.PERSIST);

	var readme_firsttime = updateCookie('readme', 'seen2');
	if (kiwi_isMobile()) readme_firsttime = false;     // don't show readme panel at all on mobile devices
	init_panel_toggle(ptype.TOGGLE, 'id-readme', false, readme_firsttime? popt.PERSIST : popt.CLOSE, readme_color);

	//init_panel_toggle(ptype.TOGGLE, 'id-msgs', true, kiwi_isMobile()? popt.CLOSE : popt.PERSIST);
	//init_panel_toggle(ptype.POPUP, 'id-msgs', true, popt.CLOSE);

	var news_firsttime = (readCookie('news', 'seen') == null);
	init_panel_toggle(ptype.POPUP, 'id-news', false, show_news? (news_firsttime? popt.PERSIST : popt.CLOSE) : popt.CLOSE);

	init_panel_toggle(ptype.POPUP, 'id-ext-controls', false, popt.CLOSE);

	init_panel_toggle(ptype.POPUP, 'id-confirmation', false, popt.CLOSE);
}

function init_panel_toggle(type, panel, scrollable, timeo, color)
{
	var divPanel = w3_el(panel);
	divPanel.ptype = type;
	//console.log('init_panel_toggle '+ panel +' ptype='+ divPanel.ptype +' '+ type);
	var divVis = w3_el(panel +'-vis');
	divPanel.scrollable = (scrollable == true)? true:false;
	var visHoffset = (divPanel.scrollable)? -kiwi_scrollbar_width() : visBorder;
	var rightSide = (divPanel.getAttribute('data-panel-pos') == "right");
   divPanel.panelShown = 1;
	
	if (type == ptype.TOGGLE) {
		var hide = rightSide? 'right':'left';
		var show = rightSide? 'left':'right';
		divVis.innerHTML =
			'<a id="'+panel+'-hide" onclick="toggle_panel('+ sq(panel) +');"><img src="icons/hide'+ hide +'.24.png" width="24" height="24" /></a>' +
			'<a id="'+panel+'-show" class="class-vis-show" onclick="toggle_panel('+ sq(panel) +');"><img src="icons/hide'+ show +'.24.png" width="24" height="24" /></a>';
	} else {		// ptype.POPUP or ptype:HIDE
		divVis.innerHTML =
			'<a id="'+panel+'-close" onclick="toggle_panel('+ sq(panel) +');">' +
			   '<img id='+ dq(panel +'-close-img') +' src="icons/close.24.png" width="24" height="24" />' +
			'</a>';
	}

	var visOffset = divPanel.activeWidth - visIcon;
	//console.log("init_panel_toggle "+panel+" right="+rightSide+" off="+visOffset);
	if (rightSide) {
		divVis.style.right = px(0);
		//console.log("RS2");
	} else {
		divVis.style.left = px(visOffset + visHoffset);
	}
	divVis.style.top = px(visBorder);
	//console.log("ARROW l="+divVis.style.left+" r="+divVis.style.right+' t='+divVis.style.top);

	if (timeo != undefined) {
      //console.log(panel +' timeo='+ timeo);
		if (timeo) {
			setTimeout(function() {toggle_panel(panel);}, timeo);
		} else
		if (timeo == popt.CLOSE) {
			toggle_panel(panel);		// make it go away immediately
		} else
		if (type == ptype.POPUP) {
			divPanel.style.visibility = "visible";
		}
	}
	if (color != undefined) {
		var divShow = w3_el(panel+'-show');
		if (divShow != undefined) divShow.style.backgroundColor = divShow.style.borderColor = color;
	}
}

function toggle_panel(panel, set)
{
	var divPanel = w3_el(panel);
	var divVis = w3_el(panel +'-vis');
	//console.log('toggle_panel '+ panel +' ptype='+ divPanel.ptype +' panelShown='+ divPanel.panelShown);
	
	if (isDefined(set)) divPanel.panelShown = set ^ 1;    // ^1 because of inverted logic below

	if (divPanel.ptype == ptype.POPUP) {
		divPanel.style.visibility = divPanel.panelShown? 'hidden' : 'visible';
		divPanel.panelShown ^= 1;
		updateCookie(panel, 'seen');
	   freqset_select();
		return;
	}
	
	var arrow_width = 12, hideWidth = divPanel.activeWidth + 2*15;
	var rightSide = (divPanel.getAttribute('data-panel-pos') == "right");
	var from, to;

	hideWidth = rightSide? -hideWidth : -hideWidth;
	if (divPanel.panelShown) {
		from = 0; to = hideWidth;
	} else {
		from = hideWidth; to = kiwi_scrollbar_width();
	}
	
	animate(divPanel, rightSide? 'right':'left', "px", from, to, 0.93, kiwi_isMobile()? 1:1000, 60, 0);
	
	w3_hide(panel +'-'+ (divPanel.panelShown? 'hide':'show'));
	w3_show_block(panel +'-'+ (divPanel.panelShown? 'show':'hide'));
	divPanel.panelShown ^= 1;

	var visOffset = divPanel.activeWidth - visIcon;
	var visHoffset = (divPanel.scrollable)? -kiwi_scrollbar_width() : visBorder;
	console.log("toggle_panel "+panel+" right="+rightSide+" shown="+divPanel.panelShown);
	if (rightSide)
		divVis.style.right = px(divPanel.panelShown? 0 : (visOffset + visIcon + visBorder*2));
	else
		divVis.style.left = px(visOffset + (divPanel.panelShown? visHoffset : (visIcon + visBorder*2)));
	freqset_select();
}

function openwebrx_resize(a)
{
   a = (isString(a) && a.startsWith('orient'))? a : 'event';
	resize_canvases();
	resize_waterfall_container(true);
   extint_environment_changed( { resize:1 } );
	resize_scale(a);
	check_top_bar_congestion();
}

/*
var orient = { cnt:0 };
function orientation_change() {
   //openwebrx_resize('orient '+ orientation);
   orient.AW = window.innerWidth;
   orient.AH = window.innerHeight;
   if (orient.cnt == 0) {
      setTimeout(function() {    // timing matters on iphone-5S but not iPad-2!
         alert('orient #'+ orient.cnt +' '+
            orient.AW +','+ orient.AH +' '+ window.innerWidth +','+ window.innerHeight);
         orient.cnt = 0;
      }, 500);
   } else orient.cnt++;
}

try {
   window.onorientationchange = orientation_change;
} catch(ex) {}
*/

var offsetDiff_init = false;
var p_left, p_owner, p_mid, p_right;

function offsetDiff(name, color, lrw, p_lrw)
{
	var el = w3_el('id-tbar-'+ name.toLowerCase() +'-bbox');
	el.style.left = px(lrw.x1);
	el.style.width = px(lrw.w);
	el.style.height = px(lrw.h);
	el.style.backgroundColor = color;

	console.log(name +' L/R/W='+ lrw.x1 +'/'+ lrw.x2 +'/'+ lrw.w +' ('+
	   (p_lrw.x1-lrw.x1) +'/'+ (p_lrw.x2-lrw.x2) +'/'+ (p_lrw.w-lrw.w) +')');
}

function check_top_bar_congestion()
{
	var left = w3_boundingBox_children('id-left-info-container');
	var owner = w3_boundingBox_children('id-mid-owner-container');
	var mid = w3_boundingBox_children('id-mid-info-container');
	var right = w3_boundingBox_children('id-topbar-right-container');
	
	// position owner info in the middle of the gap between left and mid bbox
	var owner_left = left.x2 + (mid.x1 - left.x2)/2 - owner.w/2;
	//console.log('owner_left='+ owner_left);
	w3_el('id-owner-info').style.left = px(owner_left);
	owner = w3_boundingBox_children('id-mid-owner-container');     // recompute after change
	
	// Selectively hide all but the left bbox.
	// Can't use w3_show_hide() because otherwise bbox values would be zero when hidden
	// and bbox would never reappear.
	w3_visible('id-mid-owner-container', owner.x1 >= left.x2);
	w3_visible('id-mid-info-container', mid.x1 >= left.x2);
	w3_visible('id-topbar-right-container', right.x1 >= left.x2);
	
	// place photo open arrow right after left bbox
	w3_el('id-rx-details-arrow').style.left = px(left.x2);

   /*
      if (!offsetDiff_init) {
         offsetDiff_init = true;
         p_left = left;
         p_owner = owner;
         p_mid = mid;
         p_right = right;
         w3_el('id-top-bar').innerHTML +=
            '<div class="id-tbar-left-bbox cl-tbar-bbox"></div>' +
            '<div class="id-tbar-owner-bbox cl-tbar-bbox"></div>' +
            '<div class="id-tbar-mid-bbox cl-tbar-bbox"></div>' +
            '<div class="id-tbar-right-bbox cl-tbar-bbox"></div>';
      }
      
      console.log('----');
      offsetDiff('LEFT', 'yellow', left, p_left);
      p_left = left;
      offsetDiff('OWNER', 'cyan', owner, p_owner);
      p_owner = owner;
      offsetDiff('MID', 'green', mid, p_mid);
      p_mid = mid;
      offsetDiff('RIGHT', 'red', right, p_right);
      p_right = right;
   */
}

var rx_photo_spacer_height = height_top_bar_parts;

function init_rx_photo()
{
   w3_el('id-top-photo-img').style.paddingLeft = RX_PHOTO_LEFT_MARGIN? '50px' : 0;
	RX_PHOTO_HEIGHT += rx_photo_spacer_height;
	w3_el("id-top-photo-clip").style.maxHeight = px(RX_PHOTO_HEIGHT);
	//window.setTimeout(function() { animate(html("id-rx-photo-title"),"opacity","",1,0,1,500,30); },1000);
	//window.setTimeout(function() { animate(html("id-rx-photo-desc"),"opacity","",1,0,1,500,30); },1500);
	if (dbgUs || kiwi_isMobile()) {
		close_rx_photo();
	} else {
		window.setTimeout(function() { close_rx_photo() },3000);
	}
}

var rx_photo_state=1;

function open_rx_photo()
{
	rx_photo_state=1;
	html("id-rx-photo-desc").style.opacity=1;
	html("id-rx-photo-title").style.opacity=1;
	animate_to(html("id-top-photo-clip"),"maxHeight","px",RX_PHOTO_HEIGHT,0.93,kiwi_isMobile()? 1:1000,60,function(){resize_waterfall_container(true);});
	w3_hide('id-rx-details-arrow-down');
	w3_show_block('id-rx-details-arrow-up');
}

function close_rx_photo()
{
	rx_photo_state=0;
	animate_to(html("id-top-photo-clip"),"maxHeight","px",rx_photo_spacer_height,0.93,kiwi_isMobile()? 1:1000,60,function(){resize_waterfall_container(true);});
	w3_show_block('id-rx-details-arrow-down');
	w3_hide('id-rx-details-arrow-up');
}

dont_toggle_rx_photo_flag=0;

function dont_toggle_rx_photo()
{
	dont_toggle_rx_photo_flag=1;
}

function toggle_rx_photo()
{
	if (dont_toggle_rx_photo_flag) { dont_toggle_rx_photo_flag=0; return; }
	if (rx_photo_state)
		close_rx_photo();
	else
		open_rx_photo();
	freqset_select();
}


////////////////////////////////
// =================  >ANIMATION ROUTINES  ================
////////////////////////////////

function animate(object, style_name, unit, from, to, accel, time_ms, fps, to_exec)
{
	//console.log(object.className);
	if (isUndefined(to_exec)) to_exec=0;
	object.style[style_name]=from.toString()+unit;
	object.anim_i=0;
	n_of_iters=time_ms/(1000/fps);
	if (n_of_iters < 1) n_of_iters = 1;
	change=(to-from)/(n_of_iters);
	if (isDefined(object.anim_timer)) { window.clearInterval(object.anim_timer);  }

	object.anim_timer = window.setInterval(
		function(){
			if (object.anim_i++<n_of_iters)
			{
				if (accel==1) object.style[style_name] = (parseFloat(object.style[style_name]) + change).toString() + unit;
				else 
				{ 
					remain=parseFloat(object.style[style_name])-to;
					if (Math.abs(remain)>9||unit!="px") new_val=(to+accel*remain);
					else {if (Math.abs(remain)<2) new_val=to;
					else new_val=to+remain-(remain/Math.abs(remain));}
					object.style[style_name]=new_val.toString()+unit;
				}
			}
			else 
				{object.style[style_name]=to.toString()+unit; window.clearInterval(object.anim_timer); delete object.anim_timer;}
			if (to_exec!=0) to_exec();
		},1000/fps);
}

function animate_to(object, style_name, unit, to, accel, time_ms, fps, to_exec)
{
	from = parseFloat(style_value(object, style_name));
	//console.log("FROM "+style_name+'='+from);
	animate(object, style_name, unit, from, to, accel, time_ms, fps, to_exec);
}

function style_value(of_what, which)
{
	if (of_what.currentStyle)
		return of_what.currentStyle[which];
	else
	if (window.getComputedStyle)
		return document.defaultView.getComputedStyle(of_what,null)[which];
	else
		return of_what.style[which];
}

/*function fade(something,from,to,time_ms,fps)
{
	something.style.opacity=from;
	something.fade_i=0;
	n_of_iters=time_ms/(1000/fps);
	change=(to-from)/(n_of_iters-1);
	
	something.fade_timer=window.setInterval(
		function(){
			if (something.fade_i++<n_of_iters)
				something.style.opacity=parseFloat(something.style.opacity)+change;
			else 
				{something.style.opacity=to; window.clearInterval(something.fade_timer); }
		},1000/fps);
}*/


////////////////////////////////
// ================  >DEMODULATOR ROUTINES  ===============
////////////////////////////////

demodulators=[]

demodulator_color_index=0;
demodulator_colors=["#ffff00", "#00ff00", "#00ffff", "#058cff", "#ff9600", "#a1ff39", "#ff4e39", "#ff5dbd"]

function demodulators_get_next_color()
{
	if (demodulator_color_index>=demodulator_colors.length) demodulator_color_index=0;
	return(demodulator_colors[demodulator_color_index++]);
}

function demod_envelope_draw(range, from, to, color, line)
{  //                                               ____
	// Draws a standard filter envelope like this: _/    \_
   // Parameters are given in offset frequency (Hz).
   // Envelope is drawn on the scale canvas.
	// A "drag range" object is returned, containing information about the draggable areas of the envelope
	// (beginning, ending and the line showing the offset frequency).
	if (isUndefined(color)) color="#ffff00"; //yellow
	
	env_bounding_line_w=5;   //    
	env_att_w=5;             //     _______   ___env_h2 in px   ___|_____
	env_h1=17;               //   _/|      \_ ___env_h1 in px _/   |_    \_
	env_h2=5;                //   |||env_att_w                     |_env_lineplus
	env_lineplus=1;          //   ||env_bounding_line_w
	env_line_click_area=8;
	env_slop=5;
	
	//range=get_visible_freq_range();
	from_px = scale_px_from_freq(from,range);
	to_px = scale_px_from_freq(to,range);
	if (to_px < from_px) /* swap'em */ { temp_px=to_px; to_px=from_px; from_px=temp_px; }
	
	pb_adj_cf.style.left = (from_px) +'px';
	pb_adj_cf.style.width = (to_px-from_px) +'px';

	pb_adj_lo.style.left = (from_px-env_bounding_line_w-2*env_slop) +'px';
	pb_adj_lo.style.width = (env_bounding_line_w+env_att_w+2*env_slop) +'px';

	pb_adj_hi.style.left = (to_px-env_bounding_line_w) +'px';
	pb_adj_hi.style.width = (env_bounding_line_w+env_att_w+2*env_slop) +'px';
	
	/*from_px-=env_bounding_line_w/2;
	to_px += env_bounding_line_w/2;*/
	from_px -= (env_att_w+env_bounding_line_w);
	to_px += (env_att_w+env_bounding_line_w);
	
	// do drawing:
	scale_ctx.lineWidth = 3;
	scale_ctx.strokeStyle = color;
	scale_ctx.fillStyle = color;
	var drag_ranges = { envelope_on_screen: false, line_on_screen: false };
	
	if (!(to_px<0 || from_px>window.innerWidth)) // out of screen?
	{
		drag_ranges.beginning={x1:from_px, x2: from_px+env_bounding_line_w+env_att_w+env_slop};
		drag_ranges.ending={x1:to_px-env_bounding_line_w-env_att_w-env_slop, x2: to_px};
		drag_ranges.whole_envelope={x1:from_px, x2: to_px};
		drag_ranges.envelope_on_screen=true;
		
		scale_ctx.beginPath();
		scale_ctx.moveTo(from_px,env_h1);
		scale_ctx.lineTo(from_px+env_bounding_line_w, env_h1);
		scale_ctx.lineTo(from_px+env_bounding_line_w+env_att_w, env_h2);
		scale_ctx.lineTo(to_px-env_bounding_line_w-env_att_w, env_h2);
		scale_ctx.lineTo(to_px-env_bounding_line_w, env_h1);
		scale_ctx.lineTo(to_px, env_h1);
		scale_ctx.globalAlpha = 0.3;
		scale_ctx.fill();
		scale_ctx.globalAlpha = 1;
		scale_ctx.stroke();
	}
	
	if (isDefined(line)) // out of screen? 
	{
		line_px = scale_px_from_freq(line,range);
		if (!(line_px<0 || line_px>window.innerWidth))
		{
			drag_ranges.line={x1:line_px-env_line_click_area/2, x2: line_px+env_line_click_area/2};
			drag_ranges.line_on_screen=true;
			scale_ctx.moveTo(line_px,env_h1+env_lineplus);
			scale_ctx.lineTo(line_px,env_h2-env_lineplus);
			scale_ctx.stroke();

			pb_adj_car.style.left = drag_ranges.line.x1 +'px';
			pb_adj_car.style.width = env_line_click_area +'px';

		}
	}
	return drag_ranges;
}

function demod_envelope_where_clicked(x, drag_ranges, key_modifiers)
{
	// Check exactly what the user has clicked based on ranges returned by demod_envelope_draw().
	in_range = function(x, g_range) { return g_range.x1 <= x && g_range.x2 >= x; }
	dr = demodulator.draggable_ranges;
	//console.log('demod_envelope_where_clicked x='+ x);
	//console.log(drag_ranges);
	//console.log(key_modifiers);

	if (key_modifiers.shiftKey)
	{
		//Check first: shift + center drag emulates BFO knob
		if (drag_ranges.line_on_screen && in_range(x,drag_ranges.line)) return dr.bfo;
		
		//Check second: shift + envelope drag emulates PBS knob
		if (drag_ranges.envelope_on_screen && in_range(x,drag_ranges.whole_envelope)) return dr.pbs;
	}
	
	if (key_modifiers.altKey)
	{
		if (drag_ranges.envelope_on_screen && in_range(x,drag_ranges.beginning)) return dr.bwlo;
		if (drag_ranges.envelope_on_screen && in_range(x,drag_ranges.ending)) return dr.bwhi;
	}
	
	if (drag_ranges.envelope_on_screen)
	{ 
		// For low and high cut:
		if (in_range(x,drag_ranges.beginning)) return dr.beginning;
		if (in_range(x,drag_ranges.ending)) return dr.ending;
		// Last priority: having clicked anything else on the envelope, without holding the shift key
		if (in_range(x,drag_ranges.whole_envelope)) return dr.anything_else; 
	}
	return dr.none; //User doesn't drag the envelope for this demodulator
}

//******* class demodulator *******
// this can be used as a base class for ANY demodulator
demodulator = function(offset_frequency)
{
	//console.log("this too");
	this.offset_frequency = offset_frequency;
	this.has_audio_output = true;
	this.has_text_output = false;
	this.envelope = {};
	this.color = demodulators_get_next_color();
	this.stop = function(){};
}

//ranges on filter envelope that can be dragged:
demodulator.draggable_ranges = {
	none: 0,
	beginning: 1,	// from
	ending: 2,		// to
	anything_else: 3,
	bfo: 4,			// line (while holding shift)
	pbs: 5,			// passband (while holding shift)
	bwlo: 6,			// bandwidth (while holding alt in envelope beginning)
	bwhi: 7,			// bandwidth (while holding alt in envelope ending)
} //to which parameter these correspond in demod_envelope_draw()

//******* class demodulator_default_analog *******
// This can be used as a base for basic audio demodulators.
// It already supports most basic modulations used for ham radio and commercial services: AM/FM/LSB/USB

demodulator_response_time=100; 
//in ms; if we don't limit the number of SETs sent to the server, audio will underrun (possibly output buffer is cleared on SETs in GNU Radio

var passbands = {
	am:		{ lo: -4900,	hi:  4900 },            // 9.8 kHz instead of 10 to avoid adjacent channel heterodynes in SW BCBs
	amn:		{ lo: -2500,	hi:  2500 },
	sam:		{ lo: -4900,	hi:  4900 },
	sal:		{ lo: -4900,	hi:     0 },
	sau:		{ lo:     0,	hi:  4900 },
	sas:		{ lo: -4900,	hi:  4900 },
	drm:		{ lo: -5000,	hi:  5000 },
	lsb:		{ lo: -2700,	hi:  -300 },	         // cf = 1500 Hz, bw = 2400 Hz
	lsn:		{ lo: -2400,	hi:  -300 },	         // cf = 1350 Hz, bw = 2100 Hz
	usb:		{ lo:   300,	hi:  2700 },	         // cf = 1500 Hz, bw = 2400 Hz
	usn:		{ lo:   300,	hi:  2400 },	         // cf = 1350 Hz, bw = 2100 Hz
	cw:		{ lo:   300,	hi:   700,  pbw: 400 },	// cf = 500 Hz, bw = 400 Hz
	cwn:		{ lo:   470,	hi:   530,  pbw:  60 },	// cf = 500 Hz, bw = 60 Hz
	nbfm:		{ lo: -6000,	hi:  6000 },	         // FIXME: set based on current srate?
	iq:		{ lo: -5000,	hi:  5000 },
};

function demodulator_default_analog(offset_frequency, subtype, locut, hicut)
{
   if (passbands[subtype] == null) subtype = 'am';
   //console.log('demodulator_default_analog '+ subtype +' locut='+ locut +' hicut='+ hicut);
   
	//http://stackoverflow.com/questions/4152931/javascript-inheritance-call-super-constructor-or-use-prototype-chain
	demodulator.call(this, offset_frequency);

	this.subtype = subtype;
	this.envelope.dragged_range = demodulator.draggable_ranges.none;
	var sampleRateDiv2 = audio_input_rate? audio_input_rate/2 : 5000;
	this.filter = {
		min_passband: 4,
		high_cut_limit: sampleRateDiv2,
		low_cut_limit: -sampleRateDiv2
	};

	//Subtypes only define some filter parameters and the mod string sent to server, 
	//so you may set these parameters in your custom child class.
	//Why? As the demodulation is done on the server, difference is mainly on the server side.
	this.server_mode = subtype;

//jks
//if (!isNaN(locut)) { console.log('#### demodulator_default_analog locut='+ locut); kiwi_trace(); }
//if (!isNaN(hicut)) { console.log('#### demodulator_default_analog hicut='+ hicut); kiwi_trace(); }
	var lo = isNaN(locut)? passbands[subtype].last_lo : locut;
	var hi = isNaN(hicut)? passbands[subtype].last_hi : hicut;
	if (lo == 'undefined' || lo == null) {
		lo = passbands[subtype].last_lo = passbands[subtype].lo;
	}
	if (hi == 'undefined' || hi == null) {
		hi = passbands[subtype].last_hi = passbands[subtype].hi;
	}
	
	if (override_pbw != '') {
	   var center = lo + (hi-lo)/2;
	   var min = this.filter.min_passband;
	   //console.log('### override_pbw cur_lo='+ lo +' cur_hi='+ hi +' cur_center='+ center +' min='+ min);
	   override_pbw = decodeURIComponent(override_pbw);
	   var p = override_pbw.split(',');
	   console.log('p.len='+ p.length);
	   var nlo = p[0].parseFloatWithUnits('k');
      console.log('nlo="'+ p[0] +'" '+ nlo);
	   var nhi = NaN;
	   if (p.length > 1) {
	      nhi = p[1].parseFloatWithUnits('k');
         console.log('nhi="'+ p[1] +'" '+ nlo);
      }
	   
	   // adjust passband width about current pb center
	   if (p.length == 1 && !isNaN(nlo) && nlo >= min) {
	      // /pbw
         lo = center - nlo/2;
         hi = center + nlo/2;
	   } else
	   if (p.length == 2 && !isNaN(nlo) && !isNaN(nhi) && nlo < nhi && (nhi - nlo) >= min) {
	      // /pbl,pbh
	      lo = nlo;
	      hi = nhi;
	   }
	   //console.log('### override_pbw=['+ override_pbw +'] len='+ p.length +' nlo='+ nlo +' nhi='+ nhi +' lo='+ lo +' hi='+ hi);

	   override_pbw = '';
	   extint.override_pb = true;
	}
	
	if (override_pbc != '') {
	   var cpbhw = (hi - lo)/2;
	   var cpbc = lo + cpbhw;
	   var min = this.filter.min_passband;
	   //console.log('### override_pbc cur_lo='+ lo +' cur_hi='+ hi +' cpbc='+ cpbc +' cpbhw='+ cpbhw +' min='+ min);
	   override_pbc = decodeURIComponent(override_pbc);
	   var p = override_pbc.split(',');
	   var pbc = p[0].parseFloatWithUnits('k');
      console.log('pbc="'+ p[0] +'" '+ nlo);
	   var pbw = NaN;
	   if (p.length > 1) {
	      pbw = p[1].parseFloatWithUnits('k');
         console.log('pbw="'+ p[1] +'" '+ nlo);
      }
	   
      // adjust passband center using current or specified pb width
	   if (p.length == 1 && !isNaN(pbc)) {
	      // :pbc
         lo = pbc - cpbhw;
         hi = pbc + cpbhw;
	   } else
	   if (p.length == 2 && !isNaN(pbc) && !isNaN(pbw) && pbw >= min) {
	      // :pbc,pbw
         lo = pbc - pbw/2;
         hi = pbc + pbw/2;
	   }
	   //console.log('### override_pbc=['+ override_pbc +'] len='+ p.length +' pbc='+ pbc +' pbw='+ pbw +' lo='+ lo +' hi='+ hi);

	   override_pbc = '';
	   extint.override_pb = true;
	}
	
	this.low_cut = Math.max(lo, this.filter.low_cut_limit);
	this.high_cut = Math.min(hi, this.filter.high_cut_limit);
	//console.log('DEMOD set subtype='+ subtype +' lo='+ this.low_cut, ' hi='+ this.high_cut);
	
	this.usePBCenter = false;
	this.isCW = false;
	
	switch (subtype) {
	
	   case 'am':
	   case 'amn':
	   case 'sam':
	   case 'sal':
	   case 'sau':
	   case 'sas':
	   case 'drm':
	   case 'nbfm':
	   case 'iq':
		   break;
		   
	   case 'lsb':
	   case 'lsn':
	   case 'usb':
	   case 'usn':
		   this.usePBCenter = true;
		   break;

	   case 'cw':
	   case 'cwn':
		   this.usePBCenter = true;
		   this.isCW = true;
		   break;
		   
		default:
		   console.log('DEMOD-new: unknown subtype='+ subtype);
		   break;
	}

	this.wait_for_timer = false;
	this.set_after = false;

	// set() is a wrapper to call doset(), but it ensures that doset won't execute more frequently than demodulator_response_time.
	this.set = function() {

		if (!this.wait_for_timer) {
			this.doset();
			this.set_after = false;
			this.wait_for_timer = true;
			timeout_this = this; //http://stackoverflow.com/a/2130411
			window.setTimeout(function() {
				timeout_this.wait_for_timer = false;
				if (timeout_this.set_after) timeout_this.set();
			}, demodulator_response_time);
		} else {
			this.set_after = true;
		}
	}

	// this function sends demodulator parameters to the server
	this.doset = function() {
		//console.log('DOSET fcar='+freq_car_Hz);
		//if (dbgUs && dbgUsFirst) { dbgUsFirst = false; console.trace(); }
		
		var freq = (freq_car_Hz/1000).toFixed(3);
		var mode = this.server_mode;
		var locut = this.low_cut.toString();
		var hicut = this.high_cut.toString()
		//console.log('SET mod='+ mode +' low_cut='+ locut +' high_cut='+ hicut +' freq='+ freq);
		snd_send('SET mod='+ mode +' low_cut='+ locut +' high_cut='+ hicut +' freq='+ freq);

      var changed = null;
      if (freq != owrx.last_freq) {
         changed = changed || {};
         changed.freq = 1;
         owrx.last_freq = freq;
      }
      if (mode != owrx.last_mode) {
         changed = changed || {};
         changed.mode = 1;
         owrx.last_mode = mode;
      }
      if (locut != owrx.last_locut || hicut != owrx.last_hicut) {
         changed = changed || {};
         changed.passband = 1;
         owrx.last_locut = locut; owrx.last_hicut = hicut;
      }
      if (changed != null) extint_environment_changed(changed);

		if (muted_until_freq_set) {
		   toggle_or_set_mute(muted_initially);
		   muted_until_freq_set = false;
		}
		
		if (audio_meas_dly_ena) {
		   //console.log('audio_meas_dly_start');
		   audio_meas_dly_start = (new Date()).getTime();
		}
	}
	// this.set(); //we set parameters on object creation

	//******* envelope object *******
   // for drawing the filter envelope above scale
	this.envelope.parent = this;

	this.envelope.draw = function(visible_range) 
	{
		this.visible_range = visible_range;
		this.drag_ranges = demod_envelope_draw(g_range,
				center_freq + this.parent.offset_frequency + this.parent.low_cut,
				center_freq + this.parent.offset_frequency + this.parent.high_cut,
				this.color,
				center_freq + this.parent.offset_frequency);
		var bw = Math.abs(this.parent.high_cut - this.parent.low_cut);
		pb_adj_lo_ttip.innerHTML = 'lo '+ this.parent.low_cut.toString() +', bw '+ bw.toString();
		pb_adj_hi_ttip.innerHTML = 'hi '+ this.parent.high_cut.toString() +', bw '+ bw.toString();
		pb_adj_cf_ttip.innerHTML = 'cf '+ (this.parent.low_cut + Math.abs(this.parent.high_cut - this.parent.low_cut)/2).toString();
		pb_adj_car_ttip.innerHTML = ((center_freq + this.parent.offset_frequency)/1000 + cfg.freq_offset).toFixed(2) +' kHz';
	};

	// event handlers
	this.envelope.drag_start = function(x, key_modifiers)
	{
		this.key_modifiers = key_modifiers;
		this.dragged_range = demod_envelope_where_clicked(x, this.drag_ranges, key_modifiers);
		//console.log("DRAG-START dr="+ this.dragged_range.toString());
		this.drag_origin={
			x: x,
			low_cut: this.parent.low_cut,
			high_cut: this.parent.high_cut,
			offset_frequency: this.parent.offset_frequency
		};
		return this.dragged_range != demodulator.draggable_ranges.none;
	};

	this.envelope.drag_move = function(x)
	{
		var dr = demodulator.draggable_ranges;
		if (this.dragged_range == dr.none) {
			//console.log('move none');
			return false; // we return if user is not dragging (us) at all
		}

		freq_change = Math.round(this.visible_range.hpp * (x-this.drag_origin.x));
		//console.log('DRAG fch='+ freq_change +' dr='+ this.dragged_range);

		var is_adj_BFO = this.dragged_range == dr.bfo;
		var is_adj_locut = this.dragged_range == dr.beginning;
		var is_adj_hicut = this.dragged_range == dr.ending;
		var is_adj_bwlo = this.dragged_range == dr.bwlo;
		var is_adj_bwhi = this.dragged_range == dr.bwhi;
		var is_BFO_PBS_BW = is_adj_BFO || this.dragged_range == dr.pbs || is_adj_bwlo || is_adj_bwhi;

		//dragging the line in the middle of the filter envelope while holding Shift does emulate
		//the BFO knob on radio equipment: moving offset frequency, while passband remains unchanged
		//Filter passband moves in the opposite direction than dragged, hence the minus below.
		var minus_lo = (is_adj_BFO || is_adj_bwhi)? -1:1;
		var minus_hi = (is_adj_BFO || is_adj_bwlo)? -1:1;

		//dragging any other parts of the filter envelope while holding Shift does emulate the PBS knob
		//(PassBand Shift) on radio equipment: PBS does move the whole passband without moving the offset
		//frequency.
		
		// calculate the proposed changes: both lo and hi can change if shifting passband
		var new_lo = this.drag_origin.low_cut;
		var do_lo = is_adj_locut || is_BFO_PBS_BW;
		if (do_lo) new_lo += minus_lo*freq_change;

		var new_hi = this.drag_origin.high_cut;
		var do_hi = is_adj_hicut || is_BFO_PBS_BW;
		if (do_hi) new_hi += minus_hi*freq_change;

		// validate the proposed changes
		if (do_lo) {
			//we don't let low_cut go beyond its limits
			if (new_lo < this.parent.filter.low_cut_limit) {
				//console.log('lo limit');
				return true;
			}
			//nor the filter passband be too small
			if (new_hi - new_lo < this.parent.filter.min_passband) {
				//console.log('lo min');
				return true;
			}
			//sanity check to prevent GNU Radio "firdes check failed: fa <= fb"
			if (new_lo >= new_hi) {
				//console.log('lo wrap');
				return true;
			}
		}
		
		if (do_hi) {
			//we don't let high_cut go beyond its limits
			if (new_hi > this.parent.filter.high_cut_limit) {
				//console.log('hi limit');
				return true;
			}
			//nor the filter passband be too small
			if (new_hi - new_lo < this.parent.filter.min_passband) {
				//console.log('hi min');
				return true;
			}
			//sanity check to prevent GNU Radio "firdes check failed: fa <= fb"
			if (new_hi <= new_lo) {
				//console.log('hi wrap');
				return true;
			}
		}
		
		// make the proposed changes
		if (do_lo) {
			passbands[this.parent.server_mode].last_lo = this.parent.low_cut = new_lo;
			//console.log('DRAG-MOVE lo=', new_lo.toFixed(0));
		}
		
		if (do_hi) {
			passbands[this.parent.server_mode].last_hi = this.parent.high_cut = new_hi;
			//console.log('DRAG-MOVE hi=', new_hi.toFixed(0));
		}
		
		if (this.dragged_range == dr.anything_else || is_adj_BFO) {
			//when any other part of the envelope is dragged, the offset frequency is changed (whole passband also moves with it)
			new_value = this.drag_origin.offset_frequency + freq_change;
			if (new_value > bandwidth/2 || new_value < -bandwidth/2) {
				//console.log('bfo range');
				return true; //we don't allow tuning above Nyquist frequency :-)
			}
			this.parent.offset_frequency = new_value;
			//console.log('DRAG-MOVE off=', new_value.toFixed(0));
		}
		
		//now do the actual modifications:
		mkenvelopes(this.visible_range);
		freqset_car_Hz(this.parent.offset_frequency + center_freq);
		this.parent.set();
		freqset_update_ui();

		//will have to change this when changing to multi-demodulator mode:
		//html("id-control-freq1").innerHTML=format_frequency("{x} MHz",center_freq+this.parent.offset_frequency,1e6,4);
		return true;
	};
	
	this.envelope.drag_end=function(x)
	{ //in this demodulator we've already changed values in the drag_move() function so we shouldn't do too much here.
		to_return = this.dragged_range != demodulator.draggable_ranges.none; //this part is required for cliking anywhere on the scale to set offset
		this.dragged_range = demodulator.draggable_ranges.none;
		return to_return;
	};
	
}

demodulator_default_analog.prototype = new demodulator();

function mkenvelopes(visible_range) //called from mkscale
{
	scale_ctx.clearRect(0,0,scale_ctx.canvas.width,22); //clear the upper part of the canvas (where filter envelopes reside)
	for (var i=0;i<demodulators.length;i++)
	{
		demodulators[i].envelope.draw(visible_range);
	}
}

function demodulator_remove(which)
{
	demodulators[which].stop();
	demodulators.splice(which,1);
}

function demodulator_add(what)
{
	demodulators.push(what);
	if (waterfall_setup_done) mkenvelopes(get_visible_freq_range());
}

function demodulator_analog_replace(subtype, freq)
{ //this function should only exist until the multi-demodulator capability is added
   //console.log('demodulator_analog_replace subtype='+ subtype);
   if (passbands[subtype] == null) subtype = 'am';

	var offset = 0, prev_pbo = 0, low_cut = NaN, high_cut = NaN;
	var wasCW = false, toCW = false, fromCW = false;
	
   w3_show_hide('id-sam-carrier-container', subtype.startsWith('sa'));

	if (demodulators.length) {
		wasCW = demodulators[0].isCW;
		offset = demodulators[0].offset_frequency;
		prev_pbo = passband_offset();
		demodulator_remove(0);
	} else {
		var i_freqHz = Math.round((init_frequency - cfg.freq_offset) * 1000);
      offset = (i_freqHz <= 0 || i_freqHz > bandwidth)? 0 : (i_freqHz - center_freq);
		//console.log('### init_freq='+ init_frequency +' cfg.freq_offset='+ cfg.freq_offset +' i_freqHz='+ i_freqHz +' offset='+ offset +' init_mode='+ init_mode);
		subtype = init_mode;
	}
	
	// initial offset, but doesn't consider demod.isCW since it isn't valid yet
	if (isArg(freq)) {
		offset = freq - center_freq;
	}
	
	//console.log("DEMOD-replace calling add: INITIAL offset="+(offset+center_freq));
	demodulator_add(new demodulator_default_analog(offset, subtype, low_cut, high_cut));
	
	if (!wasCW && demodulators[0].isCW)
		toCW = true;
	if (wasCW && !demodulators[0].isCW)
		fromCW = true;
	
	// determine actual offset now that demod.isCW is valid
	if (isArg(freq)) {
		freq_car_Hz = freq_dsp_to_car(freq);
		//console.log('DEMOD-replace SPECIFIED freq='+ freq +' car='+ freq_car_Hz);
		offset = freq_car_Hz - center_freq;
		wf.audioFFT_clear_wf = true;
	} else {
		// Freq not changing, just mode. Do correct thing for switch to/from cw modes: keep display freq constant
		var pbo = 0;
		if (toCW) pbo = -passband_offset();
		if (fromCW) pbo = prev_pbo;	// passband offset calculated _before_ demod was changed
		offset += pbo;
		
		// clear switching to/from cw mode because of frequency offset
		if (toCW || fromCW)
		   wf.audioFFT_clear_wf = true;
		//console.log('DEMOD-replace SAME freq='+ (offset + center_freq) +' PBO='+ pbo +' prev='+ prev_pbo +' toCW='+ toCW +' fromCW='+ fromCW);
	}

   if (cur_mode != 'drm')
      extint.prev_mode = cur_mode;
	cur_mode = subtype;
	//console.log("demodulator_analog_replace: cur_mode="+ cur_mode);

	// must be done here after demod is added, so demod.isCW is available after demodulator_add()
	// done even if freq unchanged in case mode is changing
	//console.log("DEMOD-replace calling set: FINAL freq="+ (offset + center_freq));
	demodulator_set_offset_frequency(0, offset);
	
	try_modeset_update_ui(subtype);
}

function demodulator_set_offset_frequency(which, offset)
{
	if (offset > bandwidth/2 || offset < -bandwidth/2) return;
	offset = Math.round(offset);
	//console.log("demodulator_set_offset_frequency: offset="+(offset + center_freq));
	
	// set carrier freq before demodulators[0].set() below
	// requires demodulators[0].isCW to be valid
	freqset_car_Hz(offset + center_freq);
	
	var demod = demodulators[0];
	demod.offset_frequency = offset;
	demod.set();
	try_freqset_update_ui();
}

function owrx_cfg()
{
   var cw = passbands.cw;
   cw.lo = cfg.init.cw_offset - cw.pbw/2;
   cw.hi = cfg.init.cw_offset + cw.pbw/2;
   var cwn = passbands.cwn;
   cwn.lo = cfg.init.cw_offset - cwn.pbw/2;
   cwn.hi = cfg.init.cw_offset + cwn.pbw/2;
}


////////////////////////////////
// scale
////////////////////////////////

var scale_ctx, band_ctx, dx_ctx;
var pb_adj_cf, pb_adj_cf_ttip, pb_adj_lo, pb_adj_lo_ttip, pb_adj_hi, pb_adj_hi_ttip, pb_adj_car, pb_adj_car_ttip;
var scale_canvas, band_canvas, dx_div, dx_canvas;

function scale_setup()
{
	w3_el('id-scale-container').addEventListener("mouseout", scale_container_mouseout, false);
   
	scale_canvas = html("id-scale-canvas");	
	scale_ctx = scale_canvas.getContext("2d");
	add_scale_listner(scale_canvas);

	pb_adj_car = html("id-pb-adj-car");
	pb_adj_car.innerHTML = '<span id="id-pb-adj-car-ttip" class="class-passband-adjust-car-tooltip class-tooltip-text"></span>';
	pb_adj_car_ttip = html("id-pb-adj-car-ttip");
	add_scale_listner(pb_adj_car);

	pb_adj_lo = html("id-pb-adj-lo");
	pb_adj_lo.innerHTML = '<span id="id-pb-adj-lo-ttip" class="class-passband-adjust-cut-tooltip class-tooltip-text"></span>';
	pb_adj_lo_ttip = html("id-pb-adj-lo-ttip");
	add_scale_listner(pb_adj_lo);

	pb_adj_hi = html("id-pb-adj-hi");
	pb_adj_hi.innerHTML = '<span id="id-pb-adj-hi-ttip" class="class-passband-adjust-cut-tooltip class-tooltip-text"></span>';
	pb_adj_hi_ttip = html("id-pb-adj-hi-ttip");
	add_scale_listner(pb_adj_hi);

	pb_adj_cf = html("id-pb-adj-cf");
	pb_adj_cf.innerHTML = '<span id="id-pb-adj-cf-ttip" class="class-passband-adjust-cf-tooltip class-tooltip-text"></span>';
	pb_adj_cf_ttip = html("id-pb-adj-cf-ttip");
	add_scale_listner(pb_adj_cf);

	band_canvas = html("id-band-canvas");	
	band_ctx = band_canvas.getContext("2d");
	add_canvas_listner(band_canvas);
	
	dx_div = html('id-dx-container');
	add_canvas_listner(dx_div);

	dx_canvas = html("id-dx-canvas");	
	dx_ctx = dx_canvas.getContext("2d");
	add_canvas_listner(dx_canvas);
	
	resize_scale('setup');
}

function add_scale_listner(obj)
{
	obj.addEventListener("mousedown", scale_canvas_mousedown, false);
	obj.addEventListener("mousemove", scale_canvas_mousemove, false);
	obj.addEventListener("mouseup", scale_canvas_mouseup, false);
	obj.addEventListener("contextmenu", scale_canvas_contextmenu, false);

	if (kiwi_isMobile()) {
		obj.addEventListener('touchstart', scale_canvas_touchStart, false);
		obj.addEventListener('touchmove', scale_canvas_touchMove, false);
		obj.addEventListener('touchend', scale_canvas_touchEnd, false);
	}
}

function scale_canvas_contextmenu(evt)
{
	//console.log('## SCMENU tgt='+ evt.target.id +' Ctgt='+ evt.currentTarget.id);
	return cancelEvent(evt);
}

var scale_canvas_drag_params = {
	mouse_down: false,
	drag: false,
	start_x: 0,
	last_x: 0,
	start_y: 0,
	last_y: 0,
	key_modifiers: { shiftKey:false, altKey: false, ctrlKey: false }
};

function scale_canvas_mousedown(evt)
{
	//event_dump(evt, 'SC-MDN', 1);
	with (scale_canvas_drag_params) {
		drag = false;
		start_x = evt.pageX;
		start_y = evt.pageY;
		key_modifiers.shiftKey = evt.shiftKey;
		key_modifiers.altKey = evt.altKey;
		key_modifiers.ctrlKey = evt.ctrlKey;
	}
	scale_canvas_start_drag(evt, 1);
	evt.preventDefault();
}

function scale_canvas_touchStart(evt)
{
   if (evt.targetTouches.length == 1) {
		with (scale_canvas_drag_params) {
			drag = false;
			last_x = start_x = evt.targetTouches[0].pageX;
			last_y = start_y = evt.targetTouches[0].pageY;
			key_modifiers.shiftKey = false;
			key_modifiers.altKey = false;
			key_modifiers.ctrlKey = false;
		}
	   scale_canvas_start_drag(evt, 0);
	}
	evt.preventDefault();
}

var scale_canvas_ignore_mouse_event = false;

function scale_canvas_start_drag(evt, isMouse)
{
	// Distinguish ctrl-click right-button meta event from actual right-button on mouse (or touchpad two-finger tap).
	if (evt.button == mouse.right && !evt.ctrlKey) {
		//dump_event = true;
		right_click_menu(scale_canvas_drag_params.start_x, scale_canvas_drag_params.start_y);
      scale_canvas_drag_params.mouse_down = false;
		scale_canvas_ignore_mouse_event = true;
		return;
	}

   scale_canvas_drag_params.mouse_down = true;
   if (isMouse) scale_canvas_mousemove(evt);
}

function scale_offset_carfreq_from_px(x, visible_range)
{
	if (isUndefined(visible_range)) visible_range = get_visible_freq_range();
	var offset = passband_offset();
	var f = visible_range.start + visible_range.bw*(x/canvas_container.clientWidth);
	//console.log("SOCFFPX f="+f+" off="+offset+" f-o="+(f-offset)+" rtn="+(f - center_freq - offset));
	return f - center_freq - offset;
}

function scale_canvas_drag(evt, x)
{
   if (scale_canvas_ignore_mouse_event) return;
   
	//event_dump(evt, 'SC-MDRAG', 1);
	var event_handled = 0;
	var relX = Math.abs(x - scale_canvas_drag_params.start_x);

	if (scale_canvas_drag_params.mouse_down && !scale_canvas_drag_params.drag /* && relX > canvas_drag_min_delta */ ) {
		//we can use the main drag_min_delta thing of the main canvas
		scale_canvas_drag_params.drag = true;
		//call the drag_start for all demodulators (and they will decide if they're dragged, based on X coordinate)
		for (var i=0; i<demodulators.length; i++)
			event_handled |= demodulators[i].envelope.drag_start(x, scale_canvas_drag_params.key_modifiers);
		//console.log("MOV1 evh? "+event_handled);
		evt.target.style.cursor = "move";
		//console.log('sc cursor');
	//} else
	}     // scale is different from waterfall: mousedown alone immediately changes frequency

	if (scale_canvas_drag_params.drag) {
		//call the drag_move for all demodulators (and they will decide if they're dragged)
		for (var i=0; i<demodulators.length; i++)
			event_handled |= demodulators[i].envelope.drag_move(x);
		//console.log("MOV2 evh? "+event_handled);
		if (!event_handled)
			demodulator_set_offset_frequency(0, scale_offset_carfreq_from_px(x));
		scale_canvas_drag_params.last_x = x;
	}
}

function scale_canvas_mousemove(evt)
{
	//event_dump(evt, 'SC-MM', 1);
	scale_canvas_drag(evt, evt.pageX);
}

function scale_canvas_touchMove(evt)
{
	for (var i=0; i < evt.touches.length; i++) {
		scale_canvas_drag(evt, evt.touches[i].pageX);
	}
	evt.preventDefault();
}

function scale_canvas_end_drag(evt, x)
{
   if (scale_canvas_ignore_mouse_event) {
      scale_canvas_ignore_mouse_event = false;
      return;
   }

	scale_canvas_drag_params.drag = false;
	var event_handled = false;
	
	if (scale_canvas_drag_params.mouse_down == true) {
      for (var i=0; i<demodulators.length; i++) event_handled |= demodulators[i].envelope.drag_end(x);
      //console.log("MED evh? "+event_handled);
      if (!event_handled) demodulator_set_offset_frequency(0, scale_offset_carfreq_from_px(x));
   }

	scale_canvas_drag_params.mouse_down = false;
	evt.target.style.cursor = null;		// re-enable default mouseover cursor in .css (if any)
}

function scale_canvas_mouseup(evt)
{
	//event_dump(evt, 'SC-MUP', 1);
	scale_canvas_end_drag(evt, evt.pageX);
}

function scale_canvas_touchEnd(evt)
{
	scale_canvas_end_drag(evt, scale_canvas_drag_params.last_x);
	evt.preventDefault();
}

// When mouseup occurs outside our original canvas scale_canvas_mouseup() doesn't occur terminating the drag.
// So have to detect canvas crossing and terminate that way.
function scale_container_mouseout(evt)
{
   // Prevent mouseout generated from mouseover of passband elements from prematurely ending drag.
   // Can't use "pb_el.style.pointerEvents = 'none'" trick because that disables pb tooltip.
   var trel = evt.relatedTarget;
   trel = (isObject(trel) && trel != null && isDefined(trel.id))? trel.id : null;
   if (trel && (trel.startsWith('id-pb-adj') || trel.startsWith('id-scale'))) return;
   scale_canvas_mouseup(evt);
}

function scale_px_from_freq(f,range) { return Math.round(((f-range.start)/range.bw)*canvas_container.clientWidth); }

function get_visible_freq_range()
{
	out={};
	
	if (wf.audioFFT_active && cur_mode != undefined) {
	   var off, span;
      var srate = Math.round(audio_input_rate || 12000);
	   if (cur_mode == 'iq' || cur_mode == 'drm') {
	      off = 0;
	      span = srate;
	   } else {
	      off = srate/4;
	      span = srate/2;
	   }
      out.center = center_freq + demodulators[0].offset_frequency + off;
      out.start = out.center - span;
      out.end = out.center + span;
      x_bin = freq_to_bin(out.start);
      out.bw = out.end-out.start;
      out.hpp = out.bw / scale_canvas.clientWidth;
	   //console.log('GVFR'+ (wf.audioFFT_active? '(audioFFT)':'') +" mode="+cur_mode+" xb="+x_bin+" s="+out.start+" c="+out.center+" e="+out.end+" bw="+out.bw+" hpp="+out.hpp+" cw="+scale_canvas.clientWidth);
	} else {
	   var bins = bins_at_cur_zoom();
      out.start = bin_to_freq(x_bin);
      out.center = bin_to_freq(x_bin + bins/2);
      out.end = bin_to_freq(x_bin + bins);
      out.bw = out.end-out.start;
      out.hpp = out.bw / scale_canvas.clientWidth;
	   //console.log("GVFR z="+zoom_level+" xb="+x_bin+" BACZ="+bins+" s="+out.start+" c="+out.center+" e="+out.end+" bw="+out.bw+" hpp="+out.hpp+" cw="+scale_canvas.clientWidth);
	}
	return out;
}

var scale_markers_levels = [
	{
		"hz_per_large_marker":10000000, //large
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":5000000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":1000000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":500000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":1
	},
	{
		"hz_per_large_marker":100000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":1
	},
	{
		"hz_per_large_marker":50000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":2
	},
	{
		"hz_per_large_marker":10000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":2
	},
	{
		"hz_per_large_marker":5000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":3
	},
	{
		"hz_per_large_marker":1000,
		"estimated_text_width":70,
		"format":"{x} ",
		"pre_divide":1000000,
		"decimals":3
	}
];

/*
var scale_markers_levels = [
	{
		"hz_per_large_marker":10000000, //large
		"estimated_text_width":70,
		"format":"{x}a ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":5000000,
		"estimated_text_width":70,
		"format":"{x}b ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":1000000,
		"estimated_text_width":70,
		"format":"{x}c ",
		"pre_divide":1000000,
		"decimals":0
	},
	{
		"hz_per_large_marker":500000,
		"estimated_text_width":70,
		"format":"{x}d ",
		"pre_divide":1000000,
		"decimals":1
	},
	{
		"hz_per_large_marker":100000,
		"estimated_text_width":70,
		"format":"{x}e ",
		"pre_divide":1000000,
		"decimals":1
	},
	{
		"hz_per_large_marker":50000,
		"estimated_text_width":70,
		"format":"{x}f ",
		"pre_divide":1000000,
		"decimals":2
	},
	{
		"hz_per_large_marker":10000,
		"estimated_text_width":70,
		"format":"{x}g ",
		"pre_divide":1000000,
		"decimals":2
	},
	{
		"hz_per_large_marker":5000,
		"estimated_text_width":70,
		"format":"{x}h ",
		"pre_divide":1000000,
		"decimals":3
	},
	{
		"hz_per_large_marker":1000,
		"estimated_text_width":70,
		"format":"{x}i ",
		"pre_divide":1000000,
		"decimals":3
	}
];
*/

var scale_min_space_btwn_texts = 50;
var scale_min_space_btwn_small_markers = 7;

function get_scale_mark_spacing(range)
{
	out = {};
	fcalc = function(mkr_spacing) { 
		out.numlarge = (range.bw/mkr_spacing);
		out.pxlarge = canvas_container.clientWidth/out.numlarge; 	//distance between large markers (these have text)
		out.ratio = 5; 															//(ratio-1) small markers exist per large marker
		out.pxsmall = out.pxlarge/out.ratio; 								//distance between small markers
		if (out.pxsmall < scale_min_space_btwn_small_markers) return false; 
		if (out.pxsmall/2 >= scale_min_space_btwn_small_markers && mkr_spacing.toString()[0] != "5") { out.pxsmall/=2; out.ratio*=2; }
		out.smallbw = mkr_spacing/out.ratio;
		return true;
	}
	
	for (var i=scale_markers_levels.length-1; i>=0; i--) {
		mp = scale_markers_levels[i];
		if (!fcalc(mp.hz_per_large_marker)) continue;
		//console.log(mp.hz_per_large_marker);
		//console.log(out);
		if (out.pxlarge-mp.estimated_text_width > scale_min_space_btwn_texts) break;
	}
	
	//console.log("using");
	//console.log(canvas_container);
	//console.log(range);
	//console.log(mp);
	//console.log(out);
	out.params = mp;
	return out;
}

var g_range;

function mk_freq_scale()
{
	//clear the lower part of the canvas (where frequency scale resides; the upper part is used by filter envelopes):
	g_range = get_visible_freq_range();
	mkenvelopes(g_range); //when scale changes we will always have to redraw filter envelopes, too

	scale_ctx.clearRect(0,22,scale_ctx.canvas.width,scale_ctx.canvas.height-22);
	scale_ctx.strokeStyle = "#fff";
	scale_ctx.font = "bold 12px sans-serif";
	scale_ctx.textBaseline = "top";
	scale_ctx.fillStyle = "#fff";
	
	var spacing = get_scale_mark_spacing(g_range);
	//console.log(spacing);
	marker_hz = Math.ceil(g_range.start/spacing.smallbw) * spacing.smallbw;
	text_y_pos = 22+10 + (kiwi_isFirefox()? 3:0);
	var text_to_draw;
	
	var ftext = function(f) {
		var pre_divide = spacing.params.pre_divide;
		var decimals = spacing.params.decimals;
		f += cfg.freq_offset*1e3;
		if (f < 1e6) {
			pre_divide /= 1000;
			decimals = 0;
		}
		text_to_draw = format_frequency(spacing.params.format+((f < 1e6)? 'kHz':'MHz'), f, pre_divide, decimals);
	}
	
	var last_large;
   var conv_ct=0;

	for (;;) {
      conv_ct++;
      if (conv_ct > 1000) break;
		var x = scale_px_from_freq(marker_hz,g_range);
		if (x > window.innerWidth) break;
		scale_ctx.beginPath();		
		scale_ctx.moveTo(x, 22);

		if (marker_hz % spacing.params.hz_per_large_marker == 0) {

			//large marker
			if (isUndefined(first_large)) var first_large = marker_hz; 
			last_large = marker_hz;
			scale_ctx.lineWidth = 3.5;
			scale_ctx.lineTo(x,22+11);
			ftext(marker_hz);
			var text_measured = scale_ctx.measureText(text_to_draw);
			scale_ctx.textAlign = "center";

			//advanced text drawing begins
			//console.log('text_to_draw='+ text_to_draw);
			if (zoom_level==0 && g_range.start+spacing.smallbw*spacing.ratio > marker_hz) {

				//if this is the first overall marker when zoomed all the way out
				//console.log('case 1');
				if (x < text_measured.width/2) {
				   //and if it would be clipped off the screen
					if (scale_px_from_freq(marker_hz+spacing.smallbw*spacing.ratio,g_range)-text_measured.width >= scale_min_space_btwn_texts) {
					   //and if we have enough space to draw it correctly without clipping
						scale_ctx.textAlign = "left";
						scale_ctx.fillText(text_to_draw, 0, text_y_pos); 
					}
				}
			} else
			
			if (zoom_level==0 && g_range.end-spacing.smallbw*spacing.ratio < marker_hz) {

			   //if this is the last overall marker when zoomed all the way out
				//console.log('case 2');
				if (x > window.innerWidth-text_measured.width/2) {
				   //and if it would be clipped off the screen
					if (window.innerWidth-text_measured.width-scale_px_from_freq(marker_hz-spacing.smallbw*spacing.ratio,g_range) >= scale_min_space_btwn_texts) {
					   //and if we have enough space to draw it correctly without clipping
						scale_ctx.textAlign = "right";
						scale_ctx.fillText(text_to_draw, window.innerWidth, text_y_pos); 
					}	
				} else {
					// last large marker is not the last marker, so draw normally
					scale_ctx.fillText(text_to_draw, x, text_y_pos);
				}
			} else {
			   //draw text normally
				//console.log('case 3');
				scale_ctx.fillText(text_to_draw, x, text_y_pos);
			}
		} else {
		
			//small marker
			scale_ctx.lineWidth = 2;
			scale_ctx.lineTo(x,22+8);
		}
		
		marker_hz += spacing.smallbw;
		scale_ctx.stroke();
	}

   if (conv_ct > 1000) { console.log("CONV_CT > 1000!!!"); kiwi_trace(); }

	if (zoom_level != 0) {	// if zoomed, we don't want the texts to disappear because their markers can't be seen
		// on the left side
		scale_ctx.textAlign = "center";
		var f = first_large-spacing.smallbw*spacing.ratio;
		var x = scale_px_from_freq(f,g_range);
		ftext(f);
		var w = scale_ctx.measureText(text_to_draw).width;
		if (x+w/2 > 0) scale_ctx.fillText(text_to_draw, x, 22+10);

		// on the right side
		f = last_large+spacing.smallbw*spacing.ratio;
		x = scale_px_from_freq(f,g_range);
		ftext(f);
		w = scale_ctx.measureText(text_to_draw).width;
		if (x-w/2 < window.innerWidth) scale_ctx.fillText(text_to_draw, x, 22+10);
	}
}

// carrier marker symbol dimensions
var dx_car_size = 8;
var dx_car_border = 3;
var dx_car_w = dx_car_h = dx_car_border*2 + dx_car_size;

function resize_scale(a)
{
	band_ctx.canvas.width  = window.innerWidth;
	band_ctx.canvas.height = band_canvas_h;

	dx_div.style.width = window.innerWidth+'px';

	dx_ctx.canvas.width = dx_car_w;
	dx_ctx.canvas.height = dx_car_h;
	dx_canvas.style.top = (scale_canvas_top - dx_car_h)+'px';
	dx_canvas.style.left = 0;
	dx_canvas.style.zIndex = 99;
	
	// the dx canvas is used to form the "carrier" marker symbol (yellow triangle) seen when
	// an NDB dx label is entered by the mouse
	dx_ctx.beginPath();
	dx_ctx.lineWidth = dx_car_border-1;
	dx_ctx.strokeStyle='black';
	var o = dx_car_border;
	var x = dx_car_size;
	dx_ctx.moveTo(o,o);
	dx_ctx.lineTo(o+x,o);
	dx_ctx.lineTo(o+x/2,o+x);
	dx_ctx.lineTo(o,o);
	dx_ctx.stroke();
	dx_ctx.fillStyle = "yellow";
	dx_ctx.fill();

	scale_ctx.canvas.width  = window.innerWidth;
	scale_ctx.canvas.height = scale_canvas_h;
	mkscale();
   dx_schedule_update();
}

function format_frequency(format, freq_hz, pre_divide, decimals)
{
	out = format.replace("{x}",(freq_hz/pre_divide).toFixed(decimals));
	if (0) {
		at=out.indexOf(".")+4;
		while(decimals>3)
		{
			out=out.substr(0,at)+","+out.substr(at);
			at+=4;
			decimals-=3;
		}
	}
	return out;
}

function mkscale()
{
	mk_freq_scale();
	mk_bands_scale();
	//mk_spurs();
}


////////////////////////////////
// conversions
////////////////////////////////

// A "bin" is the wf_fft_size multiplied by the maximum zoom factor.
// So there are approx 1024 * 2^14 = 16M bins.
// The left edge of the waterfall is specified with a bin number.
// The higher precision of having a large number of bins makes the code simpler.
// Remember that the actual displayed waterfall_width is typically larger than the
// wf_fft_size data in the canvas due to stretching of the canvas to fit the screen.

function bins_at_zoom(zoom)
{
	var bins = wf_fft_size << (zoom_levels_max - zoom);
	return bins;
}

function bins_at_cur_zoom()
{
	return bins_at_zoom(zoom_level);
}

// norm: normalized position, e.g. 0..1 cursor position on window
function norm_to_bins(norm)
{
	return Math.round(norm * bins_at_cur_zoom());
}

function bin_to_freq(bin) {
	var max_bins = wf_fft_size << zoom_levels_max;
	return Math.round((bin / max_bins) * bandwidth);
}

function freq_to_bin(freq) {
	var max_bins = wf_fft_size << zoom_levels_max;
	return Math.round(freq/bandwidth * max_bins);
}

function bins_to_pixels_frac(cf, bins, zoom) {
	var bin_ratio = bins / bins_at_zoom(zoom);
	if (sb_trace) console.log('bins_to_pixels_frac bins='+ bins +' z='+ zoom +' ratio='+ bin_ratio);
	if (bin_ratio > 1) bin_ratio = 1;
	if (bin_ratio < -1) bin_ratio = -1;
	var f_pixels = wf_fft_size * bin_ratio;
	return f_pixels;
}

function bins_to_pixels(cf, bins, zoom) {
	var f_pixels = bins_to_pixels_frac(cf, bins, zoom);
	var i_pixels = Math.round(f_pixels);
	return i_pixels;
}

function freq_to_pixel(freq) {
	var bins = freq_to_bin(freq) - x_bin;
	if (!(bins >= 0 && bins < bins_at_cur_zoom())) {
	   console.log("freq_to_pixel: bins="+bins+" bins_at_cur_zoom="+bins_at_cur_zoom());
		console.assert("assert fail");
	}
	var pixels = bins_to_pixels(0, bins, zoom_level);
	return pixels;
}

// clamp xbin (left edge of waterfall) to bin number available at current zoom level
function clamp_xbin(xbin)
{
	if (xbin < 0) xbin = 0;
	var max_bins = wf_fft_size << zoom_levels_max;
	var max_xbin_at_cur_zoom = max_bins - bins_at_cur_zoom();		// because right edge would be > max_bins
	if (xbin > max_xbin_at_cur_zoom) xbin = max_xbin_at_cur_zoom;
	return xbin;
}

// if the center freq of the passband is visible in the waterfall:
//		returns the bin of the passband center freq
//		else returns the (negative bin - 1) of passband outside the waterfall

function passband_visible()
{
	if (isUndefined(demodulators[0])) return x_bin;	// punt if no demod yet
	var f = freq_passband_center();
	var pb_bin = freq_to_bin(f);
	//console.log("PBV f="+f+" x_bin="+x_bin+" BACZ="+bins_at_cur_zoom()+" max_bin="+(x_bin+bins_at_cur_zoom())+" pb_bin="+pb_bin);
	pb_bin = (pb_bin >= x_bin && pb_bin < (x_bin+bins_at_cur_zoom()))? pb_bin : -pb_bin-1;
	//console.log("PBV ="+pb_bin+' '+((pb_bin<0)? 'outside':'inside'));
	return pb_bin;
}


////////////////////////////////
// canvas
////////////////////////////////

var debug_canvas_drag = false;

function canvas_log(s)
{
   if (s.charAt(0) == '$')
      owrx.news_acc_s = '<br><br>'+ s;
   else
      owrx.news_acc_s += ((owrx.news_acc_s != '')? ' | ' : '') + s;
   extint_news(owrx.news_acc_s);
}

function canvas_contextmenu(evt)
{
	//console.log('## CMENU tgt='+ evt.target.id +' Ctgt='+ evt.currentTarget.id);
	
	if (evt.target.id == 'id-wf-canvas') {
		// TBD: popup menu with database lookup, etc.
	}
	
	// let ctrl-dx_click thru
	if (evt && evt.currentTarget && evt.currentTarget.id == 'id-dx-container') {
	   //console.log('canvas_contextmenu: synthetic ctrl-dx_click');
	   dx.ctrl_click = true;
	   w3_el(evt.target.id).click();
	}
	
	// must always cancel even so system context menu doesn't appear
	return cancelEvent(evt);
}

function canvas_mouseover(evt)
{
	if (!waterfall_setup_done) return;
	//html("id-freq-show").style.visibility="visible";	
}

function canvas_mouseout(evt)
{
	if (!waterfall_setup_done) return;
	if (debug_canvas_drag) event_dump(evt, 'canvas_mouseout', 1);
	//html("id-freq-show").style.visibility="hidden";
}

function canvas_get_carfreq_offset(relativeX, incl_PBO)
{
   var freq;
   var norm = relativeX/waterfall_width;
   if (wf.audioFFT_active) {
      var cur = center_freq + demodulators[0].offset_frequency;
      var iq_or_drm = (cur_mode == 'iq' || cur_mode == 'drm');
      norm -= iq_or_drm? 0.5 : 0.25;
      var incr = norm * audio_input_rate * (iq_or_drm? 2 : 1);
      freq = cur + incr;
      //console.log('canvas_get_carfreq_offset(audioFFT) f='+ freq +' cur='+ cur +' incr='+ incr +' norm='+ norm);
   } else {
      var bin = x_bin + norm * bins_at_cur_zoom();
      freq = bin_to_freq(bin);
      //console.log('canvas_get_carfreq_offset f='+ freq +' bin='+ bin +' norm='+ norm);
   }
	var offset = incl_PBO? passband_offset() : 0;
	var f = Math.round(freq - offset);
	var cfo = f - (bandwidth/2);
	//console.log("CGCFO f="+f+" off="+offset+" cfo="+cfo);
	return cfo;
}

function canvas_get_dspfreq(relativeX)
{
	return canvas_get_carfreq_offset(relativeX, false) + center_freq;
}

canvas_dragging = false;
canvas_drag_min_delta = 1;
canvas_mouse_down = false;
canvas_ignore_mouse_event = false;

var mouse = { 'left':0, 'middle':1, 'right':2 };

function canvas_start_drag(evt, x, y)
{
	var dump_event = false;
	if (debug_canvas_drag) canvas_log('CSD');
	
	// Distinguish ctrl-click right-button meta event from actual right-button on mouse (or touchpad two-finger tap).
	if (evt.button == mouse.right && !evt.ctrlKey) {
		//dump_event = true;
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-Rclick IME=set-true');
		if (debug_canvas_drag) canvas_log('ordinary-RCM');
		right_click_menu(x, y);
      owrx.right_click_menu_active = true;
		canvas_ignore_mouse_event = false;
		if (debug_canvas_drag) console.log('CSD-Rclick IME=set-false');
		return;
	}
	
	if (dump_event) event_dump(evt, "MDN");

	if (evt.shiftKey && evt.target.id == 'id-dx-container') {
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-DX IME=set-true');
		dx_show_edit_panel(evt, -1);
	} else

	// select waterfall on nearest appropriate boundary (1, 5 or 9/10 kHz depending on band)
	if (evt.shiftKey && !(evt.ctrlKey || evt.altKey)) {
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-Wboundary IME=set-true');
		var step_Hz = 1000;
		var fold = canvas_get_dspfreq(x);
		var b = find_band(fold);
		var cm = cur_mode.substr(0,2);
		var am_ssb_iq_drm = (cm == 'am' || cm == 'sa' || cm == 'ls' || cm == 'us' || cm == 'iq' || cm == 'dr');
		//console_log('nearest', cm, am_ssb_iq_drm);
	   var ITU_region = cfg.init.ITU_region + 1;
	   var ham_80m_swbc_75m_overlap = (ITU_region == 2 && b && b.name == '75m');

		if (b != null && (b.name == 'LW' || b.name == 'MW')) {
			if (am_ssb_iq_drm) {
				step_Hz = step_9_10? 9000 : 10000;
				//console.log('SFT-CLICK 9_10');
			}
		} else
		if (b != null && (b.s == svc.B) && !ham_80m_swbc_75m_overlap) {      // SWBC bands
			if (am_ssb_iq_drm) {
				step_Hz = 5000;
				//console.log('SFT-CLICK SWBC');
			}
		}
		
		var trunc = fold / step_Hz;
		var fnew = Math.round(trunc) * step_Hz;
		//console.log('SFT-CLICK '+cur_mode+' fold='+fold+' step='+step_Hz+' trunc='+trunc+' fnew='+fnew);
		freqmode_set_dsp_kHz(fnew/1000, null);
	} else

	// lookup mouse pointer frequency in online resource appropriate to the frequency band
	if (evt.shiftKey && (evt.ctrlKey || evt.altKey)) {
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-lookup IME=set-true');
		freq_database_lookup(canvas_get_dspfreq(x), evt.altKey);
	} else
	
	// page scrolling via ctrl & alt-key click
	if (evt.ctrlKey) {
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-pageScroll1 IME=set-true');
		page_scroll(-page_scroll_amount);
	} else
	
	if (evt.altKey) {
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CSD-pageScroll2 IME=set-true');
		page_scroll(page_scroll_amount);
	}
	
	owrx.drag_count = 0;
	canvas_mouse_down = true;
	canvas_dragging = false;
	owrx.canvas_drag_last_x = owrx.canvas_drag_start_x = x;
	owrx.canvas_drag_last_y = owrx.canvas_drag_start_y = y;
}

function canvas_mousedown(evt)
{
	if (debug_canvas_drag) canvas_log('$C-MD RCMA'+ (owrx.right_click_menu_active? 1:0));
   //event_dump(evt, "C-MD");
	canvas_start_drag(evt, evt.pageX, evt.pageY);
	evt.preventDefault();	// don't show text selection mouse pointer
}

function canvas_touchStart(evt)
{
   var touches = evt.targetTouches.length;
   var x = Math.round(evt.targetTouches[0].pageX);
   var y = Math.round(evt.targetTouches[0].pageY);
	if (debug_canvas_drag) canvas_log("$C-TS"+ touches +'-x'+ x +'-y'+ y);
   owrx.double_touch_start = false;
   
   if (touches == 1) {
		canvas_start_drag(evt, x, y);
   /*
		owrx.touch_pending_start_drag = true;
		owrx.touch_pending_evt = evt;

      owrx.touch_hold_start = (new Date()).getTime();
      owrx.touch_hold_pressed = true;
      owrx.touch_hold_interval =
         setInterval(function() {
            if ((new Date()).getTime() - owrx.touch_hold_start > 750) {
               owrx.touch_hold_pressed = owrx.touch_pending_start_drag = false;
               kiwi_clearInterval(owrx.touch_hold_interval);
               alert(x +' '+ y +' '+ evt.target.id);
               canvas_start_drag(touch_pending_evt, x, y);
            }
         }, 200);
	*/
	} else
	
	if (touches == 2) {
		canvas_start_drag(evt, x, y);
	   //alert('canvas_touchStart='+ evt.targetTouches.length);
		canvas_ignore_mouse_event = true;
		if (debug_canvas_drag) console.log('CTS-doubleTouch IME=set-true');
		owrx.touches_first_startx = x;
      owrx.pinch_distance_first =
         Math.round(Math.hypot(evt.touches[0].pageX - evt.touches[1].pageX, evt.touches[0].pageY - evt.touches[1].pageY));
      owrx.pinch_distance_last = owrx.pinch_distance_first;
		owrx.double_touch_start = true;
	}
	
	evt.preventDefault();	// don't show text selection mouse pointer
}

function canvas_drag(evt, x, y, clientX, clientY)
{
	if (!waterfall_setup_done) return;
	//element=html("id-freq-show");
	var relativeX = x;
	var relativeY = y;
	spectrum_tooltip_update(evt, clientX, clientY);
	owrx.drag_count++;

   if (debug_canvas_drag)
      canvas_log('CD#'+ owrx.drag_count +' x'+ x +' y'+ y +' CMD'+ (canvas_mouse_down? 1:0) +' IME'+ (canvas_ignore_mouse_event? 1:0) +' DG'+ (canvas_dragging? 1:0));

   // drag_count > 10 was required on Lenovo TB-7104F / Android 8.1.0 to differentiate double-touch from true drag.
   // I.e. an excessive number of touch events seem to be sent by browser for a single double-touch.
	if (canvas_mouse_down && (!canvas_ignore_mouse_event || owrx.double_touch_start)) {
		if (!canvas_dragging && owrx.drag_count > 10 && Math.abs(x - owrx.canvas_drag_start_x) > canvas_drag_min_delta) {
			canvas_dragging = true;
			canvas_container.style.cursor = "move";
		}
		if (canvas_dragging) {
			var deltaX = owrx.canvas_drag_last_x - x;
			var deltaY = owrx.canvas_drag_last_y - y;

         if (owrx.double_touch_start) {
            var dist = Math.round(Math.hypot(owrx.canvas_drag_last_x - x, owrx.canvas_drag_last_y - y));
            var delta = Math.abs(dist - owrx.pinch_distance_last);
            if (debug_canvas_drag) canvas_log(dist.toFixed(0) +' '+ delta.toFixed(0));
            if (delta > 25) {
               if (debug_canvas_drag) canvas_log('*');
               var pinch_in = (dist <= owrx.pinch_distance_last);
               zoom_step(pinch_in? ext_zoom.OUT : ext_zoom.IN);
               if (debug_canvas_drag) canvas_log(pinch_in? 'IN' : 'OUT');
               owrx.pinch_distance_last = dist;
            }
         } else {
            var dbins = norm_to_bins(deltaX / waterfall_width);
            waterfall_pan_canvases(dbins);
         }

			owrx.canvas_drag_last_x = x;
			owrx.canvas_drag_last_y = y;
		}
	} else {
		w3_innerHTML('id-mouse-unit', format_frequency("{x}", canvas_get_dspfreq(relativeX) + cfg.freq_offset*1e3, 1e3, 2));
		//console.log("MOU rX="+relativeX.toFixed(1)+" f="+canvas_get_dspfreq(relativeX).toFixed(1));
	}
}

function canvas_mousemove(evt)
{
	//if (debug_canvas_drag) console.log("C-MM");
   //event_dump(evt, "C-MM");
	canvas_drag(evt, evt.pageX, evt.pageY, evt.clientX, evt.clientY);
}

function canvas_touchMove(evt)
{
	if (evt.touches.length >= 1) {
	   owrx.touches_first_lastx = evt.touches[0].pageX;
	}
	
	for (var i=0; i < evt.touches.length; i++) {
		var x = Math.round(evt.touches[i].pageX);
		var y = Math.round(evt.touches[i].pageY);
	   //if (debug_canvas_drag) canvas_log('C-TM-x'+ x +'-y'+ y);

   /*
      // any movement cancels touch hold
      if (owrx.touch_hold_pressed) {
         owrx.touch_hold_pressed = false;
         kiwi_clearInterval(owrx.touch_hold_interval);
      }

      if (owrx.touch_pending_start_drag) {
		   canvas_start_drag(evt, x, y);
         owrx.touch_pending_start_drag = false;
      }
   */
   
		canvas_drag(evt, x, y, x, y);
	}
	evt.preventDefault();
}

function canvas_end_drag2()
{
	if (debug_canvas_drag) canvas_log("C-ED2");
	canvas_container.style.cursor = "crosshair";
	canvas_mouse_down = false;
	canvas_ignore_mouse_event = false;
	if (debug_canvas_drag) { console.log("C-ED2 IME=set-false"); }
}

// When mouseup occurs outside our original canvas canvas_mouseup() doesn't occur terminating the drag.
// So have to detect canvas crossing and terminate that way.
function canvas_container_mouseout(evt)
{
	if (debug_canvas_drag) event_dump(evt, "canvas_container_mouseout", 1);
	if (debug_canvas_drag) canvas_log("C-MOUT");
	canvas_end_drag2();
}

function canvas_end_drag(evt, x)
{
	if (debug_canvas_drag) canvas_log('C-ED IME'+ (canvas_ignore_mouse_event? 1:0) +' CD'+ (canvas_dragging? 1:0));

	if (!waterfall_setup_done) return;
	//console.log("MUP "+this.id+" ign="+canvas_ignore_mouse_event);
	var relativeX = x;

	if (canvas_ignore_mouse_event) {
	   //console.log('## canvas_ignore_mouse_event');
		//ignore_next_keyup_event = true;
	} else {
		if (!canvas_dragging) {
			//event_dump(evt, "MUP");
			
			// don't set freq if mouseup without mousedown due to move into canvas from elsewhere
			if (debug_canvas_drag) canvas_log('CMD'+ (canvas_mouse_down? 1:0) +' RCMA'+ (owrx.right_click_menu_active? 1:0) +' TL'+ owrx.tuning_locked);
			if (canvas_mouse_down) {
			
			   // mobile mode (touch screen): hack to close menu when touch outside of menu area.
			   // Desktop does this instead by intercepting mousedown and keyboard escape events.
			   // Intercepting touchstart didn't work hence this hack.
			   if (owrx.right_click_menu_active) {
			      w3int_menu_onclick(null, 'id-right-click-menu');
			      owrx.right_click_menu_active = false;
			   } else {
               if (owrx.tuning_locked) {
                  var el = w3_el('id-tuning-lock-container');
                  el.style.opacity = 0.8;
                  w3_show(el);
                  var el2 = w3_el('id-tuning-lock');
                  el2.style.marginTop = px(w3_center_in_window(el2, 'TL'));
                  setTimeout(function() {
                     el.style.opacity = 0;      // CSS is setup so opacity fades
                     setTimeout(function() { w3_hide(el); }, 500);
                  }, 300);
               } else {
                  // single-click in canvas area
                  if (debug_canvas_drag) canvas_log('*click*');
                  demodulator_set_offset_frequency(0, canvas_get_carfreq_offset(relativeX, true));
               }
            }
			}
		} else {
			canvas_end_drag2();
		}
	}
	
	canvas_mouse_down = false;
	canvas_ignore_mouse_event = false;
	if (debug_canvas_drag) console.log('C-ED IME=set-false');
}

function canvas_mouseup(evt)
{
	if (debug_canvas_drag) console.log("C-MU");
   //event_dump(evt, "C-MU");
	canvas_end_drag(evt, evt.pageX);
}

function canvas_touchEnd(evt)
{
	var x = owrx.canvas_drag_last_x, y = owrx.canvas_drag_last_y;
	if (debug_canvas_drag) canvas_log('C-TE-x'+ x +'-DTS'+ (owrx.double_touch_start? 1:0) +'-DRAG'+ (canvas_dragging? 1:0));
	canvas_end_drag(evt, x);
/*
   owrx.touch_hold_pressed = false;
   kiwi_clearInterval(owrx.touch_hold_interval);
*/
	spectrum_tooltip_update(evt, x, y);
	
	if (owrx.double_touch_start) {
	   if (debug_canvas_drag) canvas_log('dr'+ canvas_dragging);

	   if (!canvas_dragging) {
         // ensure menu on narrow screen devices is visible to prevent off-screen placement
         if (kiwi_isMobile() && owrx.mobile && owrx.mobile.small)
            x = 10;
   
         if (debug_canvas_drag) canvas_log('*');
         right_click_menu(x, y);
         owrx.right_click_menu_active = true;
      } else {
         //var pinch_in = (owrx.pinch_distance_first >= owrx.pinch_distance_last)? 1:0;
         //if (debug_canvas_drag) canvas_log('pinch-'+ owrx.pinch_distance_first +'-'+ owrx.pinch_distance_last + (pinch_in? '-IN' : '-OUT'));
      }
      
      canvas_ignore_mouse_event = false;
      if (debug_canvas_drag) console.log('CTE-doubleTouch IME=set-false');
		owrx.double_touch_start = false;
	}
	
	evt.preventDefault();
}

var canvas_mousewheel_rlimit = kiwi_rateLimit(canvas_mousewheel_cb, 170);

function canvas_mousewheel(evt)
{
   canvas_mousewheel_rlimit(evt);
	evt.preventDefault();	
}

function canvas_mousewheel_cb(evt)
{
	if (!waterfall_setup_done) return;
	//console.log(evt);
   zoom_step((evt.deltaY < 0)? ext_zoom.IN : ext_zoom.OUT, evt.pageX);
	
	/*
   // scaling value is a scrolling sensitivity compromise between wheel mice and
   // laptop trackpads (and also Apple trackpad mice)
	zoom_level_f += evt.deltaY * -0.05;
	zoom_level_f = Math.max(Math.min(zoom_level_f, zoom_levels_max), 0);
	//console.log('mousewheel '+ zoom_level_f.toFixed(1));
	//w3_innerHTML('id-owner-info', 'mousewheel '+ zoom_level_f.toFixed(2) +' '+ evt.deltaY);
	zoom_step(ext_zoom.WHEEL, evt.pageX);
	*/
}


////////////////////////////////
// right click menu
////////////////////////////////

function right_click_menu_init()
{
   w3_menu('id-right-click-menu', 'right_click_menu_cb');

   // for tuning lock
   var s =
      w3_div('id-tuning-lock-container class-overlay-container w3-hide',
         w3_div('id-tuning-lock', w3_icon('', 'fa-lock', 192) + '<br>Tuning locked')
      );
   w3_appendElement('id-main-container', 'div', s);
}

var right_click_menu_content = [
   'database lookup',
   'Utility database lookup',
   'DX Cluster lookup',
   '<hr>',
   '🔒 lock tuning',
   'restore passband',
   'save waterfall as JPG',
   'edit last selected DX label',
   'DX label filter',
   '<hr>',
   '<i>cal ADC clock (admin)</i>'
];

function right_click_menu(x, y)
{
   var kHz = freq_displayed_Hz/1000;
   var b = band_info();
   var db;

   if (kHz >= b.NDB_lo && kHz < b.NDB_hi) db = 'NDB';
   else
   if (kHz < b.LW_lo) db = 'VLF/LF';
   else
   if (kHz < b.MW_hi) db = 'LW/MW';
   else
      db = 'SWBC';

   right_click_menu_content[0] = db + ' database lookup';
   
   // disable menu item if last label gid is not set
   right_click_menu_content[7] = (owrx.dx_click_gid_last? '':'!') +'edit last selected DX label';

   w3_menu_items('id-right-click-menu', right_click_menu_content);
   w3_menu_popup('id-right-click-menu', x, y);
}

function right_click_menu_cb(idx, x)
{
   //console.log('right_click_menu_cb idx='+ idx +' x='+ x +' f='+ canvas_get_dspfreq(x)/1e3);
   
   switch (idx) {
   
   case 0:  // database lookups
   case 1:
   case 2:
		freq_database_lookup(canvas_get_dspfreq(x), idx);
      break;
   
   case 3:  // tuning lock
      owrx.tuning_locked ^= 1;
      right_click_menu_content[4] = (owrx.tuning_locked? '🔓 unlock' : '🔒 lock') +' tuning';
      break;
      
   case 4:  // restore passband
      restore_passband(cur_mode);
      demodulator_analog_replace(cur_mode);
      break;
      
   case 5:  // save waterfall image
      export_waterfall(canvas_get_dspfreq(x));
      break;
   
   case 6:  // edit last selected dx label
      dx_show_edit_panel(null, owrx.dx_click_gid_last);
      break;
   
   case 7:  // open dx label filter
      dx_filter();
      break;
   
   case 8:  // cal ADC clock
      admin_pwd_query(function() {
         var r1k_kHz = Math.round(freq_displayed_Hz / 1e3);     // 1kHz windows on 1 kHz boundaries
         var r1k_Hz = r1k_kHz * 1e3;
         var clk_diff = r1k_Hz - freq_displayed_Hz;
         var clk_adj = Math.round(clk_diff * ext_adc_clock_Hz() / r1k_Hz);   // clock adjustment normalized to ADC clock frequency
         console.log('cal ADC clock: dsp='+ freq_displayed_Hz +' car='+ freq_car_Hz +' r1k_kHz='+ r1k_kHz +' clk_diff='+ clk_diff +' clk_adj='+ clk_adj);
         var new_adj = cfg.clk_adj + clk_adj;
         var ppm = new_adj * 1e6 / ext_adc_clock_Hz();
         console.log('cal ADC clock: prev_adj='+ cfg.clk_adj +' new_adj='+ new_adj +' ppm='+ ppm.toFixed(1));
         cal_adc_dialog(new_adj, clk_diff, r1k_kHz, ppm);
      });
      break;
   
   case -1:
   default:
      break;
   }

   owrx.right_click_menu_active = false;
}

function freq_database_lookup(Hz, utility)
{
   var kHz = Hz/1000;
   var kHz_r10 = Math.round(Hz/10)/100;
   var kHz_r1k = Math.round(Hz/1000);
   //console.log('### Hz='+ Hz +' kHz='+ kHz +' kHz_r10='+ kHz_r10 +' kHz_r1k='+ kHz_r1k);
   var f;
   var url = "http://";

   var b = band_info();

   
   if (utility == 1) {
      f = Math.floor(Hz/100) / 10000;	// round down to nearest 100 Hz, and express in MHz, for GlobalTuners
      url += "qrg.globaltuners.com/?q="+f.toFixed(4);
   } 
   if (utility == 0) {
      if (kHz >= b.NDB_lo && kHz < b.NDB_hi) {
         f = kHz_r1k.toFixed(0);		// 1kHz windows on 1 kHz boundaries for NDBs
         url += "www.classaxe.com/dx/ndb/rww/signal_list/?mode=signal_list&submode=&targetID=&sort_by=khz&limit=-1&offset=0&show=list&"+
         "type_DGPS=1&type_NAVTEX=1&type_NDB=1&filter_id=&filter_khz_1="+ f +"&filter_khz_2="+ f +
         "&filter_channels=&filter_sp=&filter_sp_itu_clause=AND&filter_itu=&filter_continent=&filter_dx_gsq=&region=&"+
         "filter_listener=&filter_heard_in=&filter_date_1=&filter_date_2=&offsets=&sort_by_column=khz";
      } else
   
      if (kHz < b.LW_lo) {		// VLF/LF
         f = Math.round(Hz/100) / 10;	// 100 Hz windows on 100 Hz boundaries
         console.log('kHz='+ kHz +' f='+ f);
         url += "www.mwlist.org/vlf.php?kHz="+f.toFixed(1);
      } else
   
      if (kHz < b.MW_hi) {		// LW/MW
         f = Math.round(kHz_r1k/b._9_10) * b._9_10;
         console.log('MW kHz='+ kHz +' f='+ f);
         var mwlist_area = [ 0, 1, 3, 2 ];	// mwlist_area = 1:ITU1(E) 2:ITU3(AP) 3:ITU2-SA(NA) 4:SA
         url += "www.mwlist.org/mwlist_quick_and_easy.php?area="+ mwlist_area[b.ITU_region] +"&kHz="+f.toFixed(0);
      } else
   
      {
         // HF: short-wave.info is only >= 2 MHz
         f = Math.round(kHz_r1k/5) * 5;	// 5kHz windows on 5 kHz boundaries -- intended for SWBC
         url += "www.short-wave.info/index.php?freq="+f.toFixed(0)+"&timbus=NOW&ip="+client_public_ip+"&porm=4";
      }
   }
   if (utility == 2) {
      f = Math.floor(Hz) / 1000;	// KHz for ve3sun dx cluster lookup
      url += 've3sun.com/KiwiSDR/DX.php?Search='+f.toFixed(1);
   }
   
   console.log('LOOKUP '+ kHz +' -> '+ f +' '+ url);
   var win = window.open(url, '_blank');
   if (win) win.focus();
}

function export_waterfall(Hz) {

    f = get_visible_freq_range()
    var fileName = Math.floor(f.center/100)/10 + cfg.freq_offset +'+-'+ Math.floor((f.end-f.center)/100)/10 +'KHz.jpg'

    var PNGcanvas = document.createElement("canvas");
    PNGcanvas.width = wf_fft_size;
    PNGcanvas.height = (old_canvases.length+wf_canvases.length) * wf_canvas_default_height;
    PNGcanvas.ctx = PNGcanvas.getContext("2d");
    PNGcanvas.ctx.fillStyle="black";
    PNGcanvas.ctx.fillRect(0, 0, PNGcanvas.width, PNGcanvas.height);

    PNGcanvas.ctx.strokeStyle="red";
    
    var h = 0;
    wf_canvases.forEach(function(wf_c) {
        
        PNGcanvas.ctx.drawImage(wf_c,0,h);
        h += wf_c.height;
        });
    if (old_canvases.length > 1)
        {
        for (i=1; i < old_canvases.length; i++)
           {
           PNGcanvas.ctx.drawImage(old_canvases[i],0,h);
           h += old_canvases[i].height;
           }
        }
        // old_canvases.forEach(function(wf_c) {
        //PNGcanvas.ctx.drawImage(wf_c,0,h);
        //h += wf_c.height;
        // });
    var arrow;
    if (!Hz) Hz = f.center;
    arrow = wf_fft_size*(Hz-f.start)/(f.end-f.start);

    PNGcanvas.ctx.moveTo(arrow, 0); 
    PNGcanvas.ctx.lineTo(arrow, 50); 
    
//    var arrowMinus = wf_fft_size*(1000*(Math.floor(Hz/1000))-f.start)/(f.end-f.start);
//    var arrowPlus  = wf_fft_size*(1000*(Math.floor((1000+Hz)/1000))-f.start)/(f.end-f.start);
//    PNGcanvas.ctx.moveTo(arrowMinus, 50);
//    PNGcanvas.ctx.lineTo(arrowMinus, 40);
//    PNGcanvas.ctx.lineTo(arrowPlus, 40);
//    PNGcanvas.ctx.lineTo(arrowPlus, 50);
            
//    for(h=1200; h < PNGcanvas.height; h += 1200)
//       {
//       PNGcanvas.ctx.moveTo(0,h);
//       PNGcanvas.ctx.lineTo(PNGcanvas.width,h);
//       } 

    PNGcanvas.ctx.stroke(); 
    
    var flabel = Math.floor(Hz/100)/10 + cfg.freq_offset;
    flabel = flabel + ' KHz ';
    PNGcanvas.ctx.font = "18px Arial";
    PNGcanvas.ctx.fillStyle = "lime";
    flabel += window.location.href.substring(7); 
    flabel = flabel.substring(0,flabel.indexOf(':'));

//    if (!Hz && document.getElementById('id-rx-title')) flabel = document.getElementById('id-rx-title').innerHTML;
    PNGcanvas.ctx.fillText(flabel,arrow+10,35);
    
    var fdate = (new Date()).toUTCString();
    PNGcanvas.ctx.fillText(fdate,arrow-PNGcanvas.ctx.measureText(fdate).width-10,35);
    
    var imgURL = PNGcanvas.toDataURL("image/jpeg",0.85);

    var dlLink = document.createElement('a');
    dlLink.download = fileName;
    dlLink.href = imgURL;
    dlLink.dataset.downloadurl = ["image/jpeg", dlLink.download, dlLink.href].join(':');
//    alert(dlLink.dataset.downloadurl.length/1024);
    document.body.appendChild(dlLink);
    dlLink.click();
    document.body.removeChild(dlLink);
}


////////////////////////////////
// zoom
////////////////////////////////

function zoom_finally()
{
	w3_innerHTML('id-nav-optbar-wf', 'WF'+ zoom_level.toFixed(0));
	wf_gnd_value = wf_gnd_value_base - zoomCorrection();
   extint_environment_changed( { zoom:1 } );
	freqset_select();
}

var ZOOM_NOMINAL = 10, ZOOM_BAND = 6;
var zoom_nom = 0, zoom_old_nom = 0;
var zoom_levels_max = 0;
var zoom_level = 0;
var zoom_level_f = 0;
var zoom_freq = 0;
var zoom_maxin_s = ['id-maxin', 'id-maxin-nom', 'id-maxin-max'];

var x_bin = 0;				// left edge of waterfall in units of bin number

// called from mouse wheel and zoom button pushes
// x_rel: 0 .. waterfall_width, position of mouse cursor on window, -1 called from button push

function zoom_step(dir, arg2)
{
   if (wf.audioFFT_active) {
      audioFFT_update();
      return;
   }
   
	var out = (dir == ext_zoom.OUT);
	var dir_in = (dir == ext_zoom.IN);
	var not_band_and_not_abs = (dir != ext_zoom.TO_BAND && dir != ext_zoom.ABS);
	var ozoom = zoom_level;
	var x_obin = x_bin;
	var x_norm;
	var update_zoom_f = true;
	
	if (dir == ext_zoom.WHEEL) {
	   if (arg2 == undefined) return;
	   update_zoom_f = false;
	   var znew = Math.round(zoom_level_f);
	   if (znew == ozoom) return;
	   dir = (znew > ozoom)? ext_zoom.IN : ext_zoom.OUT;
	}

	//console.log('zoom_step dir='+ dir +' arg2='+ arg2);
	if (dir == ext_zoom.MAX_OUT) {		// max out
		out = true;
		zoom_level = 0;
		x_bin = 0;
	} else {			// in/out, nom/max in, abs, band
	
		// clamp
		if (not_band_and_not_abs && ((out && zoom_level == 0) || (dir_in && zoom_level >= zoom_levels_max))) { zoom_finally(); return; }

		if (dir == ext_zoom.TO_BAND) {
			// zoom to band
			var f = center_freq + demodulators[0].offset_frequency;
			var cf;
			var b = arg2;	// band specified by caller
			if (b != undefined) {
				zoom_level = b.zoom_level;
				cf = b.cf;
				if (sb_trace)
					console.log("ZTB-user f="+f+" cf="+cf+" b="+b.name+" z="+b.zoom_level);
			} else {
				for (i=0; i < bands.length; i++) {		// search for first containing band
					b = bands[i];
					if (f >= b.min && f <= b.max)
						break;
				}
				if (i != bands.length) {
					//console.log("ZTB-calc f="+f+" cf="+b.cf+" b="+b.name+" z="+b.zoom_level);
					zoom_level = b.zoom_level;
					cf = b.cf;
				} else {
					zoom_level = ZOOM_BAND;	// not in a band -- pick a reasonable span
					cf = f;
					//console.log("ZTB-outside f="+f+" cf="+cf);
				}
			}
			out = (zoom_level < ozoom);
			x_bin = freq_to_bin(cf);		// center waterfall at middle of band
			x_bin -= norm_to_bins(0.5);
		} else
		
		if (dir == ext_zoom.ABS) {
			if (arg2 == undefined) { zoom_finally(); return; }		// no abs zoom value specified
			var znew = arg2;
			//console.log('zoom_step ABS znew='+ znew +' zmax='+ zoom_levels_max +' zcur='+ zoom_level);
			if (znew < 0 || znew > zoom_levels_max || znew == zoom_level) { zoom_finally(); return; }
			out = (znew < zoom_level);
			zoom_level = znew;
			// center waterfall at middle of passband
			x_bin = freq_to_bin(freq_passband_center());
			x_bin -= norm_to_bins(0.5);
			//console.log("ZOOM ABS z="+znew+" out="+out+" b="+x_bin);
		} else
		
		if (dir == ext_zoom.NOM_IN || dir == ext_zoom.MAX_IN) {
			
			// zoom max-in button toggle hack
			if (dir == ext_zoom.NOM_IN && arg2 != undefined && arg2 == 1 && zoom_level >= zoom_nom) {
				if (zoom_level == zoom_levels_max)
					zoom_level = zoom_nom;		// if at max toggle back to nom
				else
					zoom_level = zoom_levels_max;		// if at anything other than max go to max
			} else {
				zoom_level = (dir == ext_zoom.NOM_IN)? zoom_nom : zoom_levels_max;
			}
			
			out = (zoom_level < ozoom);
			
			// center max zoomed waterfall at middle of passband
			x_bin = freq_to_bin(freq_passband_center());
			x_bin -= norm_to_bins(0.5);
		} else {
		
			// in, out
			if (dbgUs) {
				if (sb_trace) console.log('ZOOM IN/OUT');
				sb_trace=0;
			}
			if (arg2 != undefined) {
				var x_rel = arg2;
				
				// zoom in or out centered on cursor position, not passband
				x_norm = x_rel / waterfall_width;	// normalized position (0..1) on waterfall
			} else {
				// zoom in or out centered on passband, if visible, else middle of current waterfall
				var pb_bin = passband_visible();
				if (pb_bin >= 0) {		// visible
					x_norm = (pb_bin - x_bin) / bins_at_cur_zoom();
				} else {
					x_norm = 0.5;
				}
			}
			x_bin += norm_to_bins(x_norm);	// remove offset bin relative to current zoom
			zoom_level += dir;
			x_bin -= norm_to_bins(x_norm);	// add offset bin relative to new zoom
		}
	}
	
	if (update_zoom_f) zoom_level_f = zoom_level;
	//console.log("ZStep z"+zoom_level.toString()+" fLEFT="+canvas_get_dspfreq(0));
	
	var nom = (zoom_level == zoom_levels_max)? 2 : ((zoom_level >= zoom_nom)? 1:0);
	if (nom != zoom_old_nom) {
		w3_hide(zoom_maxin_s[zoom_old_nom]);
		w3_show(zoom_maxin_s[nom], 'w3-show-table-cell');
		zoom_old_nom = nom;
	}
	
	if (zoom_level == 0 || ozoom == 0) {
		w3_show_hide('id-maxout', zoom_level != 0, 'w3-show-table-cell');
		w3_show_hide('id-maxout-max', zoom_level == 0, 'w3-show-table-cell');
	}
	
	x_bin = clamp_xbin(x_bin);
	var dbins = out? (x_obin - x_bin) : (x_bin - x_obin);
	var pixel_dx = bins_to_pixels(1, dbins, out? zoom_level:ozoom);
	if (sb_trace) console.log("Zs z"+ozoom+'>'+zoom_level+' b='+x_bin+'/'+x_obin+'/'+dbins+' bz='+bins_at_zoom(ozoom)+' r='+(dbins / bins_at_zoom(ozoom))+' px='+pixel_dx);
	var dz = zoom_level - ozoom;
	if (sb_trace) console.log('zoom_step oz='+ ozoom +' zl='+ zoom_level +' dz='+ dz +' pdx='+ pixel_dx);
	waterfall_zoom_canvases(dz, pixel_dx);
	mkscale();
	dx_schedule_update();
	if (sb_trace) console.log("SET Z"+zoom_level+" xb="+x_bin);
	wf_send("SET zoom="+ zoom_level +" start="+ x_bin);
	need_maxmindb_update = true;
	writeCookie('last_zoom', zoom_level);
	freq_link_update();
   zoom_finally();
}

function passband_increment(wider)
{
   var pb = ext_get_passband();
   var pb_width = Math.abs(pb.high - pb.low);
   var pb_inc;
   if (wider)
      pb_inc = ((pb_width * (1/0.80)) - pb_width) / 2;		// wider
   else
      pb_inc = (pb_width - (pb_width * 0.80)) / 2;				// narrower

   var rnd = (pb_inc > 10)? 10 : 1;
   pb_inc = Math.round(pb_inc/rnd) * rnd;
   //console.log('PB w='+ pb_width +' inc='+ pb_inc +' lo='+ pb.low +' hi='+ pb.high);
   pb.low += wider? -pb_inc : pb_inc;
   pb.low = Math.round(pb.low/rnd) * rnd;
   pb.high += wider? pb_inc : -pb_inc;
   pb.high = Math.round(pb.high/rnd) * rnd;
   //console.log('PB lo='+ pb.low +' hi='+ pb.high);
   ext_set_passband(pb.low, pb.high, true);
}

function zoom_click(evt, dir, arg2)
{
	if (any_alternate_click_event(evt)) {
		// currentTarget.parent=<span> currentTarget=<div> target=<img>
		var div = evt.currentTarget;
		//var parent = div.parentNode;		
		var zin = w3_contains(div, 'id-zoom-in');
		var zout = w3_contains(div, 'id-zoom-out');
		if (!zin && !zout) return;
		passband_increment(zin);
		return;
	}
	
	if (dir == ext_zoom.NOM_IN)
		zoom_step(dir, 1);		// zoom max-in button toggle hack
	else
		zoom_step(dir);
}

function zoom_over(evt)
{
	// currentTarget.parent=<span> currentTarget=<div> target=<img>
	if (evt.target.nodeName != 'IMG') return;
	var img = evt.target;
	var div = evt.currentTarget;
	//console.log(div);
	//var parent = div.parentNode;
	//console.log(parent);
	
	var zin = w3_contains(div, 'id-zoom-in');
	
	// apply shift-key title to inner IMG element so when removed the default of the parent div applies
	if (any_alternate_click_event(evt)) {
		img.title = zin? 'passband widen' : 'passband narrow';
	} else {
		img.removeAttribute('title');
	}
}

var page_scroll_amount = 0.8;

function page_scroll(norm_dir)
{
   if (!wf.audioFFT_active) {
      var dbins = norm_to_bins(norm_dir);
      waterfall_pan_canvases(dbins);		// < 0 = pan left (toward lower freqs)
   }
   freqset_select();
}

function page_scroll_icon_click(evt, norm_dir)
{
   if (any_alternate_click_event(evt)) {
      dx_label_step((norm_dir < 0)? -1:1);
   } else {
      page_scroll(norm_dir);
   }
}


var window_width;
var waterfall_width;
var waterfall_scrollable_height;

var canvas_container;
var canvas_annotation;
var canvas_phantom;

var annotation_div;

var wf_canvases = [];
var old_canvases = [];
var wf_cur_canvas = null;
var wf_canvas_default_height = 200;
var wf_canvas_actual_line;
var wf_canvas_id_seq = 1;

// NB: canvas data width is wf_fft_size, but displayed style width is waterfall_width (likely different),
// so image is stretched to fit when rendered by browser.

function create_canvas(id, w, h, style_w, style_h)
{	
	var new_canvas = document.createElement('canvas');
	new_canvas.id = id;
	new_canvas.width = w;
	new_canvas.height = h;
	if (style_w) new_canvas.style.width = px(style_w);	
	if (style_h) new_canvas.style.height = px(style_h);	
	new_canvas.ctx = new_canvas.getContext("2d");
	return new_canvas;
}

function add_canvas()
{
   var new_canvas = create_canvas('id-wf-canvas', wf_fft_size, wf_canvas_default_height, waterfall_width, wf_canvas_default_height);
	new_canvas.id_seq = wf_canvas_id_seq++;
	wf_canvas_actual_line = wf_canvas_default_height-1;
	new_canvas.style.left = 0;
	new_canvas.openwebrx_height = wf_canvas_default_height;	

	// initially the canvas is one line "above" the top of the container
	new_canvas.openwebrx_top = (-wf_canvas_default_height+1);	
	new_canvas.style.top = px(new_canvas.openwebrx_top);

	new_canvas.oneline_image = new_canvas.ctx.createImageData(wf_fft_size, 1);

	canvas_container.appendChild(new_canvas);
	add_canvas_listner(new_canvas);
	wf_canvases.unshift(new_canvas);		// add to front of array which is top of waterfall

	wf_cur_canvas = new_canvas;
	if (kiwi_gc_wf) new_canvas = null;	// gc
}

var spectrum_canvas, spectrum_ctx;
var spectrum_dB, spectrum_dB_ttip;

function init_canvas_container()
{
	window_width = window.innerWidth;		// window width minus any scrollbar
	canvas_container = html("id-waterfall-container");
	waterfall_width = canvas_container.clientWidth;
	//console.log("init_canvas_container ww="+waterfall_width);
	canvas_container.addEventListener("mouseout", canvas_container_mouseout, false);

	// annotation canvas for FSK shift markers etc.
   canvas_annotation = create_canvas('id-annotation-canvas', wf_fft_size, wf_canvas_default_height, waterfall_width, wf_canvas_default_height);
   canvas_annotation.style.zIndex = 1;    // make on top of waterfall
	canvas_container.appendChild(canvas_annotation);
	add_canvas_listner(canvas_annotation);
	
	// annotation div for text containing links etc.
	annotation_div = w3_el('id-annotation-div');
	add_canvas_listner(annotation_div);
	annotation_div.style.pointerEvents = 'none';    // prevent premature end of canvas dragging

	// a phantom one at the end
	// not an actual canvas but a <div> spacer
	canvas_phantom = html("id-phantom-canvas");
	add_canvas_listner(canvas_phantom);
	canvas_phantom.style.width = px(canvas_container.clientWidth);

	// the first one to get started
	add_canvas();

   spectrum_canvas = create_canvas('id-spectrum-canvas', wf_fft_size, height_spectrum_canvas, waterfall_width, height_spectrum_canvas);
	html("id-spectrum-container").appendChild(spectrum_canvas);
	spectrum_ctx = spectrum_canvas.ctx;
	add_canvas_listner(spectrum_canvas);
	spectrum_ctx.font = "10px sans-serif";
	spectrum_ctx.textBaseline = "middle";
	spectrum_ctx.textAlign = "left";

	spectrum_dB = html("id-spectrum-dB");
	spectrum_dB.style.height = px(height_spectrum_canvas);
	spectrum_dB.style.width = px(waterfall_width);
	spectrum_dB.innerHTML = '<span id="id-spectrum-dB-ttip" class="class-spectrum-dB-tooltip class-tooltip-text"></span>';
	add_canvas_listner(spectrum_dB);
	spectrum_dB_ttip = html("id-spectrum-dB-ttip");
}

function add_canvas_listner(obj)
{
	obj.addEventListener("mouseover", canvas_mouseover, false);
	obj.addEventListener("mouseout", canvas_mouseout, false);
	obj.addEventListener("mousedown", canvas_mousedown, false);
	obj.addEventListener("mousemove", canvas_mousemove, false);
	obj.addEventListener("mouseup", canvas_mouseup, false);
	obj.addEventListener("contextmenu", canvas_contextmenu, false);
	obj.addEventListener("wheel", canvas_mousewheel, false);

	if (kiwi_isMobile()) {
		obj.addEventListener('touchstart', canvas_touchStart, false);
		obj.addEventListener('touchmove', canvas_touchMove, false);
		obj.addEventListener('touchend', canvas_touchEnd, false);
	}
}

function remove_canvas_listner(obj)
{
	obj.removeEventListener("mouseover", canvas_mouseover, false);
	obj.removeEventListener("mouseout", canvas_mouseout, false);
	obj.removeEventListener("mousedown", canvas_mousedown, false);
	obj.removeEventListener("mousemove", canvas_mousemove, false);
	obj.removeEventListener("mouseup", canvas_mouseup, false);
	obj.removeEventListener("contextmenu", canvas_contextmenu, false);
	obj.removeEventListener("wheel", canvas_mousewheel, false);

	if (kiwi_isMobile()) {
		obj.removeEventListener('touchstart', canvas_touchStart, false);
		obj.removeEventListener('touchmove', canvas_touchMove, false);
		obj.removeEventListener('touchend', canvas_touchEnd, false);
	}
}

wf_canvas_maxshift = 0;

function wf_shift_canvases()
{
	// shift the canvases downward by increasing their individual top offsets
	wf_canvases.forEach(function(p) {
		p.style.top = px(p.openwebrx_top++);
	});
	
	// retire canvases beyond bottom of scroll-back window
	while (wf_canvases.length) {
		var p = wf_canvases[wf_canvases.length-1];	// oldest
		
		if (p == null || p.openwebrx_top < waterfall_scrollable_height) {
			if (kiwi_gc_wf) p = null;	// gc
			break;
		}
		var pp = wf_canvases[wf_canvases.length-2];
		if (pp) old_canvases.unshift(pp);
		if (old_canvases.length > 15) old_canvases.pop();  // save up to 10*wf_fps seconds 
		//p.style.display = "none";
		if (kiwi_gc_wf) remove_canvas_listner(p);	// gc
		canvas_container.removeChild(p);
		if (kiwi_gc_wf) p = wf_canvases[wf_canvases.length-1] = null;	// gc
		wf_canvases.pop();
	}
	
	// set the height of the phantom to fill the unused space
	wf_canvas_maxshift++;
	if (wf_canvas_maxshift < canvas_container.clientHeight) {
		canvas_phantom.style.top = px(wf_canvas_maxshift);
		canvas_phantom.style.height = px(canvas_container.clientHeight - wf_canvas_maxshift);
		w3_show_block(canvas_phantom);
	} else
	if (!canvas_phantom.hidden) {
		w3_hide(canvas_phantom);
		canvas_phantom.hidden = true;
	}
	
	//canvas_container.style.height = px(((wf_canvases.length-1)*wf_canvas_default_height)+(wf_canvas_default_height-wf_canvas_actual_line));
	//canvas_container.style.height = "100%";
}

function resize_canvases(zoom)
{
	window_width = canvas_container.innerWidth;
	waterfall_width = canvas_container.clientWidth;
	//console.log("RESIZE winW="+window_width+" wfW="+waterfall_width);

	new_width = px(waterfall_width);
	var zoom_value = 0;
	//console.log("RESIZE z"+zoom_level+" nw="+new_width+" zv="+zoom_value);

	wf_canvases.forEach(function(p) {
		p.style.width = new_width;
		p.style.left = zoom_value;
	});

	canvas_annotation.width = waterfall_width;
	canvas_annotation.style.width = new_width;

	canvas_phantom.style.width = new_width;
	canvas_phantom.style.left = zoom_value;

	spectrum_canvas.style.width = new_width;

   // above width change clears canvas, so redraw
   if (wf.audioFFT_active) {
      w3_innerHTML('id-annotation-div',
         w3_div('w3-section w3-container',
            w3_text('w3-large|color:cyan', 'Audio FFT<br>'),
            w3_text('w3-small|color:cyan',
                  'Zoom waterfall not available<br>' +
                  (wf.no_wf?
                     'when \"no_wf\" URL option used.<br>'
                  :
                     ('on channels '+ wf_chans_real +'-'+ (rx_chans-1) +' of Kiwis<br>' +
                     'configured for '+ rx_chans +' channels.<br>')
                  )
            ),
            w3_text('w3-small|color:cyan',
               'For details see the Kiwi forum.'
            )
         )
      );
   }

/*
   if (rx_chan >= wf_chans) {
		var sw = canvas_annotation.width;
		var sh = canvas_annotation.height;
      var ctx = canvas_annotation.ctx;
		ctx.clearRect(0,0,sw,sh);
	   ctx.font = "18px sans-serif";
	   ctx.textBaseline = "middle";
	   ctx.textAlign = "left";
	   if (wf.audioFFT_active) {
	      var x = sw/8;
         var y = sh/2;
         var text = 'AudioFFT';
         w3_fillText(ctx, x, y, 'AudioFFT', 'cyan');
         y += 18;
         w3_fillText(ctx, x, y, '(zoom waterfall not available)', null, '14px sans-serif');
	   } else {
         var text =
            wf_chans?
               ('Waterfall not available for rx'+ rx_chan)
            :
               'Waterfall not allowed on this Kiwi';
         w3_fillText(ctx, sw/2, sh/2, text, 'black');
      }
   }
*/
}


////////////////////////////////
// mobile
////////////////////////////////

function mobile_init()
{
	// When a mobile device connects to a Kiwi while held in portrait orientation:
	// Remove top bar and minimize control panel if width < oldest iPad width (768px)
	// which should catch all iPhones but no iPads (iPhone X width = 414px).
	// Also scale control panel for small-screen tablets, e.g. 7" tablets with 600px portrait width.

	var mobile = owrx.mobile = ext_mobile_info();
   //console.log('$ wh='+ mobile.width +','+ mobile.height);
	
	// anything smaller than iPad: remove top bar and switch control panel to "off".
	if (mobile.small) {
	   toggle_or_set_hide_topbar(1);
	   optbar_focus('optbar-off', 'init');
	}
	
	// for narrow screen devices, i.e. phones and 7" tablets
	if (mobile.narrow) {
	   w3_hide('id-readme');   // don't show readme panel closed icon
	   
	   // remove top bar and band/label areas on phones
	   if (mobile.width < 600) {
	      toggle_or_set_hide_topbar(3);
	   }
	}
	
   owrx.last_mobile = {};     // force rescale first time
   owrx.rescale_cnt = owrx.rescale_cnt2 = 0;

	setInterval(function() {
      mobile = owrx.mobile = ext_mobile_info(owrx.last_mobile);
      owrx.last_mobile = mobile;

      //extint_news('Cwh='+ mobile.width +','+ mobile.height +' '+ mobile.orient_unchanged +
      //   '<br>r='+ owrx.rescale_cnt  +','+ owrx.rescale_cnt2 +' #'+ owrx.dseq);
      //owrx.dseq++;

      var el = w3_el('id-control');

	   if (mobile_laptop_test) {
         extint_news('whu='+ mobile.width +','+ mobile.height +','+ el.uiWidth +
            ' psn='+ mobile.isPortrait +','+ mobile.small +','+ mobile.narrow +' #'+ owrx.dseq);
         owrx.dseq++;
      }
   
      if (mobile.orient_unchanged) return;
      owrx.rescale_cnt++;

      if (mobile.narrow) {
         // scale control panel up or down to fit width of all narrow screens
         var scale = mobile.width / el.uiWidth * 0.95;
         el.style.transform = 'scale('+ scale.toFixed(2) +')';
         el.style.transformOrigin = 'bottom right';
         el.style.right = '0px';
         owrx.rescale_cnt2++;
      } else {
         el.style.transform = 'none';
         el.style.right = '10px';
      }
	}, 500);
}


////////////////////////////////
// waterfall / spectrum
////////////////////////////////

var waterfall_setup_done=0;
var waterfall_timer;
var waterfall_ms;

function waterfall_init()
{
   if (!okay_waterfall_init) {
      return;
   }
   
	init_canvas_container();

   wf.audioFFT_active = (rx_chan >= wf_chans);
	resize_waterfall_container(false);
	resize_canvases();
	panels_setup();
	ident_init();
	scale_setup();
	mkcolormap();
	bands_init();
	spectrum_init();
	dx_schedule_update();
	users_init(false);
	stats_init();
	check_top_bar_congestion();
	if (spectrum_show) setTimeout(spec_show, 2000);    // after control instantiation finishes
   
	audioFFT_setup();

	waterfall_ms = 900/wf_fps_max;
	waterfall_timer = window.setInterval(waterfall_dequeue, waterfall_ms);
	//console.log('waterfall_dequeue @ '+ waterfall_ms +' msec');
	
	if (shortcut.keys != '') setTimeout(keyboard_shortcut_url_keys, 3000);

   if (kiwi_isMobile() || mobile_laptop_test)
      mobile_init();

	waterfall_setup_done=1;
}

var dB_bands = [];

/*
var color_bands = [
	"#993333",
	"#9966ff", "#0066ff", "#00ccff", "#00ffcc", "#66ff33", "#ccff33", "#ffcc00", "#ff6600",
	"#ff0066", "#ff33cc", "#ff00ff", "#ffffff"
];
var color_bands_dB = [
	9999,
	-120,	-110,	-100,	-90,	-80,	-70,	-60,	-50,
	-40,	-30,	-20,	-10
];
*/

var redraw_spectrum_dB_scale = false;
var spectrum_colormap, spectrum_colormap_transparent;
var spectrum_update = 0, spectrum_last_update = 0;
var spectrum_image;

function spectrum_init()
{
	spectrum_colormap = spectrum_ctx.createImageData(1, spectrum_canvas.height);
	spectrum_colormap_transparent = spectrum_ctx.createImageData(1, spectrum_canvas.height);
	update_maxmindb_sliders();
	spectrum_dB_bands();
	var spectrum_update_rate_Hz = kiwi_isMobile()? 10:10;  // limit update rate since rendering spectrum is currently expensive
	//if (kiwi_isMobile()) alert('spectrum_update_rate_Hz = '+ spectrum_update_rate_Hz +' Hz');
	setInterval(function() { spectrum_update++ }, 1000 / spectrum_update_rate_Hz);

   spectrum_image = spectrum_ctx.createImageData(spectrum_canvas.width, spectrum_canvas.height)
   
   if (!wf.audioFFT_active && rx_chan >= wf_chans) {
		// clear entire spectrum canvas to black
		var sw = spectrum_canvas.width;
		var sh = spectrum_canvas.height;
		spectrum_ctx.fillStyle = "black";
		spectrum_ctx.fillRect(0,0,sw,sh);
		
	   spectrum_ctx.font = "18px sans-serif";
      spectrum_ctx.fillStyle = "white";
      var text =
         wf_chans?
            ('Spectrum not available for rx'+ rx_chan)
         :
            'Spectrum not allowed on this Kiwi';
      var tw = spectrum_ctx.measureText(text).width;
      spectrum_ctx.fillText(text, sw/2-tw/2, sh/2);
   }

   kiwi_load_js(['extensions/colormap/colormap.js'], function() { colormap_init(); });
}

// based on WF max/min range, compute color banding each 10 dB for spectrum display
function spectrum_dB_bands()
{
	dB_bands = [];
	var i=0;
	//var color_shift_dB = -8;	// give a little floor room to the spectrum colormap
	var color_shift_dB = -12;	// give a little floor room to the spectrum colormap
	var s_maxdb = maxdb, s_mindb = mindb;

	// prevent an illegal configuration of mindb >= maxdb causing code below
	// to loop infinitely (i.e. s_full_scale = 0 => / 0)
	if (s_mindb >= s_maxdb) {
	   s_maxdb = -10;
	   s_mindb = -110;
	}

	var s_full_scale = s_maxdb - s_mindb;
	var barmax = s_maxdb, barmin = s_mindb + color_shift_dB;
	var rng = barmax - barmin;
	rng = rng? rng : 1;	// can't be zero
	//console.log("DB barmax="+barmax+" barmin="+barmin+" s_maxdb="+s_maxdb+" s_mindb="+s_mindb);
	var last_norm = 0;

   var anti_looping = 0;
	for (var dB = Math.floor(s_maxdb/10)*10; (s_mindb-dB) < 10; dB -= 10) {
		var norm = 1 - ((dB - s_mindb) / s_full_scale);
		var cmi = Math.round((dB - barmin) / rng * 255);
		var color = color_map[cmi];
		var color_transparent = color_map_transparent[cmi];
		var color_name = '#'+(color >>> 8).toString(16).leadingZeros(6);
		dB_bands[i] = { dB:dB, norm:norm, color:color_name };
		
		var ypos = function(norm) { return Math.round(norm * spectrum_canvas.height) }
		for (var y = ypos(last_norm); y < ypos(norm); y++) {
			for (var j=0; j<4; j++) {
				spectrum_colormap.data[y*4+j] = ((color>>>0) >> ((3-j)*8)) & 0xff;
				spectrum_colormap_transparent.data[y*4+j] = ((color_transparent>>>0) >> ((3-j)*8)) & 0xff;
			}
			if (anti_looping++ > 8192) break;
		}
		//console.log("DB"+i+' '+dB+' norm='+norm+' last_norm='+last_norm+' cmi='+cmi+' '+color_name+' sh='+spectrum_canvas.height);
		last_norm = norm;
		
		i++;
      if (anti_looping++ > 8192) break;
	}

	redraw_spectrum_dB_scale = true;
	w3_call('colormap_aper');
}

function spectrum_tooltip_update(evt, clientX, clientY)
{
	var target = (evt.target == spectrum_dB || evt.currentTarget == spectrum_dB || evt.target == spectrum_dB_ttip || evt.currentTarget == spectrum_dB_ttip);
	//console.log('CD '+ target +' x='+ clientX +' tgt='+ evt.target.id +' ctg='+ evt.currentTarget.id);
	//if (kiwi_isMobile()) alert('CD '+ tf +' x='+ clientX +' tgt='+ evt.target.id +' ctg='+ evt.currentTarget.id);

	if (target) {
		//event_dump(evt, 'SPEC');
		
		// This is a little tricky. The tooltip text span must be included as an event target so its position will update when the mouse
		// is moved upward over it. But doing so means when the cursor goes below the bottom of the tooltip container, the entire
		// spectrum div in this case, having included the tooltip text span will cause it to be re-positioned again. And the hover
		// doesn't go away unless the mouse is moved quickly. So to stop this we need to manually detect when the mouse is out of the
		// tooltip container and stop updating the tooltip text position so the hover will end.
		
		if (clientY >= 0 && clientY < height_spectrum_canvas) {
			spectrum_dB_ttip.style.left = px(clientX);
			spectrum_dB_ttip.style.bottom = px(200 + 10 - clientY);
			var dB = (((height_spectrum_canvas - clientY) / height_spectrum_canvas) * full_scale) + mindb;
			spectrum_dB_ttip.innerHTML = dB.toFixed(0) +' dBm';
		}
	}
}

var waterfall_dont_scale=0;
var need_maxmindb_update = false;
var need_clear_wf_sp_avg = false;

var need_clear_specavg = false, clear_specavg = true;
var specavg = [], specpeak = [];

var need_clear_wfavg = false, clear_wfavg = true;
var wfavg = [];

// amounts empirically determined
var wf_swallow_samples = [ 2, 4, 8, 18 ];    // for zoom: 11, 12, 13, 14
var x_bin_server_last, wf_swallow = 0;

function waterfall_add(data_raw, audioFFT)
{
   var x, y;
	if (data_raw == null) return;
	//var canvas = wf_canvases[0];
	var canvas = wf_cur_canvas;
	if (canvas == null) return;
	
	var data_arr_u8, data, decomp_data;
   var w = wf_fft_size;
	
	if (audioFFT == 0) {
      var u32View = new Uint32Array(data_raw, 4, 3);
      var x_bin_server = u32View[0];		// bin & zoom from server at time data was queued
      var u32 = u32View[1];
      if (kiwi_gc_wf) u32View = null;	// gc
      var x_zoom_server = u32 & 0xffff;
      var flags = (u32 >> 16) & 0xffff;
      var wf_flags = { COMPRESSED:1 };
   
      data_arr_u8 = new Uint8Array(data_raw, 16);	// unsigned dBm values, converted to signed later on
      var bytes = data_arr_u8.length;
   
      // when caught up, update the max/min db so lagging w/f data doesn't use wrong (newer) zoom correction
      if (need_maxmindb_update && zoom_level == x_zoom_server) {
         update_maxmindb_sliders();
         need_maxmindb_update = false;
      }
   
      // when caught up, clear spectrum using new data
      if (x_bin == x_bin_server && zoom_level == x_zoom_server) {
         if (need_clear_wf_sp_avg || need_clear_specavg) clear_specavg = true;
         if (need_clear_wf_sp_avg || need_clear_wfavg)   clear_wfavg = true;
         need_clear_wf_sp_avg = need_clear_wfavg = need_clear_specavg = false;
      }
      
      if (flags & wf_flags.COMPRESSED) {
         decomp_data = new Uint8Array(bytes*2);
         var wf_adpcm = { index:0, previousValue:0 };
         decode_ima_adpcm_e8_u8(data_arr_u8, decomp_data, bytes, wf_adpcm);
         var ADPCM_PAD = 10;
         data = decomp_data.subarray(ADPCM_PAD);
      } else {
         data = data_arr_u8;
      }
      
      // When zoom level is too high there is a glich in WF DDC data.
      // Swallow a few WF samples in that case (amount is zoom level dependent).
      if (wf_swallow) {
         wf_swallow--;
         return;
      }
      if (x_bin_server != x_bin_server_last) {
         x_bin_server_last = x_bin_server;
         if (zoom_level >= 11) {
            wf_swallow = wf_swallow_samples[zoom_level-11];
            if (wf_fps != wf_fps_max) {
               wf_swallow = Math.round(wf_swallow * wf_fps / wf_fps_max);
               //console.log('# wf_fps='+ wf_fps +' wf_swallow_samples='+ wf_swallow_samples[zoom_level-11] +' wf_swallow='+ wf_swallow);
            }
         }
      }
   } else {
      data = data_raw;     // unsigned dB values, converted to signed later on
      if (need_clear_specavg) {
         clear_specavg = true;
         need_clear_specavg = false;
      }
   }
	
	var sw, sh, tw=25;
	var need_spectrum_update = false;
	
	if (spectrum_display && spectrum_update != spectrum_last_update) {
		spectrum_last_update = spectrum_update;
		need_spectrum_update = true;

		// clear entire spectrum canvas to black
		sw = spectrum_canvas.width-tw;
		sh = spectrum_canvas.height;
		spectrum_ctx.fillStyle = "black";
		spectrum_ctx.fillRect(0,0,sw,sh);
		
		// draw lines every 10 dB
		// spectrum data will overwrite
		spectrum_ctx.fillStyle = "lightGray";
		for (var i=0; i < dB_bands.length; i++) {
			var band = dB_bands[i];
			y = Math.round(band.norm * sh);
			spectrum_ctx.fillRect(0,y,sw,1);
		}

		if (clear_specavg) {
			for (x=0; x<sw; x++) {
				specavg[x] = color_index(data[x]);
			}
			clear_specavg = false;
			spectrum_peak_clear = true;
		}
		
		if (spectrum_peak_clear) {
			for (x=0; x<sw; x++) {
				specpeak[x] = 0;
			}
			spectrum_peak_clear = false;
		}
		
		// if necessary, draw scale on right side
		if (redraw_spectrum_dB_scale) {
		
			// set sidebar background where the dB text will go
			/*
			spectrum_ctx.fillStyle = "black";
			spectrum_ctx.fillRect(sw,0,tw,sh);
			*/
			for (x = sw; x < spectrum_canvas.width; x++) {
				spectrum_ctx.putImageData(spectrum_colormap_transparent, x, 0, 0, 0, 1, sh);
			}
			
			// the dB scale text
			spectrum_ctx.fillStyle = "white";
			for (var i=0; i < dB_bands.length; i++) {
				var band = dB_bands[i];
				y = Math.round(band.norm * sh);
				spectrum_ctx.fillText(band.dB, sw+3, y-4);
				//console.log("SP x="+sw+" y="+y+' '+dB);
			}
			redraw_spectrum_dB_scale = false;
		}
	}
	
	// Add line to waterfall image			
	
	var oneline_image = canvas.oneline_image;
	var z, color;
	
   // spectrum
	if (spectrum_display && need_spectrum_update) {
      spectrum_ctx.fillStyle = 'hsl(180, 100%, 70%)';

		for (x=0; x<sw; x++) {
         z = color_index(wf_gnd? wf_gnd_value : data[x]);

         switch (spec_filter) {
         
         case wf_sp_menu_e.IIR:
            // non-linear spectrum filter from Rocky (Alex, VE3NEA)
            // see http://www.dxatlas.com/rocky/advanced.asp
            
            var iir_gain = 1 - Math.exp(-sp_param * z/255);
            if (iir_gain <= 0.01) iir_gain = 0.01;    // enforce minimum decay rate
            var z1 = specavg[x];
            z1 = z1 + iir_gain * (z - z1);
            if (z1 > 255) z1 = 255; if (z1 < 0) z1 = 0;
            z = specavg[x] = z1;
            break;
            
         case wf_sp_menu_e.MMA:
            if (z > 255) z = 255; if (z < 0) z = 0;
            specavg[x] = ((specavg[x] * (sp_param-1)) + z) / sp_param;
            z = specavg[x];
            break;
            
         case wf_sp_menu_e.EMA:
            if (z > 255) z = 255; if (z < 0) z = 0;
            specavg[x] += (z - specavg[x]) / sp_param;
            z = specavg[x];
            break;
            
         case wf_sp_menu_e.OFF:
         default:
            if (z > 255) z = 255; if (z < 0) z = 0;
            break;
         }

         if (z > specpeak[x]) specpeak[x] = z; 

         // draw the spectrum based on the spectrum colormap which should
         // color the 10 dB bands appropriately
         y = Math.round((1 - z/255) * sh);

         if (spectrum_slow_dev) {
            spectrum_ctx.fillRect(x,y, 1,sh-y);
         } else {
            // fixme: could optimize amount of data moved like smeter
            spectrum_ctx.putImageData(spectrum_colormap, x,0, 0,y, 1,sh-y+1);
         }
		}
		
		if (spectrum_peak) {
         spectrum_ctx.lineWidth = 1;
	      //spectrum_ctx.fillStyle = 'yellow';
         spectrum_ctx.strokeStyle = 'yellow';
         spectrum_ctx.beginPath();
         y = Math.round((1 - specpeak[0]/255) * sh) - 1;
         spectrum_ctx.moveTo(0,y);
         for (x=1; x<sw; x++) {
            y = Math.round((1 - specpeak[x]/255) * sh) - 1;
            spectrum_ctx.lineTo(x,y);
         }
         spectrum_ctx.globalAlpha = 0.55;
         //spectrum_ctx.fill();
         spectrum_ctx.stroke();
         spectrum_ctx.globalAlpha = 1;
      }
	}

   // waterfall
   for (x=0; x<w; x++) {
      z = color_index(wf_gnd? wf_gnd_value : data[x], wf.sqrt);
      
      switch (wf_filter) {
      
      case wf_sp_menu_e.IIR:
         // non-linear spectrum filter from Rocky (Alex, VE3NEA)
         // see http://www.dxatlas.com/rocky/advanced.asp
         
         if (clear_wfavg) wfavg[x] = z;
         var iir_gain = 1 - Math.exp(-wf_param * z/255);
         if (iir_gain <= 0.01) iir_gain = 0.01;    // enforce minimum decay rate
         var z1 = wfavg[x];
         z1 = z1 + iir_gain * (z - z1);
         if (z1 > 255) z1 = 255; if (z1 < 0) z1 = 0;
         wfavg[x] = z1;
         z = Math.round(wfavg[x]);
         break;
         
      case wf_sp_menu_e.MMA:
         if (clear_wfavg) wfavg[x] = z;
         wfavg[x] = ((wfavg[x] * (wf_param-1)) + z) / wf_param;
         z = Math.round(wfavg[x]);
         break;
         
      case wf_sp_menu_e.EMA:
         if (clear_wfavg) wfavg[x] = z;
         wfavg[x] += (z - wfavg[x]) / wf_param;
         //if (x == 400) console.log('old='+ old +' clr='+ clear_wfavg +' z='+ z +' new='+ wfavg[x]);
         z = Math.round(wfavg[x]);
         break;
         
      case wf_sp_menu_e.OFF:
      default:
         break;
      }

      /*
      color = color_map[z];

      for (var i=0; i<4; i++) {
         oneline_image.data[x*4+i] = ((color>>>0) >> ((3-i)*8)) & 0xff;
      }
      */
      oneline_image.data[x*4  ] = color_map_r[z];
      oneline_image.data[x*4+1] = color_map_g[z];
      oneline_image.data[x*4+2] = color_map_b[z];
      oneline_image.data[x*4+3] = 0xff;
   }
   
   if (clear_wfavg) clear_wfavg = false;
	
	// debug shear problems
	/*
   if (x_bin != x_bin_server) {
      for (x=450; x<456; x++) {
         oneline_image.data[x*4  ] = 255;
         oneline_image.data[x*4+1] = 0;
         oneline_image.data[x*4+2] = 0;
      }
   }
   if (x_bin_server_last != x_bin_server) {
      for (x=0; x<1024; x++) {
         x_bin_server_last = x_bin_server;
         oneline_image.data[x*4  ] = wf_swallow? 255:0;
         oneline_image.data[x*4+1] = 255;
         oneline_image.data[x*4+2] = 0;
      }
   }
   */

	canvas.ctx.putImageData(oneline_image, 0, wf_canvas_actual_line);
	
	// NB: can't use isDefined() here
	if (audioFFT == 0 && typeof(IBP_scan_plot) != 'undefined') IBP_scan_plot(oneline_image);
	
	// If data from server hasn't caught up to our panning or zooming then fix it.
	// This code is tricky and full of corner-cases.
	
	var fixup = false;
	if (audioFFT == 0) {
      var pixel_dx;
      if (sb_trace) console.log('WF fixup bin='+x_bin+'/'+x_bin_server+' z='+zoom_level+'/'+x_zoom_server);
   
      // need to fix zoom before fixing the pan
      if (zoom_level != x_zoom_server) {
         var dz = zoom_level - x_zoom_server;
         var out = dz < 0;
         var dbins = out? (x_bin_server - x_bin) : (x_bin - x_bin_server);
         var pixel_dx = bins_to_pixels(2, dbins, out? zoom_level:x_zoom_server);
         if (sb_trace)
            console.log("WF Z fix z"+x_zoom_server+'>'+zoom_level+' out='+out+' b='+x_bin+'/'+x_bin_server+'/'+dbins+" px="+pixel_dx);
         waterfall_zoom(canvas, dz, wf_canvas_actual_line, pixel_dx);
         
         // x_bin_server has changed now that we've zoomed
         x_bin_server += out? -dbins : dbins;
         if (sb_trace) console.log('WF z fixed');
         fixup = true;
      }
      
      if (x_bin != x_bin_server) {
         pixel_dx = bins_to_pixels(3, x_bin - x_bin_server, zoom_level);
         if (sb_trace)
            console.log("WF bin fix L="+wf_canvas_actual_line+" xb="+x_bin+" xbs="+x_bin_server+" pdx="+pixel_dx);
         waterfall_pan(canvas, wf_canvas_actual_line, pixel_dx);
         if (sb_trace) console.log('WF bin fixed');
         fixup = true;
      }
   
      if (sb_trace && x_bin == x_bin_server && zoom_level == x_zoom_server) {
         console.log('--WF FIXUP ALL DONE--');
         sb_trace=0;
      }
   }
   
   if (wf.need_autoscale > 1) wf.need_autoscale--;
   
	if (wf.need_autoscale == 1 && !fixup) {
	   var pwr_dBm = [];
	   
	   // FIXME: for audio FFT need to limit autoscale sampling to passband portion of FFT
	   // (the current algorithm at least)
      var autoscale = wf.audioFFT_active? data.slice(256, 768) : data;
	   var len = autoscale.length;
	   
	   // convert from transmitted values to true dBm
	   for (var i = 0; i < len; i++) {
	      pwr_dBm[i] = dB_wire_to_dBm(autoscale[i]);
      }
	   pwr_dBm.sort(function(a,b) {return a-b});
	   var noise = pwr_dBm[Math.floor(0.5 * len)];
	   var signal = pwr_dBm[Math.floor(0.98 * len)];
	   //console_log_dbgUs('# autoscale min='+ pwr_dBm[0] +' noise='+ noise +' signal='+ signal +' max='+ pwr_dBm[len-1]);

	   var _10 = pwr_dBm[Math.floor(0.10 * len)];
	   var _20 = pwr_dBm[Math.floor(0.20 * len)];
	   //console_log_dbgUs('# autoscale min='+ pwr_dBm[0] +' 5%='+ noise +' 10%='+ _10 +' 20%='+ _20 +' 98%='+ signal +' max='+ pwr_dBm[len-1]);
	   signal += 30;
	   if (signal < -80) signal = -80;
      noise -= 10;

      setmaxdb(1, signal);
      setmindb(1, noise);
      update_maxmindb_sliders();
	   wf.need_autoscale = 0;
	}

	wf_canvas_actual_line--;
	wf_shift_canvases();
	if (wf_canvas_actual_line < 0) add_canvas();
	
	if (kiwi_gc_wf) canvas = data_raw = data_arr_u8 = decomp_data = data = null;	// gc
}


//
// NB The panning and zooming code is tricky and full of corner-cases.
// It *still* probably has bugs.
//

function waterfall_pan(cv, line, dx)
{
	var ctx = cv.ctx;
	var y, w, h;
	var w0 = cv.width;
	
	if (line == -1) {
		y = 0;
		h = cv.height;
	} else {
		y = line;
		h = 1;
	}

	// fillRect() does not give expected result if coords are negative, so clip first
	var clip = function(v, min, max) { return ((v < min)? min : ((v > max)? max : v)); };

	try {
		if (sb_trace) console.log('waterfall_pan h='+ h +' dx='+ dx);
		
		if (dx < 0) {		// pan right (toward higher freqs)
			dx = -dx;
			w = w0-dx;
			if (sb_trace) console.log('PAN-L w='+ w +' dx='+ dx);
			if (w > 0) ctx.drawImage(cv, 0,y,w,h, dx,y,w,h);
			ctx.fillStyle = "Black";
			if (sb_trace) ctx.fillStyle = (line==-1)? "Lime":"Red";
			fx = clip(dx, 0, w0);
			ctx.fillRect(0,y, fx,h);
		} else {				// pan left (toward lower freqs)
			w = w0-dx;
			if (sb_trace) console.log('PAN-R w='+ w +' dx='+ dx);
			if (w > 0) ctx.drawImage(cv, dx,y,w,h, 0,y,w,h);
			ctx.fillStyle = "Black";
			if (sb_trace) ctx.fillStyle = (line==-1)? "Lime":"Red";
			fx = clip(w, 0, w0);
			ctx.fillRect(fx,y, w0,h);
		}
	} catch(ex) {
		console.log('EX WFPAN '+ ex.toString() +' dx='+ dx +' y='+ y +' w='+ w +' h='+ h);
	}
}

// have to keep track of fractional pixels while panning
var last_pixels_frac = 0;

function waterfall_pan_canvases(bins)
{
	if (!bins) return;
   if (wf.audioFFT_active) return;
	
	var x_obin = x_bin;
	x_bin += bins;
	x_bin = clamp_xbin(x_bin);
	//console.log("PAN lpf="+last_pixels_frac);
	var f_dx = bins_to_pixels_frac(4, x_bin - x_obin, zoom_level) + last_pixels_frac;		// actual movement allowed due to clamping
	var i_dx = Math.round(f_dx);
	last_pixels_frac = f_dx - i_dx;
	if (sb_trace) console.log("PAN-CAN z="+zoom_level+" xb="+x_bin+" db="+(x_bin - x_obin)+" f_dx="+f_dx+" i_dx="+i_dx+" lpf="+last_pixels_frac);
	if (!i_dx) return;

	wf_canvases.forEach(function(cv) {
		waterfall_pan(cv, -1, i_dx);
	});
	
	wf_send("SET zoom="+ zoom_level +" start="+ x_bin);
	
	mkscale();
	need_clear_wf_sp_avg = true;
	dx_schedule_update();
   extint_environment_changed( { waterfall_pan:1 } );

	// reset "select band" menu if freq is no longer inside band
	//console.log('page_scroll PBV='+ passband_visible() +' freq_car_Hz='+ freq_car_Hz);
	if (passband_visible() < 0)
		check_band(true);
}

function waterfall_zoom(cv, dz, line, x)
{
	var ctx = cv.ctx;
	var w = cv.width;
	var zf = 1 << Math.abs(dz);
	var pw = w / zf;
	var fx;
	var y, h;
	
	// fillRect() does not give expected result if coords are negative, so clip first
	var clip = function(v, min, max) { return ((v < min)? min : ((v > max)? max : v)); };
	
	if (line == -1) {
		y = 0;
		h = cv.height;
	} else {
		y = line;
		h = 1;
	}

	try {
		if (sb_trace) console.log('waterfall_zoom w='+ w +' h='+ h +' pw='+ pw +' zf='+ zf);

		if (dz < 0) {		// zoom out
			if (sb_trace) console.log('WFZ-out srcX=0/'+ w +' dstX='+ x +'/'+ (x+pw) +' (pw='+ pw +')');
			
			ctx.drawImage(cv, 0,y,w,h, x,y,pw,h);
			ctx.fillStyle = "Black";
			if (sb_trace) {
				console.log('chocolate 0:'+ x);
				ctx.fillStyle = "chocolate";
			}
			fx = clip(x, 0, w);
			ctx.fillRect(0,y, fx,y+h);
			if (sb_trace) {
				console.log('brown '+ (x+pw) +':'+ w);
				ctx.fillStyle = "brown";
			}
			fx = clip(x+pw, 0, w);
			ctx.fillRect(fx,y, w,y+h);
		} else {			// zoom in
			if (w != 0) {
				if (sb_trace) console.log('WFZ-in srcX='+ x +'/'+ (x+pw) +'(pw='+ pw +') dstX=0/'+ w);
				var fill_hi = false, fill_lo = false;
				if ((x+pw) > w) {
					fx = Math.round((w-x) * zf);
					if (sb_trace)
						console.log('CLAMP HI fx='+ fx);
					fill_hi = true;
				}
				if (x < 0) {
					fx = Math.round(-x * zf);
					if (sb_trace)
						console.log('CLAMP LO fx='+ fx);
					fill_lo = true;
				}
				
				ctx.drawImage(cv, x,y,pw,h, 0,y,w,h);
				ctx.fillStyle = "Black";
				if (sb_trace) ctx.fillStyle = "deepPink";
				if (fill_hi) ctx.fillRect(fx,y, w,y+h);
				if (fill_lo) ctx.fillRect(0,y, fx,y+h);
			}
		}
	} catch(ex) {
		console.log('EX WFZ '+ ex.toString() +' dz='+ dz +' x='+ x +' y='+ y +' w='+ w +' h='+ h);
	}
}

function waterfall_zoom_canvases(dz, x)
{
	if (sb_trace) console.log("ZOOM-CAN z"+zoom_level+" xb="+x_bin+" x="+x);

	wf_canvases.forEach(function(cv) {
		waterfall_zoom(cv, dz, -1, x);
	});
	
	need_clear_wf_sp_avg = true;
}

// window:
//		top container
//		non-waterfall container
//		waterfall container

function waterfall_height()
{
	var top_height = html("id-top-container").clientHeight;
	var non_waterfall_height = html("id-non-waterfall-container").clientHeight;
	var wf_height = window.innerHeight - top_height - non_waterfall_height;
	//console.log('## waterfall_height: wf_height='+ wf_height +' winh='+ window.innerHeight +' th='+ top_height +' nh='+ non_waterfall_height);
	return wf_height;
}

// resize_waterfall_container() can be called repeatedly while top photo sliding animation is ongoing.
// With certain screen sizes it is possible for wf_height to be negative for a period of time, so very
// important to set waterfall_scrollable_height = 0 in that case.

function resize_waterfall_container(check_init)
{
	if (check_init && !waterfall_setup_done) return;

	var wf_height = waterfall_height();

	if (wf_height >= 0) {
	
	   // canvas_annotation has to track canvas_container height so as not to generate undesired mouseout events
		canvas_annotation.style.height = canvas_container.style.height = px(wf_height);
		waterfall_scrollable_height = wf_height * 3;

      // Don't change the height because that clears the canvas.
      // Instead just pick a large initial height value and depend on the draw clipping.
		//canvas_annotation.height = wf_height;
		//canvas_annotation.style.height = px(wf_height);
	} else {
		waterfall_scrollable_height = 0;
	}

	//console.log('## wf_h='+ wf_height +' wsh='+ waterfall_scrollable_height);
}

var waterfall_delay = 0;
var waterfall_queue = [];
var waterfall_last_add = 0;

function waterfall_add_queue(what, ws, firstChars)
{
   if (firstChars == 'DAT') {
      var u8View = new Uint8Array(what, 4);
      var cmd = u8View[0];
      if (cmd == 0) {
         for (var i = 0; i < 3*256; i++) {
            downloaded_colormap[i] = u8View[i+1];
         }
         mkcolormap();
         console.log('W/F DAT downloaded_colormap');
      } else
         console.log('W/F DAT unknown cmd='+ cmd);
      return;
   }
   
	var u32View = new Uint32Array(what, 4, 3);
	var seq = u32View[2];
	if (kiwi_gc_wf) u32View = null;	// gc

	var now = Date.now();
	var spacing = waterfall_last_add? (now - waterfall_last_add) : 0;
	waterfall_last_add = now;

	waterfall_queue.push({ data:what, audioFFT:0, seq:seq, spacing:spacing });
	if (kiwi_gc_wf) what = null;	// gc
}

var init_zoom_set = false;
var waterfall_last_out = 0;
var wf_dq_onesec = 0;

function waterfall_dequeue()
{
	/*
      wf_dq_onesec += waterfall_ms;
      if (wf_dq_onesec >= 1000) {
         console.log('WF Q='+ waterfall_queue.length);
         wf_dq_onesec = 0;
      }
	*/
	
	// demodulator must have been initialized before calling zoom_step()
	if (!init_zoom_set && demodulators[0]) {
		init_zoom = parseInt(init_zoom);
		if (init_zoom < 0 || init_zoom > zoom_levels_max) init_zoom = 0;
		//console.log("### init_zoom="+init_zoom);
		zoom_step(ext_zoom.ABS, init_zoom);
		init_zoom_set = true;
	}

	if (!waterfall_setup_done || waterfall_queue.length == 0) return;
	
	// synchronize waterfall to audio
	while (waterfall_queue.length != 0) {

		var seq = waterfall_queue[0].seq;
		var target = audio_ext_sequence + waterfall_delay;
		if (seq > target) {
			//console.log('SEQ too soon: s'+ seq +' > t'+ target +' ('+ (seq - target) +')');
			return;		// too soon
		}

		var now = Date.now();
		if (seq == audio_ext_sequence && now < (waterfall_last_out + waterfall_queue[0].spacing)) {
			//console.log('SEQ need spacing');
			//console.log('SEQ need spacing: s'+ seq +' sp'+ waterfall_queue[0].spacing +' ('+ (now - waterfall_last_out) +')');
			return;		// need spacing
		}
	
		// seq < audio_ext_sequence or seq == audio_ext_sequence and spacing is okay
		waterfall_last_out = now;
		
		var data = waterfall_queue[0].data;
		if (kiwi_gc_wf) waterfall_queue[0].data = null;	// gc
		var audioFFT = waterfall_queue[0].audioFFT;
		waterfall_queue.shift();
		waterfall_add(data, audioFFT);
		if (kiwi_gc_wf) data = null;	// gc
	}
}

var downloaded_colormap = new Uint8Array(3*256);

// google turbo color_map, grab from here: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f
turbo_colormap_data = [0.18995,0.07176,0.23217,0.19483,0.08339,0.26149,0.19956,0.09498,0.29024,0.20415,0.10652,0.31844,0.20860,0.11802,0.34607,0.21291,0.12947,0.37314,0.21708,0.14087,0.39964,0.22111,0.15223,0.42558,0.22500,0.16354,0.45096,0.22875,0.17481,0.47578,0.23236,0.18603,0.50004,0.23582,0.19720,0.52373,0.23915,0.20833,0.54686,0.24234,0.21941,0.56942,0.24539,0.23044,0.59142,0.24830,0.24143,0.61286,0.25107,0.25237,0.63374,0.25369,0.26327,0.65406,0.25618,0.27412,0.67381,0.25853,0.28492,0.69300,0.26074,0.29568,0.71162,0.26280,0.30639,0.72968,0.26473,0.31706,0.74718,0.26652,0.32768,0.76412,0.26816,0.33825,0.78050,0.26967,0.34878,0.79631,0.27103,0.35926,0.81156,0.27226,0.36970,0.82624,0.27334,0.38008,0.84037,0.27429,0.39043,0.85393,0.27509,0.40072,0.86692,0.27576,0.41097,0.87936,0.27628,0.42118,0.89123,0.27667,0.43134,0.90254,0.27691,0.44145,0.91328,0.27701,0.45152,0.92347,0.27698,0.46153,0.93309,0.27680,0.47151,0.94214,0.27648,0.48144,0.95064,0.27603,0.49132,0.95857,0.27543,0.50115,0.96594,0.27469,0.51094,0.97275,0.27381,0.52069,0.97899,0.27273,0.53040,0.98461,0.27106,0.54015,0.98930,0.26878,0.54995,0.99303,0.26592,0.55979,0.99583,0.26252,0.56967,0.99773,0.25862,0.57958,0.99876,0.25425,0.58950,0.99896,0.24946,0.59943,0.99835,0.24427,0.60937,0.99697,0.23874,0.61931,0.99485,0.23288,0.62923,0.99202,0.22676,0.63913,0.98851,0.22039,0.64901,0.98436,0.21382,0.65886,0.97959,0.20708,0.66866,0.97423,0.20021,0.67842,0.96833,0.19326,0.68812,0.96190,0.18625,0.69775,0.95498,0.17923,0.70732,0.94761,0.17223,0.71680,0.93981,0.16529,0.72620,0.93161,0.15844,0.73551,0.92305,0.15173,0.74472,0.91416,0.14519,0.75381,0.90496,0.13886,0.76279,0.89550,0.13278,0.77165,0.88580,0.12698,0.78037,0.87590,0.12151,0.78896,0.86581,0.11639,0.79740,0.85559,0.11167,0.80569,0.84525,0.10738,0.81381,0.83484,0.10357,0.82177,0.82437,0.10026,0.82955,0.81389,0.09750,0.83714,0.80342,0.09532,0.84455,0.79299,0.09377,0.85175,0.78264,0.09287,0.85875,0.77240,0.09267,0.86554,0.76230,0.09320,0.87211,0.75237,0.09451,0.87844,0.74265,0.09662,0.88454,0.73316,0.09958,0.89040,0.72393,0.10342,0.89600,0.71500,0.10815,0.90142,0.70599,0.11374,0.90673,0.69651,0.12014,0.91193,0.68660,0.12733,0.91701,0.67627,0.13526,0.92197,0.66556,0.14391,0.92680,0.65448,0.15323,0.93151,0.64308,0.16319,0.93609,0.63137,0.17377,0.94053,0.61938,0.18491,0.94484,0.60713,0.19659,0.94901,0.59466,0.20877,0.95304,0.58199,0.22142,0.95692,0.56914,0.23449,0.96065,0.55614,0.24797,0.96423,0.54303,0.26180,0.96765,0.52981,0.27597,0.97092,0.51653,0.29042,0.97403,0.50321,0.30513,0.97697,0.48987,0.32006,0.97974,0.47654,0.33517,0.98234,0.46325,0.35043,0.98477,0.45002,0.36581,0.98702,0.43688,0.38127,0.98909,0.42386,0.39678,0.99098,0.41098,0.41229,0.99268,0.39826,0.42778,0.99419,0.38575,0.44321,0.99551,0.37345,0.45854,0.99663,0.36140,0.47375,0.99755,0.34963,0.48879,0.99828,0.33816,0.50362,0.99879,0.32701,0.51822,0.99910,0.31622,0.53255,0.99919,0.30581,0.54658,0.99907,0.29581,0.56026,0.99873,0.28623,0.57357,0.99817,0.27712,0.58646,0.99739,0.26849,0.59891,0.99638,0.26038,0.61088,0.99514,0.25280,0.62233,0.99366,0.24579,0.63323,0.99195,0.23937,0.64362,0.98999,0.23356,0.65394,0.98775,0.22835,0.66428,0.98524,0.22370,0.67462,0.98246,0.21960,0.68494,0.97941,0.21602,0.69525,0.97610,0.21294,0.70553,0.97255,0.21032,0.71577,0.96875,0.20815,0.72596,0.96470,0.20640,0.73610,0.96043,0.20504,0.74617,0.95593,0.20406,0.75617,0.95121,0.20343,0.76608,0.94627,0.20311,0.77591,0.94113,0.20310,0.78563,0.93579,0.20336,0.79524,0.93025,0.20386,0.80473,0.92452,0.20459,0.81410,0.91861,0.20552,0.82333,0.91253,0.20663,0.83241,0.90627,0.20788,0.84133,0.89986,0.20926,0.85010,0.89328,0.21074,0.85868,0.88655,0.21230,0.86709,0.87968,0.21391,0.87530,0.87267,0.21555,0.88331,0.86553,0.21719,0.89112,0.85826,0.21880,0.89870,0.85087,0.22038,0.90605,0.84337,0.22188,0.91317,0.83576,0.22328,0.92004,0.82806,0.22456,0.92666,0.82025,0.22570,0.93301,0.81236,0.22667,0.93909,0.80439,0.22744,0.94489,0.79634,0.22800,0.95039,0.78823,0.22831,0.95560,0.78005,0.22836,0.96049,0.77181,0.22811,0.96507,0.76352,0.22754,0.96931,0.75519,0.22663,0.97323,0.74682,0.22536,0.97679,0.73842,0.22369,0.98000,0.73000,0.22161,0.98289,0.72140,0.21918,0.98549,0.71250,0.21650,0.98781,0.70330,0.21358,0.98986,0.69382,0.21043,0.99163,0.68408,0.20706,0.99314,0.67408,0.20348,0.99438,0.66386,0.19971,0.99535,0.65341,0.19577,0.99607,0.64277,0.19165,0.99654,0.63193,0.18738,0.99675,0.62093,0.18297,0.99672,0.60977,0.17842,0.99644,0.59846,0.17376,0.99593,0.58703,0.16899,0.99517,0.57549,0.16412,0.99419,0.56386,0.15918,0.99297,0.55214,0.15417,0.99153,0.54036,0.14910,0.98987,0.52854,0.14398,0.98799,0.51667,0.13883,0.98590,0.50479,0.13367,0.98360,0.49291,0.12849,0.98108,0.48104,0.12332,0.97837,0.46920,0.11817,0.97545,0.45740,0.11305,0.97234,0.44565,0.10797,0.96904,0.43399,0.10294,0.96555,0.42241,0.09798,0.96187,0.41093,0.09310,0.95801,0.39958,0.08831,0.95398,0.38836,0.08362,0.94977,0.37729,0.07905,0.94538,0.36638,0.07461,0.94084,0.35566,0.07031,0.93612,0.34513,0.06616,0.93125,0.33482,0.06218,0.92623,0.32473,0.05837,0.92105,0.31489,0.05475,0.91572,0.30530,0.05134,0.91024,0.29599,0.04814,0.90463,0.28696,0.04516,0.89888,0.27824,0.04243,0.89298,0.26981,0.03993,0.88691,0.26152,0.03753,0.88066,0.25334,0.03521,0.87422,0.24526,0.03297,0.86760,0.23730,0.03082,0.86079,0.22945,0.02875,0.85380,0.22170,0.02677,0.84662,0.21407,0.02487,0.83926,0.20654,0.02305,0.83172,0.19912,0.02131,0.82399,0.19182,0.01966,0.81608,0.18462,0.01809,0.80799,0.17753,0.01660,0.79971,0.17055,0.01520,0.79125,0.16368,0.01387,0.78260,0.15693,0.01264,0.77377,0.15028,0.01148,0.76476,0.14374,0.01041,0.75556,0.13731,0.00942,0.74617,0.13098,0.00851,0.73661,0.12477,0.00769,0.72686,0.11867,0.00695,0.71692,0.11268,0.00629,0.70680,0.10680,0.00571,0.69650,0.10102,0.00522,0.68602,0.09536,0.00481,0.67535,0.08980,0.00449,0.66449,0.08436,0.00424,0.65345,0.07902,0.00408,0.64223,0.07380,0.00401,0.63082,0.06868,0.00401,0.61923,0.06367,0.00410,0.60746,0.05878,0.00427,0.59550,0.05399,0.00453,0.58336,0.04931,0.00486,0.57103,0.04474,0.00529,0.55852,0.04028,0.00579,0.54583,0.03593,0.00638,0.53295,0.03169,0.00705,0.51989,0.02756,0.00780,0.50664,0.02354,0.00863,0.49321,0.01963,0.00955,0.47960,0.01583,0.01055];

// adjusted so the overlaid white text of the spectrum scale doesn't get washed out
var spectrum_scale_color_map_transparency = 200;

var color_map = new Uint32Array(256);
var color_map_transparent = new Uint32Array(256);
var color_map_r = new Uint8Array(256);
var color_map_g = new Uint8Array(256);
var color_map_b = new Uint8Array(256);

function mkcolormap()
{
   var ccm;
   if (wf.cmap >= kiwi.cmap_e.custom_1)
      ccm = wf.custom_colormaps[wf.cmap - kiwi.cmap_e.custom_1];
   
	for (var i=0; i<256; i++) {
		var r0, g0, b0, s0, s1;
		var r, g, b;
		
		switch (wf.cmap) {
		
		case kiwi.cmap_e.kiwi:
			// new default
			if (i < 32) {
				r = 0; g = 0; b = i*255/31;
			} else if (i < 72) {
				r = 0; g = (i-32)*255/39; b = 255;
			} else if (i < 96) {
				r = 0; g = 255; b = 255-(i-72)*255/23;
			} else if (i < 116) {
				r = (i-96)*255/19; g = 255; b = 0;
			} else if (i < 184) {
				r = 255; g = 255-(i-116)*255/67; b = 0;
			} else {
				r = 255; g = 0; b = (i-184)*128/70;
			}
			break;

		case kiwi.cmap_e.CuteSDR:
			// old one from CuteSDR
			if (i<43) {
				r = 0; g = 0; b = i*255/43;
			} else if (i<87) {
				r = 0; g = (i-43)*255/43; b = 255;
			} else if (i<120) {
				r = 0; g = 255; b = 255-(i-87)*255/32;
			} else if (i<154) {
				r = (i-120)*255/33; g = 255; b = 0;
			} else if (i<217) {
				r = 255; g = 255-(i-154)*255/62; b = 0;
			} else {
				r = 255; g = 0; b = (i-217)*128/38;
			}
			break;

		case kiwi.cmap_e.greyscale:
			// greyscale
			black_level = 0.0;
			white_level = 48.0;
			var v = black_level + ((255 - black_level + white_level) * i/255);
			r = g = b = v;
			break;
			
		case kiwi.cmap_e.linear:
			var c_from = { r:255, g:0, b:255 };
			var c_to = { r:0, g:255, b:0 };
			var s = 1.0;
			r = c_from.r * (i/255) + c_to.r * ((255-i)/255); r = r * (s + (i/255) * (1-s));
			g = c_from.g * (i/255) + c_to.g * ((255-i)/255); g = g * (s + (i/255) * (1-s));
			b = c_from.b * (i/255) + c_to.b * ((255-i)/255); b = b * (s + (i/255) * (1-s));
			break;

		case kiwi.cmap_e.turbo:
			r = turbo_colormap_data[i * 3 + 0] * 255;
			g = turbo_colormap_data[i * 3 + 1] * 255;
			b = turbo_colormap_data[i * 3 + 2] * 255;
			break;
		
		case kiwi.cmap_e.SdrDx:
			/*
			   from: fyngyrz.com/sdrdxdoc/waterfall2apf.html
            0 0.0 0.0 0.0 
            45 0.0 0.0 0.25 
            60 0.0 0.0 0.5 
            75 1.0 1.0 0.0 
            90 1.0 0.0 0.0 
            105 1.0 1.0 1.0

            original above was too compressed, so what we use is expanded a bit:
            0 0.0 0.0 0.0 
            20 0.0 0.0 0.5 
            60 0.0 0.0 1.0 
            150 1.0 1.0 0.0 
            180 1.0 0.0 0.0 
            210 1.0 1.0 1.0
         */
         
			if (i <= 20) {
				r0 = 0; g0 = 0; b0 = 0;
				r = 0; g = 0; b = 0.5;
				s0 = 0;
				s1 = 20;
			} else
			if (i <= 60) {
				r0 = 0; g0 = 0; b0 = 0.5;
				r = 0; g = 0; b = 1.0;
				s0 = 21;
				s1 = 60;
			} else
			if (i <= 150) {
				r0 = 0; g0 = 0; b0 = 1.0;
				r = 1.0; g = 1.0; b = 0;
				s0 = 61;
				s1 = 150;
			} else
			if (i <= 180) {
				r0 = 1.0; g0 = 1.0; b0 = 0;
				r = 1.0; g = 0; b = 0;
				s0 = 151;
				s1 = 180;
			} else
			if (i <= 210) {
				r0 = 1.0; g0 = 0; b0 = 0;
				r = 1.0; g = 1.0; b = 1.0;
				s0 = 181;
				s1 = 210;
			} else {
				r0 = 1.0; g0 = 1.0; b0 = 1.0;
				r = 1.0; g = 1.0; b = 1.0;
				s0 = 211;
				s1 = 255;
			}

         var d = s1 - s0;
         var ni = i - s0;
         var f = ni / d;
		
         r = (r0 + ((r - r0) * f)) * 255;
         g = (g0 + ((g - g0) * f)) * 255;
         b = (b0 + ((b - b0) * f)) * 255;

         //if (wf.cmap == kiwi.cmap_e.SdrDx)
         //   console.log(i +' s0='+ s0 +' s1='+ s1 +' f='+ f.toFixed(3) +' r='+ r.toFixed(0) +' g='+ g.toFixed(0) +' b='+ b.toFixed(0));
			break;

		default:
		   /*
			r = downloaded_colormap[i * 3 + 0];
			g = downloaded_colormap[i * 3 + 1];
			b = downloaded_colormap[i * 3 + 2];
			*/
			
			r = ccm[i * 3 + 0];
			g = ccm[i * 3 + 1];
			b = ccm[i * 3 + 2];
			break;
		}
		
		r = Math.round(r); r = w3_clamp(r, 0, 255);
		g = Math.round(g); g = w3_clamp(g, 0, 255);
		b = Math.round(b); b = w3_clamp(b, 0, 255);

      // composite colormap used by spectrum
		color_map[i] = (r<<24) | (g<<16) | (b<<8) | 0xff;
		color_map_transparent[i] = (r<<24) | (g<<16) | (b<<8) | spectrum_scale_color_map_transparency;
		
		// component colormap for waterfall (also used by some extensions)
		color_map_r[i] = r;
		color_map_g[i] = g;
		color_map_b[i] = b;
	}
}

function dB_wire_to_dBm(db_value)
{
	// What is transmitted over the network are unsigned 55..255 values (compressed) which
	// correspond to -200..0 dBm. Convert here to back to <= 0 signed dBm.
	// Done this way because -127 is the smallest value in an int8 which isn't enough
	// to hold our smallest dBm value and also we don't expect dBm values > 0 to be needed.
	//
   // We map 0..-200 dBm to (u1_t) 255..55
   // If we map it the reverse way, (u1_t) 0..255 => 0..-255 dBm (which is more natural), then the
   // noise in the bottom bits due to the ADPCM compression will effect the high-order dBm bits
   // which is bad.
	
	if (db_value < 0) db_value = 0;
	if (db_value > 255) db_value = 255;
	var dBm = -(255 - db_value);
	return (dBm + cfg.waterfall_cal);
}

function color_index(db_value, sqrt)
{
   var dBm = dB_wire_to_dBm(db_value);
	if (dBm < mindb) dBm = mindb;
	if (dBm > maxdb) dBm = maxdb;
	var relative_value = dBm - mindb;

	var value_percent_default = relative_value/full_scale;
	var value_percent = value_percent_default;
	
	if (isDefined(sqrt)) {
      try {
         switch (+sqrt) {
      
         case 0:
         default:
            break;
         case 1:
            value_percent = Math.sqrt(value_percent_default);
            break;
         case 2:
            if (value_percent_default > 0.21 && value_percent_default < 0.5)
               value_percent = 0.2 + (4 + Math.log10(value_percent_default - 0.2)) * 0.09;
            break;
         case 3:
            if (value_percent_default > 0.31 && value_percent_default < 0.6)
               value_percent = 0.3 + (5 + Math.log10(value_percent_default - 0.3)) * 0.07;
            break;
         case 4:
            if (value_percent_default > 0.41 && value_percent_default < 0.7)
               value_percent = 0.4 + (6 + Math.log10(value_percent_default - 0.4)) * 0.055;
            break;
         }
      } catch(ex) {
         value_percent = value_percent_default;
      }
   }
	
	var i = value_percent * 255;
	i = Math.round(i);
	if (i < 0) i = 0;
	if (i > 255) i = 255;
	return i;
}


// waterfall_color_index_max_min() and color_index_max_min() used by iq_display.js and integrate.js

function waterfall_color_index_max_min(db_value, maxdb, mindb)
{
	// convert to negative-only signed dBm (i.e. -256 to -1 dBm)
	// done this way because -127 is the smallest value in an int8 which isn't enough
	db_value = -(255 - db_value);		
	
	if (db_value < mindb) db_value = mindb;
	if (db_value > maxdb) db_value = maxdb;
	var relative_value = db_value - mindb;
	var fullscale = maxdb - mindb;
	fullscale = fullscale? full_scale : 1;	// can't be zero
	var value_percent = relative_value / fullscale;
	
	var i = value_percent * 255;
	i = Math.round(i);
	if (i < 0) i = 0;
	if (i > 255) i = 255;
	return i;
}

function color_index_max_min(value, maxdb, mindb)
{
	if (value < mindb) value = mindb;
	if (value > maxdb) value = maxdb;
	var relative_value = value - mindb;
	var fullscale = maxdb - mindb;
	fullscale = fullscale? full_scale : 1;	// can't be zero
	var value_percent = relative_value / fullscale;
	
	var i = value_percent * 255;
	i = Math.round(i);
	if (i < 0) i = 0;
	if (i > 255) i = 255;
	return i;
}

/* not used
//var color_scale=[0xFFFFFFFF, 0x000000FF];
//var color_scale=[0x000000FF, 0x000000FF, 0x3a0090ff, 0x10c400ff, 0xffef00ff, 0xff5656ff];
//var color_scale=[0x000000FF, 0x000000FF, 0x534b37ff, 0xcedffaff, 0x8899a9ff,  0xfff775ff, 0xff8a8aff, 0xb20000ff];

//var color_scale=[ 0x000000FF, 0xff5656ff, 0xffffffff];

//2014-04-22
var color_scale=[0x2e6893ff, 0x69a5d0ff, 0x214b69ff, 0x9dc4e0ff,  0xfff775ff, 0xff8a8aff, 0xb20000ff];

function waterfall_mkcolor(db_value)
{
	if (db_value < mindb) db_value = mindb;
	if (db_value > maxdb) db_value = maxdb;
	var relative_value = db_value - mindb;
	var value_percent = relative_value/full_scale;
	
	percent_for_one_color=1/(color_scale.length-1);
	index=Math.floor(value_percent/percent_for_one_color);
	remain=(value_percent-percent_for_one_color*index)/percent_for_one_color;
	return color_between(color_scale[index+1],color_scale[index],remain);
}

function color_between(first, second, percent)
{
	output=0;
	for (var i=0;i<4;i++)
	{
		add = ((((first&(0xff<<(i*8)))>>>0)*percent) + (((second&(0xff<<(i*8)))>>>0)*(1-percent))) & (0xff<<(i*8));
		output |= add>>>0;
	}
	return output>>>0;
}
*/
	

////////////////////////////////
// audio FFT
////////////////////////////////

var fft = {
   init: false,
   comp_1x: false,
   audioFFT_dynload: {},

   offt: 0,
   i_re: 0,
   i_im: 0,
   o_re: 0,
   o_im: 0,
   window_512: [],
   window_1k: [],
   window_2k: [],
   pwr_dB: [],
   dBi: [],

   CUTESDR_MAX_VAL: 32767,
};

function audioFFT_setup()
{
   if (!wf.audioFFT_active) return;
   zoom_level = 0;

   if (wf.aper != kiwi.aper_e.auto) {
      var last_AF_max_dB = readCookie('last_AF_max_dB', maxdb);
      var last_AF_min_dB = readCookie('last_AF_min_dB', mindb_un);
      setmaxdb(1, last_AF_max_dB);
      setmindb(1, last_AF_min_dB);
      update_maxmindb_sliders();
   }

   // Hanning
   var window = function(i, nsamp) {
      return (0.5 - 0.5 * Math.cos((2 * Math.PI * i)/(nsamp-1)));
   };

   for (i = 0; i < 512; i++) fft.window_512[i] = window(i, 512);
   for (i = 0; i < 1024; i++) fft.window_1k[i] = window(i, 1024);
   for (i = 0; i < 2048; i++) fft.window_2k[i] = window(i, 2048);
}

function audioFFT_update()
{
   mkscale();
   dx_schedule_update();
   freq_link_update();
   w3_innerHTML('id-nav-optbar-wf', 'WF');
   freqset_select();

   // clear waterfall
   if (wf.audioFFT_clear_wf) {
      wf_canvases.forEach(function(cv) {
         cv.ctx.fillStyle = "Black";
         cv.ctx.fillRect(0,0, cv.width,cv.height);
      });
      need_clear_specavg = true;
      wf.audioFFT_clear_wf = false;
   
      // colormap auto
      if (wf.aper == kiwi.aper_e.auto) {
         if (wf.audioFFT_active) wf.need_autoscale = 16;    // delay a bit before autoscaling
      }
   }
}

function wf_audio_FFT(audio_data, samps)
{
   if (!wf.audioFFT_active) return;
   
   if (!kiwi_load_js_polled(fft.audioFFT_dynload, ['pkgs/js/Ooura_FFT32.js'])) return;
   
   var i, j, k;
   
   //console.log('iq='+ audio_mode_iq +' comp='+ audio_compression +' samps='+ samps);

   var iq = (ext_get_mode() == 'iq');
   if (!fft.init || iq != fft.iq || audio_compression != fft.comp) {
      console.log('audio_FFT: SWITCHING iq='+ iq +' comp='+ audio_compression);
      var type;
      if (iq) {
         type = 'complex';
         fft.size = 1024;
         fft.offt = ooura32.FFT(fft.size, {"type":"complex", "radix":4});
         fft.i_re = ooura32.vectorArrayFactory(fft.offt);
         fft.i_im = ooura32.vectorArrayFactory(fft.offt);
      } else {
         type = 'real';
         fft.size = audio_compression? (fft.comp_1x? 2048 : 1024) : 512;
         fft.offt = ooura32.FFT(fft.size, {"type":"real", "radix":4});
         fft.i_re = ooura32.scalarArrayFactory(fft.offt);
      }
      fft.o_re = ooura32.vectorArrayFactory(fft.offt);
      fft.o_im = ooura32.vectorArrayFactory(fft.offt);
      //fft.scale = 10.0 * 2.0 / (fft.size * fft.size * fft.CUTESDR_MAX_VAL * fft.CUTESDR_MAX_VAL);
      // FIXME: What's the correct value to use here? Adding the third fft.size was just arbitrary.
      fft.scale = 10.0 * 2.0 / (fft.size * fft.size * fft.size * fft.CUTESDR_MAX_VAL * fft.CUTESDR_MAX_VAL);
      
      for (i = 0; i < 1024; i++) fft.pwr_dB[i] = 0;
      fft.iq = iq;
      fft.comp = audio_compression;
      fft.init = true;
   }

   if (fft.iq) {
      for (i = 0, j = 0; i < 1024; i += 2, j++) {
         fft.i_re[j] = audio_data[i] * fft.window_512[j];
         fft.i_im[j] = audio_data[i+1] * fft.window_512[j];
      }
      fft.offt.fft(fft.offt, fft.i_re.buffer, fft.i_im.buffer, fft.o_re.buffer, fft.o_im.buffer);
      for (j = 0, k = 512; j < 256; j++, k++) {
         var re = fft.o_re[j], im = fft.o_im[j];
         var pwr = re*re + im*im;
         var dB = 10.0 * Math.log10(pwr * fft.scale + 1e-30);
         dB = Math.round(255 + dB);
         fft.pwr_dB[k] = dB;
      }
      for (j = 256, k = 256; j < 512; j++, k++) {
         var re = fft.o_re[j], im = fft.o_im[j];
         var pwr = re*re + im*im;
         var dB = 10.0 * Math.log10(pwr * fft.scale + 1e-30);
         dB = Math.round(255 + dB);
         fft.pwr_dB[k] = dB;
      }
      waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
   } else {
      if (audio_compression) {
         if (fft.comp_1x) {
            // 2048 real samples done as 1x 2048-pt FFT
            for (i = 0; i < 2048; i++) {
               fft.i_re[i] = audio_data[i] * fft.window_2k[i];
            }
            fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
            for (j = 0, k = 256; j < 1024; j++) {
               var re = fft.o_re[j], im = fft.o_im[j];
               var pwr = re*re + im*im;
               fft.dBi[j&1] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
               if (j & 1) {
                  fft.pwr_dB[k] = Math.max(fft.dBi[0], fft.dBi[1]);
                  k++;
               }
            }
         } else {
            // 2048 real samples done as 2x 1024-pt FFTs
            for (i = 0; i < 1024; i++) {
               fft.i_re[i] = audio_data[i] * fft.window_1k[i];
            }
            fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
            for (j = 0, k = 256; j < 512; j++, k++) {
               var re = fft.o_re[j], im = fft.o_im[j];
               var pwr = re*re + im*im;
               fft.pwr_dB[k] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
            }
            waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
      
            for (i = 1024; i < 2048; i++) {
               fft.i_re[i] = audio_data[i] * fft.window_2k[i-1024];
            }
            fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
            for (j = 0, k = 256; j < 512; j++, k++) {
               var re = fft.o_re[j], im = fft.o_im[j];
               var pwr = re*re + im*im;
               fft.pwr_dB[k] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
            }
         }
         waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
      } else {
         for (i = 0; i < 512; i++) {
            fft.i_re[i] = audio_data[i] * fft.window_512[i];
         }
         fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
         for (j = 0, k = 256; j < 256; j++, k += 2) {
            var re = fft.o_re[j], im = fft.o_im[j];
            var pwr = re*re + im*im;
            fft.pwr_dB[k] = fft.pwr_dB[k+1] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
         }
         waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
      }
   }
}

/*
         // 2048 real samples done as 2x 1024-pt FFTs
         
         for (i = 0; i < 1024; i++) {
            fft.i_re[i] = audio_data[i] * fft.window_1k[i];
         }
         fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
         for (j = 0, k = 256; j < 512; j++, k++) {
            var re = fft.o_re[j], im = fft.o_im[j];
            var pwr = re*re + im*im;
            fft.pwr_dB[k] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
         }
         waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
   
         for (i = 1024; i < 2048; i++) {
            fft.i_re[i] = audio_data[i] * fft.window_1k[i-1024];
         }
         fft.offt.fft(fft.offt, fft.i_re.buffer, fft.o_re.buffer, fft.o_im.buffer);
         for (j = 0, k = 256; j < 512; j++, k++) {
            var re = fft.o_re[j], im = fft.o_im[j];
            var pwr = re*re + im*im;
            fft.pwr_dB[k] = Math.round(255 + (10.0 * Math.log10(pwr * fft.scale + 1e-30)));
         }
         waterfall_queue.push({ data:fft.pwr_dB, audioFFT:1, seq:0, spacing:0 });
*/


////////////////////////////////
// ui
////////////////////////////////

/*
	displayed vs carrier frequency rules:
		the demod freq/offset is the displayed freq so the passband is drawn correctly
		the carrier freq is passed to the server
		for ssb/cw the passband freq is the display freq and shown on the freq entry box (demod.usePBCenter)
	
	frequency settings paths:
	
	freqmode_set_dsp_kHz		-> demodulator_analog_replace -> demodulator_set_offset_frequency[1/3] -> freqset_car_Hz[1/2] (freq_car_Hz =)
									-> demodulator_set_offset_frequency[2/3] -> freqset_car_Hz (freq_car_Hz =)

	scale_canvas_mousemove	)		-> demodulator_set_offset_frequency[3/3] -> freqset_car_Hz (freq_car_Hz =)
	scale_canvas_end_drag 	) offsets with demod.usePBCenter
	canvas_mouseup				)
	
	(passband drag)			-> freqset_car_Hz[2/2] (freq_car_Hz =)
	
	(mode buttons)				-> demodulator_analog_replace -> demodulator_set_offset_frequency-> freqset_car_Hz (freq_car_Hz =)
	
	select_band					-> freqmode_set_dsp_kHz -> (above)
	dx_click
	freqset_complete
	freqstep
	WF shift-click (nearest boundary)
	
*/

var freq_displayed_Hz, freq_displayed_kHz_str, freq_car_Hz;
var freqset_tout;

function freq_dsp_to_car(fdsp)
{
	var demod = demodulators[0];
	if (isUndefined(demod)) {
	   console.log("freq_dsp_to_car no demod?");
		return fdsp;
	}
	var offset = demod.low_cut + (demod.high_cut - demod.low_cut)/2;
	fcar = demod.isCW? fdsp - offset : fdsp;
	// fixme: not good enough to contain passband in rx bandwidth
	if (fcar < 0) fcar = 0;
	if (fcar > bandwidth) fcar = bandwidth;
	//console.log("freq_dsp_to_car dsp="+fdsp+" car="+fcar+" isCW="+demod.isCW+" offset="+offset+" hcut="+demod.high_cut+" lcut="+demod.low_cut);
	return fcar;
}

function freq_car_to_dsp(fcar)
{
	var demod = demodulators[0];
	if (isUndefined(demod)) return fcar;
	var offset = demod.low_cut + (demod.high_cut - demod.low_cut)/2;
	fdsp = demod.isCW? fcar + offset : fcar;
	//console.log("freq_car_to_dsp dsp="+fdsp+" car="+fcar+" isCW="+demod.isCW+" offset="+offset+" hcut="+demod.high_cut+" lcut="+demod.low_cut);
	return fdsp;
}

function passband_offset()
{
	var offset=0;
	var usePBCenter = false;
	var demod = demodulators[0];
	if (isDefined(demod)) {
		usePBCenter = demod.usePBCenter;
		offset = usePBCenter? demod.low_cut + (demod.high_cut - demod.low_cut)/2 : 0;
	}
	//console.log("passband_offset: usePBCenter="+usePBCenter+' offset='+offset);
	return offset;
}

// Always return the PB center freq.
// The PB center is usually only added when demod.usePBCenter for the CW modes is true.
function freq_passband_center()
{
	var freq = 0;
	var demod = demodulators[0];
	if (isDefined(demod)) {
		freq = center_freq + demod.offset_frequency;
		freq += demod.low_cut + (demod.high_cut - demod.low_cut)/2;
	}
	return freq;
}

function passband_offset_dxlabel(mode)
{
	var pb = passbands[mode];
	var m = mode.substr(0,2);
	var usePBCenter = (m == 'us' || m == 'ls');
	var offset = usePBCenter? pb.lo + (pb.hi - pb.lo)/2 : 0;
	//console.log("passband_offset: m="+mode+" use="+usePBCenter+' o='+offset);
	return offset;
}


////////////////////////////////
// frequency entry
////////////////////////////////

function freqmode_set_dsp_kHz(fdsp, mode, opt)
{
   var dont_clear_wf = w3_opt(opt, 'dont_clear_wf', false);
   var open_ext = w3_opt(opt, 'open_ext', false);

	fdsp *= 1000;
	//console.log("freqmode_set_dsp_kHz: fdsp="+fdsp+' mode='+mode);
	if (dont_clear_wf == false) wf.audioFFT_clear_wf = true;

	if (isArg(mode) && (mode != cur_mode || open_ext == true)) {
		//console.log("freqmode_set_dsp_kHz: calling demodulator_analog_replace");
		ext_set_mode(mode, fdsp, opt);
	} else {
		freq_car_Hz = freq_dsp_to_car(fdsp);
		//console.log("freqmode_set_dsp_kHz: calling demodulator_set_offset_frequency NEW freq_car_Hz="+freq_car_Hz);
		demodulator_set_offset_frequency(0, freq_car_Hz - center_freq);
	}
}

function freqset_car_Hz(fcar)
{
	freq_car_Hz = fcar;
	//console.log("freqset_car_Hz: NEW freq_car_Hz="+fcar);
}

var freq_dsp_set_last;

function freqset_update_ui()
{
	//console.log('FUPD-UI freq_car_Hz='+ freq_car_Hz +' cf+of='+(center_freq + demodulators[0].offset_frequency));
	//console.log('FUPD-UI center_freq='+ center_freq +' offset_frequency='+ demodulators[0].offset_frequency);
	//kiwi_trace();
	freq_displayed_Hz = freq_car_to_dsp(freq_car_Hz);
   freq_displayed_kHz_str = (freq_displayed_Hz/1000).toFixed(2);
   //console.log("FUPD-UI freq_car_Hz="+freq_car_Hz+' NEW freq_displayed_Hz='+freq_displayed_Hz);
	
	if (!waterfall_setup_done) return;
	
	var obj = w3_el('id-freq-input');
	if (isUndefined(obj) || obj == null) return;		// can happen if SND comes up long before W/F

   var f_with_freq_offset = freq_displayed_Hz + cfg.freq_offset*1e3;
   freq_displayed_kHz_str_with_freq_offset = (f_with_freq_offset/1000).toFixed((f_with_freq_offset > 100e6)? 1:2);
   obj.value = freq_displayed_kHz_str_with_freq_offset;

	//console.log("FUPD obj="+ typeof(obj) +" val="+ obj.value);
	freqset_select();
	
	// re-center if the new passband is outside the current waterfall 
	var pb_bin = -passband_visible() - 1;
	//console.log("RECEN pb_bin="+pb_bin+" x_bin="+x_bin+" f(x_bin)="+bin_to_freq(x_bin));
	if (pb_bin >= 0) {
		var wf_middle_bin = x_bin + bins_at_cur_zoom()/2;
		//console.log("RECEN YES pb_bin="+pb_bin+" wfm="+wf_middle_bin+" dbins="+(pb_bin - wf_middle_bin));
		waterfall_pan_canvases(pb_bin - wf_middle_bin);		// < 0 = pan left (toward lower freqs)
	}
	
	// reset "select band" menu if freq is no longer inside band
	check_band();
	
	writeCookie('last_freq', freq_displayed_kHz_str_with_freq_offset);
	freq_dsp_set_last = freq_displayed_kHz_str_with_freq_offset;
	//console.log('## freq_dsp_set_last='+ freq_dsp_set_last);

	freq_step_update_ui();
	freq_link_update();
	
	// update history list
   //console.log('freq_memory update');
   //console.log(freq_memory);
	if (freq_displayed_kHz_str_with_freq_offset != freq_memory[freq_memory_pointer]) {
	   freq_memory.push(freq_displayed_kHz_str_with_freq_offset);
	   //console.log('freq_memory push='+ freq_displayed_kHz_str_with_freq_offset);
	}
	if (freq_memory.length > 25) freq_memory.shift();
	freq_memory_pointer = freq_memory.length-1;
   //console.log('freq_memory ptr='+ freq_memory_pointer);
   //console.log(freq_memory);
	writeCookie('freq_memory', JSON.stringify(freq_memory));
}

function freqset_keydown(event)
{
   if (event.keyCode == '38') {  // up-arrow
      freq_memory_up_down(1);
   }
   else if (event.keyCode == '40') { // down-arrow
      freq_memory_up_down(0);
   }
}

var freq_up_down_timeout = -1;

function freq_memory_up_down(up)
{
   kiwi_clearTimeout(freq_up_down_timeout);

   var obj = w3_el('id-freq-input');
   if (up) {
      if (freq_memory_pointer > 0) --freq_memory_pointer;
      if (freq_memory[freq_memory_pointer]) obj.value = freq_memory[freq_memory_pointer];
   } else {
      if (freq_memory_pointer < freq_memory.length-1) ++freq_memory_pointer; else return;
      if (freq_memory[freq_memory_pointer]) obj.value = freq_memory[freq_memory_pointer];
   }
   //console.log(freq_memory);
   //console.log('### freq_memory_up_down '+ (up? 'UP':'DOWN') +' len='+ freq_memory.length +' ptr='+ freq_memory_pointer +' f='+ freq_memory[freq_memory_pointer]);

   freq_up_down_timeout = setTimeout(function() {
      if (!kiwi_isMobile()) {
         // revert to current frequency if no selection made
         freq_memory_pointer = freq_memory.length-1;
         w3_el('id-freq-input').value = freq_dsp_set_last;
      }
      
      freqset_complete(2);
   }, kiwi_isMobile()? 2000:3000);
}

function freqset_select(id)
{
   // only switch focus to id-freq-input if active element doesn't specify w3-retain-input-focus
   var ae = document.activeElement;
   //console.log(ae);
   if (!ae || !w3_contains(ae, 'w3-retain-input-focus')) {
	   w3_field_select('id-freq-input', {mobile:1});
	} else {
      //console.log('#### activeElement w3-retain-input-focus');
	}
}

function modeset_update_ui(mode)
{
	if (owrx.last_mode_el != null) owrx.last_mode_el.style.color = "white";
	
	// if sound comes up before waterfall then the button won't be there
	var el = w3_el('id-mode-'+ mode.substr(0,2));
	el.innerHTML = mode.toUpperCase();
	if (el && el.style) el.style.color = "lime";
	owrx.last_mode_el = el;

	squelch_setup(toggle_e.FROM_COOKIE);
	writeCookie('last_mode', mode);
	freq_link_update();

	// disable compression button in iq mode
	w3_set_props('id-button-compression', 'w3-disabled', (mode == 'iq'));
}

// delay the UI updates called from the audio path until the waterfall UI setup is done
function try_freqset_update_ui()
{
	if (waterfall_setup_done) {
		freqset_update_ui();
		if (wf.audioFFT_active) {
		
         // if not already clearing then clear on iq mode change
         var c_iq_drm_sas = (cur_mode == 'iq' || cur_mode == 'drm' || cur_mode == 'sas')? 1:0;
         var p_iq_drm_sas = (wf.audioFFT_prev_mode == 'iq' || wf.audioFFT_prev_mode == 'drm' || wf.audioFFT_prev_mode == 'sas')? 1:0;
		   if (!wf.audioFFT_clear_wf && (c_iq_drm_sas ^ p_iq_drm_sas))
		      wf.audioFFT_clear_wf = true;
		   audioFFT_update();
		   wf.audioFFT_prev_mode = cur_mode;
		} else {
		   mkenvelopes(get_visible_freq_range());
		}
	} else {
		setTimeout(try_freqset_update_ui, 1000);
	}
}

function try_modeset_update_ui(mode)
{
	if (waterfall_setup_done) {
		modeset_update_ui(mode);
	} else {
		setTimeout(function() {
			try_modeset_update_ui(mode);
		}, 1000);
	}
}

function freq_link_update()
{
	var host = kiwi_url_origin();
	var url = host + '/?f='+ freq_displayed_kHz_str + cur_mode +'z'+ zoom_level;
	w3_innerHTML('id-freq-link',
      w3_icon('w3-text-css-lime||title='+ dq('copy to clipboard:\n'+ url),
         'fa-external-link-square', 15, '', 'freq_link_update_cb', url
      )
	);
}

function freq_link_update_cb(path, param, first)
{
   if (first) return;
   w3_copy_to_clipboard(param);
}

function freqset_complete(from)
{
	var obj = w3_el('id-freq-input');
	//console.log("FCMPL from="+ from +" obj="+ typeof(obj) +" val="+ (obj.value).toString());
	kiwi_clearTimeout(freqset_tout);
   kiwi_clearTimeout(freq_up_down_timeout);
	if (isUndefined(obj) || obj == null) return;		// can happen if SND comes up long before W/F

   var p = obj.value.split(/[\/:]/);
	var slash = obj.value.includes('/');
   // 'k' suffix is simply ignored since default frequencies are in kHz
	var f = p[0].replace(',', '.').parseFloatWithUnits('M', 1e-3);    // Thanks Petri, OH1BDF
	var err = true;
	if (f > 0 && !isNaN(f)) {
	   f -= cfg.freq_offset;
	   if (f > 0 && !isNaN(f)) {
         freqmode_set_dsp_kHz(f, null);
	      w3_field_select(obj, {mobile:1});
	      err = false;
      }
	}
   if (err) freqset_update_ui();    // restore previous
	
	// accept "freq/pbw" or "/pbw" to quickly change passband width to a numeric value
	// also "lo,hi" in place of "pbw"
	// and ":pbc" or ":pbc,pbw" to set the pbc at the current pbw
	if (p[1]) {
	   p2 = p[1].split(',');
	   var lo = p2[0].parseFloatWithUnits('k');
	   var hi = NaN;
	   if (p2.length > 1) {
	      hi = p2[1].parseFloatWithUnits('k');
	   }
	   //console.log('### <'+ (slash? '/' : ':') +'> '+ p2[0] +'/'+ lo +', '+ p2[1] +'/'+ hi);
      var cpb = ext_get_passband();
      var cpbhw = (cpb.high - cpb.low)/2;
      var cpbcf = cpb.low + cpbhw;
	   
	   if (slash) {
         // adjust passband width about current pb center
         if (p2.length == 1) {
            // /pbw
            var pbhw = lo/2;
            lo = cpbcf - pbhw, hi = cpbcf + pbhw;
         }
      } else {
         // adjust passband center using current or specified pb width
         var pbc = lo;
         if (p2.length == 1) {
            // :pbc
            lo = pbc - cpbhw;
            hi = pbc + cpbhw;
         } else {
            var pbhw = Math.abs(hi/2);
            // :pbc,pbw
            lo = pbc - pbhw;
            hi = pbc + pbhw;
         }
      }

      ext_set_passband(lo, hi, true);     // does error checking for NaN, lo < hi, min pbw etc.
	}
}

var ignore_next_keyup_event = false;

// freqset_keyup is called on each key-up while the frequency box is selected so that if a numeric
// entry is made, without a terminating <return> key, a setTimeout(freqset_complete()) can be done to
// arrange automatic completion.

function freqset_keyup(obj, evt)
{
	//console.log("FKU obj="+ typeof(obj) +" val="+ obj.value +' ignore_next_keyup_event='+ ignore_next_keyup_event);
	//console.log(obj); console.log(evt);
	kiwi_clearTimeout(freqset_tout);
	
	// Ignore modifier-key key-up events triggered because the frequency box is selected while
	// modifier-key-including mouse event occurs somewhere else.
	// Also keeps ident_complete timeout from being set after return key.
	
	// But this is tricky. Key-up of a shift/ctrl/alt/cmd key can only be detected by looking for a
	// evt.key string length != 1, i.e. evt.shiftKey et al don't seem to be valid for the key-up event!
	// But also have to check for them with any_alternate_click_event() in case a modifier key of a
	// normal key is pressed (e.g. shift-$).
	if (evt != undefined && evt.key != undefined) {
		var klen = evt.key.length;
		
		// any_alternate_click_event_except_shift() allows e.g. "10M" for 10 MHz
		if (any_alternate_click_event_except_shift(evt) || (klen != 1 && evt.key != 'Backspace')) {
	
			// An escape while the the freq box has focus causes the browser to put input value back to the
			// last entered value directly by keyboard. This value is likely different than what was set by
			// the last "element.value = ..." assigned from a waterfall click. So we have to restore the value.
			if (evt.key == 'Escape') {
			   //event_dump(evt, 'Escape-freq');
				//console.log('** restore freq box');
				freqset_update_ui();
			}
	
			//console.log('FKU IGNORE ign='+ ignore_next_keyup_event +' klen='+ klen);
			ignore_next_keyup_event = false;
			return;
		}
	}
	
	if (ignore_next_keyup_event) {
      ignore_next_keyup_event = false;
      return;
   }
   
	freqset_tout = setTimeout(function() {freqset_complete(1);}, 3000);
}

var num_step_buttons = 6;

var up_down = {
   // 0 means use special step logic
	am: [ 0, -1, -0.1, 0.1, 1, 0 ],
	amn: [ 0, -1, -0.1, 0.1, 1, 0 ],
	sam: [ 0, -1, -0.1, 0.1, 1, 0 ],
	sal: [ 0, -1, -0.1, 0.1, 1, 0 ],
	sau: [ 0, -1, -0.1, 0.1, 1, 0 ],
	sas: [ 0, -1, -0.1, 0.1, 1, 0 ],
	drm: [ 0, -1, -0.1, 0.1, 1, 0 ],
	usb: [ 0, -1, -0.1, 0.1, 1, 0 ],
	usn: [ 0, -1, -0.1, 0.1, 1, 0 ],
	lsb: [ 0, -1, -0.1, 0.1, 1, 0 ],
	lsn: [ 0, -1, -0.1, 0.1, 1, 0 ],
	cw: [ 0, -0.1, -0.01, 0.01, 0.1, 0 ],
	cwn: [ 0, -0.1, -0.01, 0.01, 0.1, 0 ],
	nbfm: [ -5, -1, -0.1, 0.1, 1, 5 ],
	iq: [ 0, -1, -0.1, 0.1, 1, 0 ],
};

var up_down_default = {
   // only referenced by special step logic, so only max/min values used (that's why others are zero)
   // NB: abs(values)
	am: [ 5, 0, 0, 0, 0, 5 ],
	amn: [ 5, 0, 0, 0, 0, 5 ],
	sam: [ 5, 0, 0, 0, 0, 5 ],
	sal: [ 5, 0, 0, 0, 0, 5 ],
	sau: [ 5, 0, 0, 0, 0, 5 ],
	sas: [ 5, 0, 0, 0, 0, 5 ],
	drm: [ 5, 0, 0, 0, 0, 5 ],
	usb: [ 5, 0, 0, 0, 0, 5 ],
	usn: [ 5, 0, 0, 0, 0, 5 ],
	lsb: [ 5, 0, 0, 0, 0, 5 ],
	lsn: [ 5, 0, 0, 0, 0, 5 ],
	cw: [ 1, 0, 0, 0, 0, 1 ],
	cwn: [ 1, 0, 0, 0, 0, 1 ],
	// nbfm doesn't have special step
	iq: [ 5, 0, 0, 0, 0, 5 ],
};

var NDB_400_1000_mode = 1;		// special 400/1000 step mode for NDB band

function special_step(b, sel, caller)
{
	var s = 'SPECIAL_STEP '+ caller +' sel='+ sel;
	var step_Hz;

	if (b != null && b.name == 'NDB') {
		if (cur_mode == 'cw' || cur_mode == 'cwn') {
			step_Hz = NDB_400_1000_mode;
		} else {
			step_Hz = -1;
		}
		s += ' NDB';
	} else
	if (b != null && (b.name == 'LW' || b.name == 'MW')) {
	   var cm = cur_mode.substr(0,2);
		var am_ssb_iq_drm = (cm == 'am' || cm == 'sa' || cm == 'ls' || cm == 'us' || cm == 'iq' || cm == 'dr');
		//console_log('special step', cm, am_ssb_iq_drm);
		if (am_ssb_iq_drm) {
			step_Hz = step_9_10? 9000 : 10000;
		} else {
			step_Hz = -1;
		}
		s += ' LW/MW';
	} else
	if (b != null && b.chan != 0) {
		step_Hz = b.chan;
		s += ' band='+ b.name +' ';
	} else {
		step_Hz = -1;
		s += ' no band chan found, use default';
	}
	if (step_Hz == -1) step_Hz = up_down_default[cur_mode][sel]*1000;
	if (sel < num_step_buttons/2) step_Hz = -step_Hz;
	s += ' '+ step_Hz;
	//console.log(s);
	return step_Hz;
}

function freqstep(sel)
{
	var step_Hz = up_down[cur_mode][sel]*1000;
	
	// set step size from band channel spacing
	if (step_Hz == 0) {
		var b = find_band(freq_displayed_Hz);
		step_Hz = special_step(b, sel, 'freqstep');
	}

	var fnew = freq_displayed_Hz;
	var incHz = Math.abs(step_Hz);
	var posHz = (step_Hz >= 0)? 1:0;
	var trunc = fnew / incHz;
	trunc = (posHz? Math.ceil(trunc) : Math.floor(trunc)) * incHz;
	var took;

	if (incHz == NDB_400_1000_mode) {
		var kHz = fnew % 1000;
		if (posHz)
			kHz = (kHz < 400)? 400 : ( (kHz < 600)? 600 : 1000 );
		else
			kHz = (kHz == 0)? -400 : ( (kHz <= 400)? 0 : ( (kHz <= 600)? 400 : 600 ) );
		trunc = Math.floor(fnew/1000)*1000;
		fnew = trunc + kHz;
		took = '400/1000';
		//console.log("STEP -400/1000 kHz="+kHz+" trunc="+trunc+" fnew="+fnew);
	} else
	if (freq_displayed_Hz != trunc) {
		fnew = trunc;
		took = 'TRUNC';
	} else {
		fnew += step_Hz;
		took = 'INC';
	}
	//console.log('STEP '+sel+' '+cur_mode+' fold='+freq_displayed_Hz+' inc='+incHz+' trunc='+trunc+' fnew='+fnew+' '+took);
	
	// audioFFT mode: don't clear waterfall for small frequency steps
	freqmode_set_dsp_kHz(fnew/1000, null, { dont_clear_wf:true });
}

var freq_step_last_mode, freq_step_last_band;

function freq_step_update_ui(force)
{
	if (isUndefined(cur_mode) || passbands[cur_mode] == undefined ) return;
	var b = find_band(freq_displayed_Hz);
	
	//console.log("freq_step_update_ui: lm="+freq_step_last_mode+' cm='+cur_mode);
	if (!force && freq_step_last_mode == cur_mode && freq_step_last_band == b) {
		//console.log("freq_step_update_ui: return "+freq_step_last_mode+' '+cur_mode);
		return;
	}

   var cm = cur_mode.substr(0,2);
   var am_ssb_iq_drm = (cm == 'am' || cm == 'sa' || cm == 'ls' || cm == 'us' || cm == 'iq' || cm == 'dr');
	var show_9_10 = (b != null && (b.name == 'LW' || b.name == 'MW') && am_ssb_iq_drm)? true:false;
	w3_visible('id-9-10-cell', show_9_10);

	for (var i=0; i < num_step_buttons; i++) {
		var step_Hz = up_down[cur_mode][i]*1000;
		if (step_Hz == 0) {
			step_Hz = special_step(b, i, 'freq_step_update_ui');
		}

		var title;
		var absHz = Math.abs(step_Hz);
		var posHz = (step_Hz >= 0)? 1:0;
		if (absHz >= 1000)
			title = (posHz? '+':'')+(step_Hz/1000).toString()+'k';
		else
		if (absHz != NDB_400_1000_mode)
			title = (posHz? '+':'')+step_Hz.toString();
		else {
			title = (posHz? '+':'-')+'400/'+(posHz? '+':'-')+'1000';
		}
		html('id-step-'+i).title = title;
	}
	
	freq_step_last_mode = cur_mode;
	freq_step_last_band = b;
}

function band_info()
{
	var _9_10 = (+cfg.init.AM_BCB_chan)? 10:9;

	var ITU_region = cfg.init.ITU_region + 1;
	var LW_lo = 153-9/2, NDB_lo, NDB_hi, MW_hi;
	
	if (ITU_region == 1) {		// really 526.5 in UK?
		NDB_lo = 279+9/2; NDB_hi = 531-9/2; MW_hi = 1602+9/2;
	} else
	if (ITU_region == 2) {
		NDB_lo = 191-1/2; NDB_hi = 540-_9_10/2; MW_hi = 1700+_9_10/2;
	} else {
		// ITU_region == 3
		NDB_lo = 191-1/2; NDB_hi = 540-_9_10/2; MW_hi = 1602+_9_10/2;
	}
	
	//console.log('ITU='+ ITU_region +' _9_10='+ _9_10 +' LW_lo='+ LW_lo +' NDB_lo='+ NDB_lo +' NDB_hi='+ NDB_hi +' MW_hi='+ MW_hi);
	return { ITU_region:ITU_region, _9_10:_9_10, LW_lo:LW_lo, NDB_lo:NDB_lo, NDB_hi:NDB_hi, MW_hi:MW_hi }
}

// augment bands[] found in the config.js configuration file
function bands_init()
{
	var i, z;

	var bi = band_info();

	for (i=0; i < bands.length; i++) {
		var b = bands[i];
		bands[i].chan = isUndefined(b.chan)? 0 : b.chan;
		b.min -= b.chan/2; b.max += b.chan/2;
		
		// fix LW/NDB/MW band definitions based on ITU region and MW channel spacing configuration settings
		if (b.name == 'LW') {
			b.min = bi.LW_lo; b.max = bi.NDB_lo; b.chan = 9;
		}
		if (b.name == 'NDB') {
			b.min = bi.NDB_lo; b.max = bi.NDB_hi; b.chan = 0;
		}
		if (b.name == 'MW') {
			b.min = bi.NDB_hi; b.max = bi.MW_hi; b.chan = bi._9_10;
		}
		
		b.min *= 1000; b.max *= 1000; b.chan *= 1000;
		var bw = b.max - b.min;
		//console.log(b.name +' bw='+ bw);
		for (z=zoom_nom; z >= 0; z--) {
		   var zbw = bandwidth / (1 << z);
		   //console.log('z'+ z +' '+ (bw / zbw * 100).toFixed(0) +'%');
			if (bw <= 0.80 * zbw)
				break;
		}
		bands[i].zoom_level = z;
		bands[i].cf = b.min + (b.max - b.min)/2;
		bands[i].longName = b.name +' '+ b.s.name;
		//console.log("BAND "+b.name+" bw="+bw+" z="+z);
		
		// FIXME: Change IBP passband from CW to CWN.
		// A software release can't modify bands[] definition in config.js so do this here.
		// At some point config.js will be eliminated when admin page gets equivalent UI.
		if ((b.s == svc.L || b.s == svc.X) && b.region == 'm') {
		   if (!b.sel.includes('cwn'))
		      b.sel = b.sel.replace('cw', 'cwn');
		}
	}

	mkscale();
}

function find_band(freq)
{
	var b;
	for (var i=0; i < bands.length; i++) {
		b = bands[i];
		if (b.region != "-" && b.region != "*" && b.region.charAt(0) != '>') continue;
		if (freq >= b.min && freq <= b.max)
			return b;
	}
	return null;
}

	band_canvas_h = 30;
	band_canvas_top = 0;
		band_scale_h = 20;
		band_scale_top = 5;
			band_scale_text_top = 5;
	
	dx_container_h = 80;
	dx_container_top = band_canvas_h;
		dx_label_top = 5;
		dx_line_h = dx_container_h - dx_label_top;
	
	scale_canvas_h = 47;
	scale_canvas_top = band_canvas_h + dx_container_h;
	
scale_container_h = band_canvas_h + dx_container_h + scale_canvas_h;

function mk_bands_scale()
{
	var r = g_range;
	
	// band bars & station labels
	var tw = band_ctx.canvas.width;
	var i, x, y=band_scale_top, w, h=band_scale_h, ty=y+band_scale_text_top;
	//console.log("BB fftw="+wf_fft_size+" tw="+tw+" rs="+r.start+" re="+r.end+" bw="+(r.end-r.start));
	//console.log("BB pixS="+scale_px_from_freq(r.start, g_range)+" pixE="+scale_px_from_freq(r.end, g_range));
	band_ctx.globalAlpha = 1;
	band_ctx.fillStyle = "White";
	band_ctx.fillRect(0,band_canvas_top,tw,band_canvas_h);

	for (i=0; i < bands.length; i++) {
		var b = bands[i];
		if (b.region != "-" && b.region != "*" && b.region.charAt(0) != '>') continue;

		var x1=0, x2;
		var min_inside = (b.min >= r.start && b.min <= r.end)? 1:0;
		var max_inside = (b.max >= r.start && b.max <= r.end)? 1:0;
		if (min_inside && max_inside) { x1 = b.min; x2 = b.max; } else
		if (!min_inside && max_inside) { x1 = r.start; x2 = b.max; } else
		if (min_inside && !max_inside) { x1 = b.min; x2 = r.end; } else
		if (b.min < r.start && b.max > r.end) { x1 = r.start; x2 = r.end; }

		if (x1 == 0) continue;
 
      x = scale_px_from_freq(x1, g_range); var xx = scale_px_from_freq(x2, g_range);
      w = xx - x;
      //console.log("BANDS x="+x1+'/'+x+" y="+x2+'/'+xx+" w="+w);
      if (w < 3) continue;

      band_ctx.fillStyle = b.s.color;
      band_ctx.globalAlpha = 0.2;
      //console.log("BB x="+x+" y="+y+" w="+w+" h="+h);
      band_ctx.fillRect(x,y,w,h);
      band_ctx.globalAlpha = 1;

      //band_ctx.fillStyle = "Black";
      band_ctx.font = "bold 12px sans-serif";
      band_ctx.textBaseline = "top";
      var tx = x + w/2;
      var txt = b.longName;
      var mt = band_ctx.measureText(txt);
      //console.log("BB mt="+mt.width+" txt="+txt);
      if (w >= mt.width+4) {
         ;     // long name fits in bar
      } else {
         txt = b.name;
         mt = band_ctx.measureText(txt);
         //console.log("BB mt="+mt.width+" txt="+txt);
         if (w >= mt.width+4) {
            ;  // short name fits in bar
         } else {
            txt = null;
         }
      }
      //if (txt) console.log("BANDS tx="+(tx - mt.width/2)+" ty="+ty+" mt="+mt.width+" txt="+txt);
      if (txt) band_ctx.fillText(txt, tx - mt.width/2, ty);
	}
}

function mk_spurs()
{
	scale_ctx.fillStyle = "red";
	var h = 12;
	var y = scale_canvas_h - h;
	for (var z=0; z <= zoom_level && z < spurs.length; z++) {
		for (var i=0; i < spurs[z].length; i++) {
			var x = scale_px_from_freq(spurs[z][i]*1000, g_range);
			//console.log("SPUR "+spurs[z][i]+" @"+x);
			if (x > window.innerWidth) break;
			if (x < 0) continue;
			scale_ctx.fillRect(x-1,y,2,h);
		}
	}
}

function parse_freq_mode(freq_mode)
{
   var s = new RegExp("([0-9.]*)([^&#]*)").exec(freq_mode);
}

var last_selected_band = 0;

function band_scroll(dir)
{
   var i = last_selected_band;
   var b;

   do {
      i += dir;
      if (i < 0) i = band_menu.length - 1;
      if (i >= band_menu.length) i = 0;
      b = band_menu[i];
   } while (b == null);
   
   select_band(i);
   w3_set_value('id-select-band', i);
}

function select_band(v, mode)
{
   var v_num = +v;
   //console.log('select_band t/o_v='+ typeof(v) +' v_num='+ v_num);
   if (!isNaN(v_num)) {
      //console.log('select_band num v='+ v_num);
      b = band_menu[v_num];
   } else {
      //console.log('select_band str v='+ v);
      var i;
      for (i = 0; i < band_menu.length-1; i++) {
         if (band_menu[i] && band_menu[i].name == v)
            break;
      }
      //console.log('select_band i='+ i);
      if (i < band_menu.length-1)
         select_band(i, mode);
      return;
   }
   
	if (b == null) {
	   check_band(true);
		return;
	}
	
	var freq;
	if (isDefined(b.sel)) {
		freq = parseFloat(b.sel);
		if (isUndefined(mode) && isString(b.sel)) {
			mode = b.sel.search(/[a-z]/i);
			mode = (mode == -1)? null : b.sel.slice(mode);
		}
	} else {
		freq = b.cf/1000;
	}

	//console.log("SEL BAND"+v_num+" "+b.name+" freq="+freq+((mode != null)? " mode="+mode:""));
	last_selected_band = v_num;
	if (dbgUs) {
		//console.log("SET BAND cur z="+zoom_level+" xb="+x_bin);
		sb_trace=0;
	}
	freqmode_set_dsp_kHz(freq, mode);
	zoom_step(ext_zoom.TO_BAND, b);		// pass band to disambiguate nested bands in band menu
	if (sb_trace) {
		//console.log("SET BAND after z="+zoom_level+" xb="+x_bin);
	}
}

function check_band(reset)
{
	// reset "select band" menu if no longer inside band
	if (last_selected_band) {
		band = band_menu[last_selected_band];
		//console.log("check_band "+last_selected_band+" reset="+reset+' '+band.min+'/'+band.max);
		
		// check both carrier and pbc frequencies
	   var car = freq_car_Hz;
	   var pbc = freq_passband_center();
	   
		if ((reset != undefined && reset == -1) || ((car < band.min || car > band.max) && (pbc < band.min || pbc > band.max))) {
	      //console.log('check_band OUTSIDE BAND RANGE reset='+ reset +' car='+ car +' pbc='+ pbc +' last_selected_band='+ last_selected_band);
	      //console.log(band);
			w3_select_value('id-select-band', 0);
			last_selected_band = 0;
		}
	}
}
	
function tune(fdsp, mode, zoom, zarg)
{
	ext_tune(fdsp, mode, ext_zoom.ABS, zoom, zarg);
}

var maxdb;
var mindb_un;
var mindb;
var full_scale;

function init_scale_dB()
{
	maxdb = init_max_dB;
	mindb_un = init_min_dB;
	mindb = mindb_un - zoomCorrection();
	full_scale = maxdb - mindb;
	full_scale = full_scale? full_scale : 1;	// can't be zero

   wf.save_maxdb = maxdb;
   wf.save_mindb_un = mindb_un;
   wf.auto_ceil.val = +initCookie('last_ceil_dB', wf.auto_ceil.def);
   wf.auto_floor.val = +initCookie('last_floor_dB', wf.auto_floor.def);
}


////////////////////////////////
// confirmation panel
////////////////////////////////

var confirmation = {
   displayed: false,
   close_cb: null,
};

function confirmation_panel_init()
{
   w3_el('id-panels-container').innerHTML +=
      w3_div('id-confirmation class-panel|border: 1px solid white|data-panel-name="confirmation" data-panel-pos="center" data-panel-order="0" data-panel-size="600,100"');

	w3_innerHTML('id-confirmation',
		w3_divs('id-confirmation-container/class-panel-inner') +
		w3_div('id-confirmation-vis class-vis')
	);
}

function confirmation_panel_set_close_func(close_cb)
{
	w3_el('id-confirmation-close').onclick = close_cb;    // hook the close icon
	confirmation.close_cb = close_cb;
}

function confirmation_panel_init2()
{
   confirmation_panel_set_close_func(confirmation_panel_close);
	w3_el('id-kiwi-body').addEventListener('keyup',
	   function(evt) {
	      if (evt.key == 'Escape') {
	         confirmation.close_cb();
            toggle_or_set_hide_panels(0);    // cancel panel hide mode
	      }
	   }, true);
}

function confirmation_show_content(s, w, h, close_cb, bg_color)
{
   // can't simply call confirmation_panel_close() here because of how panel is toggled
   if (confirmation.displayed)
      w3_color('id-confirmation', null, '');    // remove any user applied bg_color
   
   w3_innerHTML('id-confirmation-container', s);
   w3_color('id-confirmation', null, bg_color);
   
   if (close_cb) confirmation_panel_set_close_func(close_cb);
   confirmation_panel_show(w, h);
   
   // If panels hidden by e.g. 'x' key, and new panel brought up by menu action,
   // then force panels visible again.
   toggle_or_set_hide_panels(0);
}

function confirmation_panel_show(w, h)
{
	el = w3_el('id-confirmation');
	el.style.zIndex = 1020;
	if (w == undefined) w = 525;
	if (h == undefined) h = 80;
	confirmation_panel_resize(w, h);

   //console.log('confirmation_panel_show CHECK was '+ confirmation.displayed);
   confirmation.displayed = !confirmation.displayed;
   toggle_panel('id-confirmation');
}

function confirmation_panel_resize(w, h)
{
	var el = w3_el('id-confirmation');
	panel_set_width_height('id-confirmation', w, h);
   el.style.left = px(window.innerWidth/2 - el.activeWidth/2);
   el.style.bottom = px(window.innerHeight/2 - el.uiHeight/2);
}

function confirmation_panel_close()
{
   //console.log('confirmation_panel_close CHECK displayed='+ confirmation.displayed);
   //kiwi_trace();
   if (confirmation.displayed) {
      w3_color('id-confirmation', null, '');    // remove any user applied bg_color
      toggle_panel('id-confirmation');
      confirmation_panel_set_close_func(confirmation_panel_close);   // set default
      confirmation.displayed = false;
      //console.log('confirmation_panel_close CLOSE');
   }
}


////////////////////////////////
// cal ADC clock confirmation panel
////////////////////////////////

var cal_adc_new_adj;

function cal_adc_dialog(new_adj, clk_diff, r1k, ppm)
{
   var s;
   var gps_correcting = (cfg.ADC_clk_corr && ext_adc_gps_clock_corr() > 3)? 1:0;
   if (gps_correcting) {
      s = w3_col_percent('/w3-valign',
            w3_div('w3-show-inline-block', 'GPS is automatically correcting ADC clock. <br> No manual calibration available.') +
            w3_button('w3-red w3-margin-left', 'Close', 'confirmation_panel_close'),
            80
         );
   } else {
      cal_adc_new_adj = new_adj;
      var adc_clock_ppm_limit = 100;
      var hz_limit = ext_adc_clock_nom_Hz() * adc_clock_ppm_limit / 1e6;
      
      if (new_adj < -hz_limit || new_adj > hz_limit) {
         console.log('cal ADC clock: ADJ TOO LARGE');
         s = w3_col_percent('/w3-valign',
               w3_div('w3-show-inline-block', 'ADC clock adjustment too large: '+ clk_diff +' Hz<br>' +
                  '(ADC clock '+ ppm.toFixed(1) +' ppm, limit is +/- '+ adc_clock_ppm_limit +' ppm)') +
               w3_button('w3-red w3-margin-left', 'Close', 'confirmation_panel_close'),
               80
            );
      } else {
         s = w3_col_percent('/w3-valign',
               w3_div('w3-show-inline-block', 'ADC clock will be adjusted by<br>'+ clk_diff +' Hz to '+ r1k +' kHz<br>' +
                  '(ADC clock '+ ppm.toFixed(1) +' ppm)') +
               w3_button('w3-green w3-margin-left', 'Confirm', 'cal_adc_confirm') +
               w3_button('w3-red w3-margin-left', 'Cancel', 'confirmation_panel_close'),
               80
            );
      }
   }
   
   confirmation_show_content(s, 525, 70);
}

function cal_adc_confirm()
{
   ext_send('SET clk_adj='+ cal_adc_new_adj);
   ext_set_cfg_param('cfg.clk_adj', cal_adc_new_adj, true);
   confirmation_panel_close();
}


////////////////////////////////
// admin pwd panel
////////////////////////////////

function admin_pwd_query(isAdmin_true_cb)
{
	ext_hasCredential('admin', admin_pwd_cb, isAdmin_true_cb, ws_wf);
}

function admin_pwd_cb(badp, isAdmin_true_cb)
{
	console.log('admin_pwd_cb badp='+ badp);
	if (!badp) {
		isAdmin_true_cb();
		return;
	}

	var s =
		w3_col_percent('/w3-text-aqua',
			w3_input('kiwi-pw', 'Admin password', 'admin.pwd', '', 'admin_pwd_cb2'), 80
		);
   confirmation_show_content(s, 525, 80);

	// put the cursor in (i.e. select) the password field
	w3_field_select('id-admin.pwd', {mobile:1});
}

function admin_pwd_cb2(el, val)
{
   w3_string_cb(el, val);
   confirmation_panel_close();
	ext_valpwd('admin', val, ws_wf);
}


////////////////////////////////
// dx labels
////////////////////////////////

var dx = {
   filter_ident: '',
   filter_notes: '',
   filter_case: 0,
   filter_wild: 0,
   filter_grep: 0,
   ctrl_click: false,
   displayed: [],
};

var dx_update_delay = 350;
var dx_update_timeout, dx_seq=0;

function dx_schedule_update()
{
	kiwi_clearTimeout(dx_update_timeout);
	dx_div.innerHTML = "";
	dx_update_timeout = setTimeout(dx_update, dx_update_delay);
}

function dx_update()
{
	dx_seq++;
	//g_range = get_visible_freq_range();
	//console.log("DX min="+(g_range.start/1000)+" max="+(g_range.end/1000));
	wf_send('SET MARKER min='+ (g_range.start/1000).toFixed(3) +' max='+ (g_range.end/1000).toFixed(3) +' zoom='+ zoom_level +' width='+ waterfall_width);
}

// Why doesn't using addEventListener() to ignore mousedown et al not seem to work for
// div elements created appending to innerHTML?

var dx_ibp_list, dx_ibp_interval, dx_ibp_server_time_ms, dx_ibp_local_time_epoch_ms = 0;
var dx_ibp_freqs = { 14:0, 18:1, 21:2, 24:3, 28:4 };
var dx_ibp_lastsec = 0;

var dx_ibp = [
	'4U1UN', 	'New York',
	'VE8AT',		'Nunavut',
	'W6WX',		'California',
	'KH6RS', 	'Hawaii',
	'ZL6B',		'New Zealand',
	'VK6RBP',	'Australia',
	'JA2IGY',	'Japan',
	'RR9O',		'Siberia',
	'VR2B',		'Hong Kong',
	'4S7B',		'Sri Lanka',
	'ZS6DN',		'South Africa',
	'5Z4B',		'Kenya',
	'4X6TU',		'Israel',
	'OH2B',		'Finland',
	'CS3B',		'Madeira',
	'LU4AA',		'Argentina',
	'OA4B',		'Peru',
	'YV5B',		'Venezuela'
];

var dx_list = [];

function dx_label_cb(arr)
{
	var i;
	var obj = arr[0];
	
	// reply to label step request
	if (obj.t == 2) {
	   var dl = arr[1];
	   if (dl) {
	      //console.log('dx_label_cb: type=2 f='+ dl.f);
	      //console.log(dl);
	      var mode = kiwi.modes_l[dl.b & DX_MODE];
         freqmode_set_dsp_kHz(dl.f, mode);
         if (dl.lo != 0 && dl.hi != 0) {
            ext_set_passband(dl.lo, dl.hi);     // label has custom pb
         } else {
            var dpb = passbands[mode];
            ext_set_passband(dpb.lo, dpb.hi);   // need to force default pb in case cpb is not default
         }
      } else {
	      //console.log('dx_label_cb: type=2 NO LABEL FOUND');
      }
	   return;
	}
	
	kiwi_clearInterval(dx_ibp_interval);
	dx_ibp_list = [];
	dx_ibp_server_time_ms = obj.s * 1000 + (+obj.m);
	dx_ibp_local_time_epoch_ms = Date.now();
	
	dx_filter_field_err(+obj.f);
	
	var dx_idx, dx_z = 120;
	dx_div.innerHTML = '';
	var s = '';
	dx.displayed = [];
	
	for (i = 1; i < arr.length; i++) {
		obj = arr[i];
		dx_idx = i-1;
		var gid = obj.g;
		var freq = obj.f;
		var moff = obj.o;
		var flags = obj.b;
		var ident = obj.i;
		var notes = isDefined(obj.n)? obj.n : '';
		var params = isDefined(obj.p)? obj.p : '';

		var freqHz = freq * 1000;
		var loff = passband_offset_dxlabel(kiwi.modes_l[flags & DX_MODE]);	// always place label at center of passband
		var x = scale_px_from_freq(freqHz + loff, g_range) - 1;	// fixme: why are we off by 1?
		var cmkr_x = 0;		// optional carrier marker for NDBs
		var carrier = freqHz - moff;
		if (moff) cmkr_x = scale_px_from_freq(carrier, g_range);
	
		var t = dx_label_top + (30 * (dx_idx&1));		// stagger the labels vertically
		var h = dx_container_h - t;
		var color = type_colors[flags & DX_TYPE];
		if (ident == 'IBP' || ident == 'IARU%2fNCDXF') color = type_colors[0x20];		// FIXME: hack for now
		//console.log("DX "+dx_seq+':'+dx_idx+" f="+freq+" o="+loff+" k="+moff+" F="+flags+" m="+kiwi.modes_u[flags & DX_MODE]+" <"+ident+"> <"+notes+'>');
		
		carrier /= 1000;
		dx_list[gid] = { "gid":gid, "carrier":carrier, "lo":obj.lo, "hi":obj.hi, "freq":freq, "moff":moff, "flags":flags, "ident":ident, "notes":notes, "params":params };
      dx.displayed[dx_idx] = dx_list[gid];
		//console.log(dx_list[gid]);
		
		s +=
			'<div id="'+dx_idx+'-id-dx-label" class="class-dx-label '+ gid +'-id-dx-gid'+ ((params != '')? ' id-has-ext':'') +'" ' +
			   'style="left:'+(x-10)+'px; top:'+t+'px; z-index:'+dx_z+'; ' +
				'background-color:'+ color +';" ' +
				
				// overrides underlying canvas listeners for the dx labels
				'onmouseenter="dx_enter(this,'+ cmkr_x +', event)" onmouseleave="dx_leave(this,'+ cmkr_x +')" ' +
				'onmousedown="ignore(event)" onmousemove="ignore(event)" onmouseup="ignore(event)" ontouchmove="ignore(event)" ontouchend="ignore(event)" ' +
				'onclick="dx_click(event,'+ gid +')" ontouchstart="dx_click(event,'+ gid +')" name="'+ ((params == '')? 0:1) +'">' +
			'</div>' +
			'<div class="class-dx-line" id="'+dx_idx+'-id-dx-line" style="left:'+x+'px; top:'+t+'px; height:'+h+'px; z-index:110"></div>';
		//console.log(s);
		
		dx_z++;
	}
	//console.log(dx.displayed);
	
	dx_div.innerHTML = s;

	for (i = 1; i < arr.length; i++) {
		obj = arr[i];
		dx_idx = i-1;
		var ident = obj.i;
		var notes = (isDefined(obj.n))? obj.n : '';
		//var params = (isDefined(obj.p))? obj.p : '';
		var el = w3_el(dx_idx +'-id-dx-label');
		
		try {
			el.innerHTML = decodeURIComponent(ident);
		} catch(ex) {
			el.innerHTML = 'bad URI decode';
		}
		
		try {
			el.title = decodeURIComponent(notes);
		} catch(ex) {
			el.title = 'bad URI decode';
		}
		
		// FIXME: merge this with the concept of labels that are TOD sensitive (e.g. SW BCB schedules)	
		if (ident == 'IBP' || ident == 'IARU%2fNCDXF') {
			var off = dx_ibp_freqs[Math.trunc(freq / 1000)];
			dx_ibp_list.push({ idx:dx_idx, off:off });
			kiwi_clearInterval(dx_ibp_interval);
			dx_ibp_interval = setInterval(function() {
				var d = new Date(dx_ibp_server_time_ms + (Date.now() - dx_ibp_local_time_epoch_ms));
				var min = d.getMinutes();
				var sec = d.getSeconds();
				var rsec = sec % 10;
				if ((rsec == 0) && dx_ibp_lastsec == 9) {
					var slot = (min % 3) * 6 + Math.trunc(sec/10);
					for (var i=0; i < dx_ibp_list.length; i++) {
						var s = slot - dx_ibp_list[i].off;
						if (s < 0) s = 18 + s;
						//console.log('IBP '+ min +':'+ sec +' slot='+ slot +' off='+ off +' s='+ s +' '+ dx_ibp[s*2] +' '+ dx_ibp[s*2+1]);
						
						// label may now be out of DOM if we're panning & zooming around
						var el = w3_el(dx_ibp_list[i].idx +'-id-dx-label');
						if (el) el.innerHTML = 'IBP: '+ dx_ibp[s*2] +' '+ dx_ibp[s*2+1];
					}
					//IBP_monitor(slot);
				}
				dx_ibp_lastsec = rsec;
			}, 500);
		}
	}
}

function dx_filter()
{
	var s =
		w3_div('w3-medium w3-text-aqua w3-bold', 'DX label filter') +
		w3_divs('w3-text-aqua',
		   w3_col_percent('',
            w3_divs('/w3-margin-T-8',
               w3_input('w3-label-inline/id-dx-filter-ident w3-retain-input-focus w3-input-any-change w3-padding-small', 'Ident', 'dx.filter_ident', dx.filter_ident, 'dx_filter_cb'),
               w3_input('w3-label-inline/id-dx-filter-notes w3-retain-input-focus w3-input-any-change w3-padding-small', 'Notes', 'dx.filter_notes', dx.filter_notes, 'dx_filter_cb')
            ), 90
         ),
         w3_inline('w3-halign-space-around w3-margin-T-8 w3-text-white/',
            w3_checkbox('w3-retain-input-focus w3-label-inline w3-label-not-bold', 'case sensitive', 'dx.filter_case', dx.filter_case, 'dx_filter_opt_cb'),

            // Wildcard pattern matching, in addition to grep, is implemented. But currently checkbox is not shown because
            // there is no clear advantage in using it. E.g. it doesn't do partial matching like grep. So you have to type
            // "*pattern*" to duplicate what simply typing "pattern" to grep would do. Neither of them has the syntax of e.g.
            // simple search engines which is what the user probably really wants.
            w3_inline('',
               w3_text('', 'pattern match:'),
               //w3_checkbox('w3-retain-input-focus w3-label-inline w3-label-not-bold', 'wildcard', 'dx.filter_wild', dx.filter_wild, 'dx_filter_opt_cb'),
               w3_checkbox('w3-margin-left w3-retain-input-focus w3-label-inline w3-label-not-bold', 'grep', 'dx.filter_grep', dx.filter_grep, 'dx_filter_opt_cb')
            )
         )
      );

   confirmation_show_content(s, 450, 140, dx_filter_panel_close);
   w3_field_select('id-dx-filter-ident', {mobile:1});    // select the field
}

// Use a custom panel close routine because we need to remove focus if any of our elements are the
// active element at close time. This is due to how the w3-retain-input-focus logic works to keep
function dx_filter_panel_close()
{
   //console.log('dx_filter_panel_close');
   var ae = document.activeElement;
   //console.log(ae);
   if (ae && ae.id && (ae.id.startsWith('id-dx-filter') || ae.id.startsWith('id-dx.filter'))) {
      //console.log('### activeElement='+ ae.id);
      ae.blur();
   }

   confirmation_panel_close();
}

function dx_filter_cb(path, val, first, no_close)
{
   if (first) return;
	w3_string_cb(path, val);
	var filtered = (dx.filter_ident != '' || dx.filter_notes != '');
   //console.log('dx_filter_cb path='+ path +' val='+ val +' filtered='+ filtered);
   //console.log('DX_FILTER ident=<'+ dx.filter_ident +'> notes=<'+ dx.filter_notes +
   //   '> case='+ dx.filter_case +' wild='+ dx.filter_wild +' grep='+ dx.filter_grep);
	wf_send('SET DX_FILTER i='+ encodeURIComponent(dx.filter_ident +'x') +' n='+ encodeURIComponent(dx.filter_notes +'x') +
	   ' c='+ dx.filter_case +' w='+ dx.filter_wild +' g='+ dx.filter_grep);
	w3_remove_then_add('id-dx-container', 'whiteSmoke cl-dx-filtered', filtered? 'cl-dx-filtered' : 'whiteSmoke');
	if (!filtered && !no_close) dx_filter_panel_close();
}

function dx_filter_opt_cb(path, val, first)
{
   if (first) return;
   val = +val;
   w3_bool_cb(path, val);
   
   // changing e.g. grep checkbox may clear ident/notes field error condition, so call dx_filter_cb() to update
   // pass "no_close = true" to prevent panel closing if fields empty
   dx_filter_cb('dx.filter_ident', dx.filter_ident, false, /* no_close */ true);

   //console.log('dx_filter_opt_cb path='+ path +' val='+ val);
   w3_checkbox_set(path, val);
   
   // wild and grep are exclusive
   if (val && path != 'dx.filter_case') {
      dx_filter_opt_cb((path == 'dx.filter_wild')? 'dx.filter_grep' : 'dx.filter_wild', 0);
   }
   w3_field_select('id-dx-filter-ident', {mobile:1});    // reselect the field
}

function dx_filter_field_err(err)
{
   //console.log('dx_filter_field_err='+ err);
   w3_set_props('id-dx-filter-ident', 'w3-pink', err & 1);
   w3_set_props('id-dx-filter-notes', 'w3-pink', err & 2);
}

// Step to next/prev visible label.
// If at display extremes request that server search for next available label (possibly filtered).
function dx_label_step(dir)
{
   //console.log('dx_label_step f='+ freq_car_Hz +'/'+ freq_displayed_Hz +' m='+ cur_mode);
   var i, dl;

   if (dir == 1) {
      for (i = 0; i < dx.displayed.length; i++) {
         dl = dx.displayed[i];
         var f = Math.round(dl.freq * 1e3);
         //console.log('consider #'+ i +' '+ f);
         if (f > freq_displayed_Hz) break;
      }
      if (i == dx.displayed.length) {
	      wf_send('SET MARKER dir=1 freq='+ (freq_displayed_Hz/1e3).toFixed(3));
         return;
      }
   } else {
      for (i = dx.displayed.length - 1; i >= 0 ; i--) {
         dl = dx.displayed[i];
         var f = Math.round(dl.freq * 1e3);
         //console.log('consider #'+ i +' '+ f);
         if (f < freq_displayed_Hz) break;
      }
      if (i < 0) {
	      wf_send('SET MARKER dir=-1 freq='+ (freq_displayed_Hz/1e3).toFixed(3));
         return;
      }
   }
   
   // after changing display to this frequency the normal dx_schedule_update() process will
   // acquire a new set of labels
   var mode = kiwi.modes_l[dl.flags & DX_MODE];
   //console.log('FOUND #'+ i +' '+ f +' '+ dl.ident +' '+ mode +' '+ dl.lo +' '+ dl.hi);
   freqmode_set_dsp_kHz(dl.freq, mode);
   if (dl.lo != 0 && dl.hi != 0) {
      ext_set_passband(dl.lo, dl.hi);     // label has custom pb
   } else {
      var dpb = passbands[mode];
      //console.log(dpb);
      ext_set_passband(dpb.lo, dpb.hi);   // need to force default pb in case cpb is not default
   }
}

var dx_panel_customize = false;
var dx_keys;

// note that an entry can be cloned by selecting it, but then using the "add" button instead of "modify"
function dx_show_edit_panel(ev, gid)
{
	dx_keys = ev? { shift:ev.shiftKey, alt:ev.altKey, ctrl:ev.ctrlKey, meta:ev.metaKey } : { shift:0, alt:0, ctrl:0, meta:0 };
	dxo.gid = gid;
	
	if (!dx_panel_customize) {
		html('id-ext-controls').className = 'class-panel class-dx-panel';
		dx_panel_customize = true;
	}
	
	//console.log('dx_show_edit_panel ws='+ ws_wf.stream);
	admin_pwd_query(function() {
      dx_show_edit_panel2();
	});
}

/*
	UI improvements:
		tab between fields
*/

function dx_show_edit_panel2()
{
	var gid = dxo.gid;
	
	if (gid == -1) {
		//console.log('DX EDIT new entry');
		//console.log('DX EDIT new f='+ freq_car_Hz +'/'+ freq_displayed_Hz +' m='+ cur_mode);
		dxo.f = freq_displayed_kHz_str;
		dxo.lo = dxo.hi = dxo.o = 0;
		dxo.m = kiwi.modes_s[cur_mode];
		dxo.y = types_s.active;
		dxo.i = dxo.n = dxo.p = '';
	} else {
		//console.log('DX EDIT entry #'+ gid +' prev: f='+ dx_list[gid].freq +' flags='+ dx_list[gid].flags.toHex() +' i='+ dx_list[gid].ident +' n='+ dx_list[gid].notes);
		dxo.f = dx_list[gid].carrier.toFixed(2);		// starts as a string, validated to be a number
      dxo.lo = dx_list[gid].lo;
      dxo.hi = dx_list[gid].hi;
		dxo.o = dx_list[gid].moff;
		dxo.m = (dx_list[gid].flags & DX_MODE);
		dxo.y = ((dx_list[gid].flags & DX_TYPE) >> DX_TYPE_SFT);

		try {
			dxo.i = decodeURIComponent(dx_list[gid].ident);
		} catch(ex) {
			dxo.i = 'bad URI decode';
		}
	
		try {
			dxo.n = decodeURIComponent(dx_list[gid].notes);
		} catch(ex) {
			dxo.n = 'bad URI decode';
		}
	
		try {
			dxo.p = decodeURIComponent(dx_list[gid].params);
		} catch(ex) {
			dxo.p = 'bad URI decode';
		}
	
		//console.log('dxo.i='+ dxo.i +' len='+ dxo.i.length);
	}
	//console.log(dxo);
	
	// quick key combo to toggle 'active' mode without bringing up panel
	if (gid != -1 && dx_keys.shift && dx_keys.alt) {
		//console.log('DX COMMIT quick-active entry #'+ dxo.gid +' f='+ dxo.f);
		//console.log(dxo);
		var type = dxo.y;
		type = (type == types_s.active)? types_s.watch_list : types_s.active;
		dxo.y = type;
		var mode = dxo.m;
		mode |= (type << DX_TYPE_SFT);
		wf_send('SET DX_UPD g='+ dxo.gid +' f='+ dxo.f +' lo='+ dxo.lo.toFixed(0) +' hi='+ dxo.hi.toFixed(0) +' o='+ dxo.o.toFixed(0) +' m='+ mode +
			' i='+ encodeURIComponent(dxo.i +'x') +' n='+ encodeURIComponent(dxo.n +'x') +' p='+ encodeURIComponent(dxo.p +'x'));
		return;
	}

	extint_panel_hide();		// committed to displaying edit panel, so remove any ext panel
	
	dxo.f = (parseFloat(dxo.f) + cfg.freq_offset).toFixed(2);
	
	dxo.pb = '';
	if (dxo.lo || dxo.hi) {
      if (dxo.lo == -dxo.hi) {
         dxo.pb = (Math.abs(dxo.hi)*2).toFixed(0);
      } else {
         dxo.pb = dxo.lo.toFixed(0) +', '+ dxo.hi.toFixed(0);
      }
	}

	var s =
		w3_div('w3-medium w3-text-aqua w3-bold', 'DX label edit') +
		w3_divs('w3-text-aqua/w3-margin-T-8',
         w3_inline('w3-halign-space-between/',
				w3_input('w3-padding-small||size=8', 'Freq', 'dxo.f', dxo.f, 'dx_num_cb'),
				w3_select('|color:red', 'Mode', '', 'dxo.m', dxo.m, kiwi.modes_u, 'dx_sel_cb'),
				w3_input('w3-padding-small||size=10', 'Passband', 'dxo.pb', dxo.pb, 'dx_passband_cb'),
				w3_select('|color:red', 'Type', '', 'dxo.y', dxo.y, types, 'dx_sel_cb'),
				w3_input('w3-padding-small||size=8', 'Offset', 'dxo.o', dxo.o, 'dx_num_cb')
			),
		
			w3_input('w3-label-inline/w3-padding-small w3-retain-input-focus', 'Ident', 'dxo.i', '', 'dx_string_cb'),
			w3_input('w3-label-inline/w3-padding-small', 'Notes', 'dxo.n', '', 'dx_string_cb'),
			w3_input('w3-label-inline/w3-padding-small', 'Extension', 'dxo.p', '', 'dx_string_cb'),
		
			w3_inline('w3-hspace-16',
				w3_button('w3-yellow', 'Modify', 'dx_modify_cb'),
				w3_button('w3-green', 'Add', 'dx_add_cb'),
				w3_button('w3-red', 'Delete', 'dx_delete_cb'),
				w3_text('', 'Create new label with Add button')
			)
		);
	
	// can't do this as initial val passed to w3_input above when string contains quoting
	ext_panel_show(s, null, function() {
		var el = w3_el('dxo.i');
		el.value = dxo.i;
		w3_el('dxo.n').value = dxo.n;
		w3_el('dxo.p').value = dxo.p;
		
		// change focus to input field
		// FIXME: why doesn't field select work?
		//console.log('dxo.i='+ el.value);
		w3_field_select(el, {mobile:1});
	});
	ext_set_controls_width_height(550, 260);
}

function dx_close_edit_panel(id)
{
	w3_radio_unhighlight(id);
	extint_panel_hide();
	
	// NB: Can't simply do a dx_schedule_update() here as there is a race for the server to
	// update the dx list before we can pull it again. Instead, the add/modify/delete ajax
	// response will call dx_update() directly when the server has updated.
}

function dx_modify_cb(id, val)
{
	//console.log('DX COMMIT modify entry #'+ dxo.gid +' f='+ dxo.f);
	//console.log(dxo);
	if (dxo.gid == -1) return;
	var mode = dxo.m;
	var type = dxo.y << DX_TYPE_SFT;
	mode |= type;
	dxo.f -= cfg.freq_offset;
	if (dxo.f < 0) dxo.f = 0;
	wf_send('SET DX_UPD g='+ dxo.gid +' f='+ dxo.f +' lo='+ dxo.lo.toFixed(0) +' hi='+ dxo.hi.toFixed(0) +' o='+ dxo.o.toFixed(0) +' m='+ mode +
		' i='+ encodeURIComponent(dxo.i +'x') +' n='+ encodeURIComponent(dxo.n +'x') +' p='+ encodeURIComponent(dxo.p +'x'));
	setTimeout(function() {dx_close_edit_panel(id);}, 250);
}

function dx_add_cb(id, val)
{
	//console.log('DX COMMIT new entry');
	//console.log(dxo);
	var mode = dxo.m;
	var type = dxo.y << DX_TYPE_SFT;
	mode |= type;
	dxo.f -= cfg.freq_offset;
	if (dxo.f < 0) dxo.f = 0;
	wf_send('SET DX_UPD g=-1 f='+ dxo.f +' lo='+ dxo.lo.toFixed(0) +' hi='+ dxo.hi.toFixed(0) +' o='+ dxo.o.toFixed(0) +' m='+ mode +
		' i='+ encodeURIComponent(dxo.i +'x') +' n='+ encodeURIComponent(dxo.n +'x') +' p='+ encodeURIComponent(dxo.p +'x'));
	setTimeout(function() {dx_close_edit_panel(id);}, 250);
	owrx.dx_click_gid_last = undefined;    // because gid's may get renumbered
}

function dx_delete_cb(id, val)
{
	//console.log('DX COMMIT delete entry #'+ dxo.gid);
	//console.log(dxo);
	if (dxo.gid == -1) return;
	wf_send('SET DX_UPD g='+ dxo.gid +' f=-1');
	setTimeout(function() {dx_close_edit_panel(id);}, 250);
	owrx.dx_click_gid_last = undefined;    // because gid's may get renumbered
}

function dx_click(ev, gid)
{
   //event_dump(ev, 'dx_click');
	if (ev.shiftKey) {
		dx_show_edit_panel(ev, gid);
	} else {
	   owrx.dx_click_gid_last = gid;
	   var freq = dx_list[gid].freq;
		var mode = kiwi.modes_l[dx_list[gid].flags & DX_MODE];
		var lo = dx_list[gid].lo;
		var hi = dx_list[gid].hi;
		var params = dx_list[gid].params;
		console.log('### dx_click f='+ dx_list[gid].freq +' mode='+ mode +' cur_mode='+ cur_mode +' lo='+ lo +' hi='+ hi +' params='+ params);

      extint.extname = extint.param = null;
      if (isArg(params)) {
         var ext = (params == '')? [] : decodeURIComponent(params).split(',');
         if (mode == 'drm') {
            extint.extname = 'drm';
            ext.push('lo:'+ lo);    // forward passband info from dx label panel to keep DRM ext from overriding it
            ext.push('hi:'+ hi);
            extint.param = ext.join(',');
         } else {
            extint.extname = ext[0];
            extint.param = ext.slice(1).join(',');
         }
      }
      console.log('### dx_click extname='+ extint.extname +' param=<'+ extint.param +'>');

		freqmode_set_dsp_kHz(freq, mode, { open_ext:true });
		if (lo || hi) {
		   ext_set_passband(lo, hi, false, freq);
		}
		
		// open specified extension
		// setting DRM mode above opens DRM extension
		if (mode != 'drm' && !any_alternate_click_event(ev) && !dx.ctrl_click && dx_list[gid].params) {
		   console.log('### dx_click ext='+ extint.extname +' <'+ extint.param +'>');
			extint_open(extint.extname, 250);
		}
		
		dx.ctrl_click = false;
	}
	return cancelEvent(ev);		// keep underlying canvas from getting event
}

// Any var we add to the div in dx_label() is undefined in the div that appears here,
// so use the number embedded in id="" to create a reference.
// Even the "data-" thing doesn't work.

var dx_z_save, dx_bg_color_save;

function dx_enter(dx, cmkr_x, ev)
{
	dx_z_save = dx.style.zIndex;
	dx.style.zIndex = 999;
	dx_bg_color_save = dx.style.backgroundColor;
	dx.style.backgroundColor = (w3_contains(dx, 'id-has-ext') && !any_alternate_click_event(ev))? 'magenta':'yellow';

	var dx_line = w3_el(parseInt(dx.id)+'-id-dx-line');
	dx_line.zIndex = 998;
	dx_line.style.width = '3px';
	
	if (cmkr_x) {
		dx_canvas.style.left = (cmkr_x-dx_car_w/2)+'px';
		dx_canvas.style.zIndex = 100;
	}
}

function dx_leave(dx, cmkr_x)
{
	dx.style.zIndex = dx_z_save;
	dx.style.backgroundColor = dx_bg_color_save;

	var dx_line = w3_el(parseInt(dx.id)+'-id-dx-line');
	dx_line.zIndex = 110;
	dx_line.style.width = '1px';
	
	if (cmkr_x) {
		dx_canvas.style.zIndex = 99;
	}
}


////////////////////////////////
// s-meter
////////////////////////////////

var smeter_width;
var SMETER_RHS = 38;
var SMETER_SCALE_HEIGHT = 29;
var SMETER_BIAS = 127;
var SMETER_INPUT_MAX = 3.4;
var SMETER_INPUT_RANGE = (SMETER_BIAS + SMETER_INPUT_MAX);
var SMETER_DISPLAY_MAX = -6;     // don't display all the way to SMETER_INPUT_MAX
var SMETER_DISPLAY_RANGE = (SMETER_BIAS + SMETER_DISPLAY_MAX);
var sMeter_dBm_biased = 0;
var sMeter_ctx;
var smeter_ovfl;

// 6 dB / S-unit
var bars = {
	dBm:  [ -121, -109, -97,  -85,  -73,  -63,   -53,   -33,   -13   ],
	text: [ 'S1', 'S3', 'S5', 'S7', 'S9', '+10', '+20', '+40', '+60' ]
};

function smeter_dBm_biased_to_x(dBm_biased)
{
   if (dBm_biased > SMETER_DISPLAY_RANGE)
      dBm_biased = SMETER_DISPLAY_RANGE;     // clamp
	return Math.round(dBm_biased / SMETER_DISPLAY_RANGE * smeter_width);
}

function smeter_init()
{
	w3_innerHTML('id-control-smeter',
		'<canvas id="id-smeter-scale" class="class-smeter-scale" width="0" height="0"></canvas>',
		w3_div('id-smeter-ovfl w3-hide', 'OV'),
		w3_div('id-smeter-dbm-value'),
		w3_div('id-smeter-dbm-units', 'dBm')
	);

	var sMeter_canvas = w3_el('id-smeter-scale');
	smeter_ovfl = w3_el('smeter-ovfl');

	smeter_width = divControl.activeWidth - SMETER_RHS - html_LR_border_pad(sMeter_canvas);   // less our own border/padding
	
	var w = smeter_width, h = SMETER_SCALE_HEIGHT, y=h-8;
	var tw = w + SMETER_RHS;
	sMeter_ctx = sMeter_canvas.getContext("2d");
	sMeter_ctx.canvas.width = tw;
	sMeter_ctx.canvas.height = h;
	sMeter_ctx.fillStyle = "gray";
	sMeter_ctx.globalAlpha = 1;
	sMeter_ctx.fillRect(0,0,tw,h);

	sMeter_ctx.font = "11px Verdana";
	sMeter_ctx.textBaseline = "middle";
	sMeter_ctx.textAlign = "center";
	
	sMeter_ctx.fillStyle = "white";
	for (var i=0; i < bars.text.length; i++) {
		var x = smeter_dBm_biased_to_x(bars.dBm[i] + SMETER_BIAS);
		line_stroke(sMeter_ctx, 1, 3, "white", x,y-8,x,y+8);
		sMeter_ctx.fillText(bars.text[i], x, y-15);
		//console.log("SM x="+x+' dBm='+bars.dBm[i]+' '+bars.text[i]);
	}

	line_stroke(sMeter_ctx, 0, 5, "black", 0,y,w,y);
	setInterval(update_smeter, 100);
}

var sm_px = 0, sm_timeout = 0, sm_interval = 10;
var sm_ovfl_showing = false;

function update_smeter()
{
	var x = smeter_dBm_biased_to_x(sMeter_dBm_biased);
	var y = SMETER_SCALE_HEIGHT-8;
	var w = smeter_width;
	sMeter_ctx.globalAlpha = 1;
	line_stroke(sMeter_ctx, 0, 5, "lime", 0,y,x,y);
	
	if (sm_timeout-- == 0) {
		sm_timeout = sm_interval;
		if (x < sm_px) line_stroke(sMeter_ctx, 0, 5, "black", x,y,sm_px,y);
		//if (x < sm_px) line_stroke(sMeter_ctx, 0, 5, "black", x,y,w,y);
		sm_px = x;
	} else {
		if (x < sm_px) {
			line_stroke(sMeter_ctx, 0, 5, "red", x,y,sm_px,y);
		} else {
			sm_px = x;
			sm_timeout = sm_interval;
		}
	}
	
	if (audio_ext_adc_ovfl && !sm_ovfl_showing) {
	   w3_hide('id-smeter-dbm-units');
	   w3_show('id-smeter-ovfl');
	   sm_ovfl_showing = true;
	} else
	if (!audio_ext_adc_ovfl && sm_ovfl_showing) {
	   w3_hide('id-smeter-ovfl');
	   w3_show('id-smeter-dbm-units');
	   sm_ovfl_showing = false;
	}
	
	w3_innerHTML('id-smeter-dbm-value', (sMeter_dBm_biased - SMETER_BIAS).toFixed(0));
}


////////////////////////////////
// user ident
////////////////////////////////

var ident_tout;
var ident_user = '';
var need_ident = false;

function ident_init()
{
	var ident = initCookie('ident', '');
	ident = kiwi_strip_tags(ident, '');
	//console.log('IINIT ident_user=<'+ ident +'>');
	var el = w3_el('id-ident-input');
	el.value = ident;
	ident_user = ident;
	need_ident = true;
	//console.log('ident_init: SET ident='+ ident_user);
}

function ident_complete()
{
	var el = w3_el('id-ident-input');
	var ident = el.value;
	ident = kiwi_strip_tags(ident, '');
	el.value = ident;
	//console.log('ICMPL el='+ typeof(el) +' ident_user=<'+ ident +'>');
	kiwi_clearTimeout(ident_tout);

	// okay for ident='' to erase it
	// SECURITY: size limited by <input size=...> but guard against binary data injection?
	//w3_field_select(el, {mobile:1});
	freqset_select();    // don't keep ident field selected

	writeCookie('ident', ident);
	ident_user = ident;
	need_ident = true;
	//console.log('ident_complete: SET ident_user='+ ident_user);
}

function ident_keyup(el, evt)
{
	//event_dump(evt, "IKU");
	kiwi_clearTimeout(ident_tout);
	//console.log("IKU el="+ typeof(el) +" val="+ el.value);
	
	// Ignore modifier keys used with mouse events that also appear here.
	// Also keeps ident_complete timeout from being set after return key.
	//if (ignore_next_keyup_event) {
	if (evt != undefined && evt.key != undefined) {
		var klen = evt.key.length;
		if (any_alternate_click_event_except_shift(evt) || klen != 1) {
         //console.log("ignore shift-key ident_keyup");
         //ignore_next_keyup_event = false;
         return;
      }
	}
	
	ident_tout = setTimeout(ident_complete, 5000);
}


////////////////////////////////
// keyboard shortcuts
////////////////////////////////

var shortcut = {
   nav_off: 0,
   keys: '',
   SHIFT: 1,
   CTL_OR_ALT: 2,
   SHIFT_PLUS_CTL_OR_ALT: 3
};

function keyboard_shortcut_init()
{
   if (kiwi_isMobile() || kiwi_isFirefox() < 47 || kiwi_isChrome() <= 49 || kiwi_isOpera() <= 36) return;
   
   shortcut.help =
      w3_div('',
         w3_inline_percent('w3-padding-tiny w3-bold w3-text-aqua', 'Keys', 25, 'Function'),
         w3_inline_percent('w3-padding-tiny', 'g =', 25, 'select frequency entry field'),
         w3_inline_percent('w3-padding-tiny', 'j i LR-arrow-keys', 25, 'frequency step down/up, add shift or alt/ctrl for faster<br>shift plus alt/ctrl to step to next/prev DX label'),
         w3_inline_percent('w3-padding-tiny', 't T UD-arrow-keys', 25, 'scroll frequency memory list'),
         w3_inline_percent('w3-padding-tiny', 'b B', 25, 'scroll band menu'),
         w3_inline_percent('w3-padding-tiny', 'e E', 25, 'scroll extension menu'),
         w3_inline_percent('w3-padding-tiny', 'a A d l u c f q', 25, 'toggle modes: AM SAM DRM LSB USB CW NBFM IQ<br>add alt/ctrl to toggle backwards (e.g. SAM modes)'),
         w3_inline_percent('w3-padding-tiny', 'p P', 25, 'passband narrow/widen'),
         w3_inline_percent('w3-padding-tiny', 'r', 25, 'toggle audio recording'),
         w3_inline_percent('w3-padding-tiny', 'z Z', 25, 'zoom in/out, add alt/ctrl for max in/out'),
         w3_inline_percent('w3-padding-tiny', '< >', 25, 'waterfall page down/up'),
         w3_inline_percent('w3-padding-tiny', 'w W', 25, 'waterfall min dB slider -/+ 1 dB, add alt/ctrl for -/+ 10 dB'),
         w3_inline_percent('w3-padding-tiny', 'S', 25, 'waterfall auto-scale'),
         w3_inline_percent('w3-padding-tiny', 's D', 25, 'spectrum on/off toggle, slow device mode'),
         w3_inline_percent('w3-padding-tiny', 'v V m space', 25, 'volume less/more, mute'),
         w3_inline_percent('w3-padding-tiny', 'o', 25, 'toggle between option bar "off" and "stats" mode,<br>others selected by related shortcut key'),
         w3_inline_percent('w3-padding-tiny', '!', 25, 'toggle aperture manual/auto menu'),
         w3_inline_percent('w3-padding-tiny', '@', 25, 'DX label filter'),
         w3_inline_percent('w3-padding-tiny', 'x y', 25, 'toggle visibility of control panels, top bar'),
         w3_inline_percent('w3-padding-tiny', 'esc', 25, 'close/cancel action'),
         w3_inline_percent('w3-padding-tiny', '? h', 25, 'toggle this help list'),
         w3_inline_percent('w3-padding-tiny w3-bold w3-text-aqua', '', 25, 'Windows, Linux: use alt, not ctrl'),
         w3_inline_percent('w3-padding-tiny w3-bold w3-text-aqua', '', 25, 'Mac: use ctrl or alt')
      );

	w3_el('id-kiwi-body').addEventListener('keydown', keyboard_shortcut_event, true);
}

function keyboard_shortcut_help()
{
   confirmation_show_content(shortcut.help, 550, 545);   // height +15 per added line
}

// FIXME: animate (light up) control panel icons?

function keyboard_shortcut_nav(nav)
{
   w3_el('id-nav-optbar-'+ nav).click();
   shortcut.nav_click = true;
}

function keyboard_shortcut_key_proc()
{
   if (shortcut.key_i >= shortcut.keys.length) return;
   var key = shortcut.keys[shortcut.key_i];
   //console.log('key='+ key);
   keyboard_shortcut(key, 0, 0);
   shortcut.key_i++;
   setTimeout(keyboard_shortcut_key_proc, 100);
}

function keyboard_shortcut_url_keys()
{
   shortcut.keys = shortcut.keys.split('');
   shortcut.key_i = 0;
   keyboard_shortcut_key_proc();
}

// abcdefghijklmnopqrstuvwxyz `~!@#$%^&*()-_=+[]{}\|;:'"<>? 0123456789.,/:kM
// ..........F.. ............    .                      ... FFFFFFFFFFFFFFFF
// .. ..   ..  F  .  .. ..  .                               F: frequency entry keys
// ABCDEFGHIJKLMNOPQRSTUVWXYZ
// :space: :tab:
//    .

function keyboard_shortcut(key, mod, ctlAlt)
{
   var action = true;
   var mode = ext_get_mode();
   var dir = ctlAlt? -1 : 1;
   shortcut.nav_click = false;
   
   switch (key) {
   
   // mode
   case 'a': mode_button(null, w3_el('id-button-am'), dir); break;
   case 'A': mode_button(null, w3_el('id-button-sam'), dir); break;
   case 'd': ext_set_mode('drm', null, { open_ext:true }); break;
   case 'l': mode_button(null, w3_el('id-button-lsb'), dir); break;
   case 'u': mode_button(null, w3_el('id-button-usb'), dir); break;
   case 'c': mode_button(null, w3_el('id-button-cw'), dir); break;
   case 'f': ext_set_mode('nbfm'); break;
   case 'q': ext_set_mode('iq'); break;
   
   // step
   case 'j': case 'J': case 'ArrowLeft':  if (mod != shortcut.SHIFT_PLUS_CTL_OR_ALT) freqstep(2-mod); else dx_label_step(-1); break;
   case 'i': case 'I': case 'ArrowRight': if (mod != shortcut.SHIFT_PLUS_CTL_OR_ALT) freqstep(3+mod); else dx_label_step(+1); break;
   
   // passband
   case 'p': passband_increment(false); break;
   case 'P': passband_increment(true); break;
   
   // volume/mute
   case 'v': setvolume(1, volume-10); toggle_or_set_mute(0); keyboard_shortcut_nav('audio'); break;
   case 'V': setvolume(1, volume+10); toggle_or_set_mute(0); keyboard_shortcut_nav('audio'); break;
   case 'm':
   case ' ': toggle_or_set_mute(); shortcut.nav_click = true; break;

   // frequency entry / memory list
   case 'g': case '=': freqset_select(); break;
   case 't': freq_up_down_cb(null, 1); break;
   case 'T': freq_up_down_cb(null, 0); break;
   case 'b': band_scroll(1); break;
   case 'B': band_scroll(-1); break;

   // page scroll
   case '<': page_scroll(-page_scroll_amount); break;
   case '>': page_scroll(+page_scroll_amount); break;

   // zoom
   case 'z': zoom_step(ctlAlt? ext_zoom.NOM_IN : ext_zoom.IN); break;
   case 'Z': zoom_step(ctlAlt? ext_zoom.MAX_OUT : ext_zoom.OUT); break;
   
   // waterfall
   case 'w': incr_mindb(1, ctlAlt? -10 : -1); keyboard_shortcut_nav('wf'); break;
   case 'W': incr_mindb(1, ctlAlt? +10 : +1); keyboard_shortcut_nav('wf'); break;
   
   // spectrum
   case 's': toggle_or_set_spec(); keyboard_shortcut_nav('wf'); break;
   case 'S': wf_autoscale_cb(); keyboard_shortcut_nav('wf'); break;
   case 'D': toggle_or_set_slow_dev(); keyboard_shortcut_nav('wf'); break;
   
   // colormap
   case '!': keyboard_shortcut_nav('wf'); wf_aper_cb('wf.aper', wf.aper ^ 1, false); break;

   // misc
   case 'o': keyboard_shortcut_nav(shortcut.nav_off? 'status':'off'); shortcut.nav_off ^= 1; break;
   case 'r': toggle_or_set_rec(); break;
   case 'x': toggle_or_set_hide_panels(); break;
   case 'y': toggle_or_set_hide_topbar(); break;
   case '@': dx_filter(); shortcut.nav_click = true; break;
   case 'e': extension_scroll(1); break;
   case 'E': extension_scroll(-1); break;
   case '?': case 'h': keyboard_shortcut_help(); break;

   default:
      if (key.length == 1) console.log('no shortcut key <'+ key +'>');
      action = false; break;
   
   }
   
   if (action && !shortcut.nav_click) keyboard_shortcut_nav('users');

   ignore_next_keyup_event = true;     // don't trigger e.g. freqset_keyup()/freqset_complete()
}

function keyboard_shortcut_event(evt)
{
   if (evt.target) {
      var k = evt.key;
      
      // ignore esc and Fnn function keys
      if (k == 'Escape' || k.match(/F[1-9][12]?/)) {
         //event_dump(evt, 'Escape-shortcut');
         //console.log('KEY PASS Esc');
         return;
      }
      
      var id = evt.target.id;
      var suffix = '';
      if (id == '') {
         //event_dump(evt, 'shortcut');
         w3_iterate_classList(evt.target, function(className, idx) {
            if (className.startsWith('id-')) {
               id = className;
               suffix = ' (class)';
               //console.log('KEY shortcut className='+ id + suffix +' ###');
            }
         });
      }
      
      //{ event_dump(evt, 'shortcut'); return; }

      var sft = evt.shiftKey;
      var ctl = evt.ctrlKey;
      var alt = evt.altKey;
      var meta = evt.metaKey;
      var ctlAlt = (ctl||alt);
      var mod = (sft && !ctlAlt)? shortcut.SHIFT : ( (!sft & ctlAlt)? shortcut.CTL_OR_ALT : ( (sft && ctlAlt)? shortcut.SHIFT_PLUS_CTL_OR_ALT : 0 ) );

      var field_input_key = (
            (k >= '0' && k <= '9' && !ctl) ||
            k == '.' || k == ',' ||                // ',' is alternate decimal point to '.'
            k == '/' || k == ':' || k == '-' ||    // for passband spec, have to allow for negative passbands (e.g. lsb)
            k == 'k' || k == 'M' ||                // scale modifiers
            k == 'Enter' || k == 'ArrowUp' || k == 'ArrowDown' || k == 'Backspace' || k == 'Delete'
         );

      if (evt.target.nodeName != 'INPUT' || (id == 'id-freq-input' && !field_input_key)) {
         
         // don't interfere with the meta key shortcuts of the browser
         if (kiwi_isOSX()) {
            if (meta) {
               //console.log('ignore OSX META '+ (k? k:''));
               return;
            }
         } else {
            if (ctl) {
               //console.log('ignore non-OSX CTL '+ (k? k:''));
               return;
            }
         }
         
         // evt.key isn't what you'd expect when evt.altKey
         if (alt && !k.startsWith('Arrow')) {
            //event_dump(evt, 'shortcut alt');
            k = String.fromCharCode(evt.keyCode).toLowerCase();
            if (sft) k = k.toUpperCase();
            //console.log('shortcut alt k='+ k);
         }
         
         keyboard_shortcut(k, mod, ctlAlt);
         
         /*
         if (k != 'Shift' && k != 'Control' && evt.key != 'Alt') {
            if (!action) event_dump(evt, 'shortcut');
            console.log('KEY SHORTCUT <'+ k +'> '+ (sft? 'SFT ':'') + (ctl? 'CTL ':'') + (alt? 'ALT ':'') + (meta? 'META ':'') +
               ((evt.target.nodeName == 'INPUT')? 'id-freq-input' : evt.target.nodeName) +
               (action? ' ACTION':''));
         }
         */

         cancelEvent(evt);
         return;
      } else {
         //console.log('KEY INPUT FIELD <'+ k +'> '+ id + suffix);
      }
   } else {
      //console.log('KEY no EVT');
   }
}

function extension_scroll(dir)
{
   console.log('extension_scroll dir='+ dir);
   console.log(extint_names);
   var el = w3_el('id-select-ext');
   console.log(el);
   var ext_menu = el.childNodes;
   console.log(ext_menu);
   var menu;

   // ext_menu[i: 1..n+1] for value = "0".."n"
   // value = "-1" when menu has no selection
   var i = (+el.value)+1;
   console.log('extension_scroll initial i='+ i);

   do {
      i += dir;
      if (i < 1) i = ext_menu.length - 1;
      if (i >= ext_menu.length) i = 1;
      menu = ext_menu[i];
   } while (menu.disabled);
   
   var value = +(menu.value);
   var idx = +(menu.getAttribute('kiwi_idx'));
   console.log('extension_scroll i='+ i +' val='+ value +' idx='+ idx +' '+ menu.innerHTML);
   w3_select_value('id-select-ext', value);
   if (owrx.sel_ext_to) kiwi_clearTimeout(owrx.sel_ext_to);
   owrx.sel_ext_to = setTimeout(function() { extint_select(value); }, 2000);
}


////////////////////////////////
// panels
////////////////////////////////

var panel_margin = 10;
var ac_play_button;

function test_audio_suspended()
{
   //console.log('AudioContext.state='+ ac_play_button.state);
   if (ac_play_button.state != "running") {
      var s =
         w3_div('id-play-button-container class-overlay-container||onclick="play_button()"',
            w3_div('id-play-button',
               '<img src="gfx/openwebrx-play-button.png" width="150" height="150" /><br><br>' +
               (kiwi_isMobile()? 'Tap to':'Click to') +' start OpenWebRX'
            )
         );
      w3_appendElement('id-main-container', 'div', s);
      el = w3_el('id-play-button');
      el.style.marginTop = px(w3_center_in_window(el));
      //alert('state '+ ac_play_button.state);
   }
}

// called from waterfall_init()
function panels_setup()
{
   var el;
   var s;
   
	w3_el("id-ident").innerHTML =
		'<form id="id-ident-form" action="#" onsubmit="ident_complete(); return false;">' +
			w3_input('w3-label-not-bold/id-ident-input|padding:1px|size=20 onkeyup="ident_keyup(this, event)"', 'Your name or callsign:', 'ident-input') +
		'</form>';
	
	w3_el("id-control-freq1").innerHTML =
	   w3_inline('',
         w3_div('id-freq-cell',
            '<form id="id-freq-form" name="form_freq" action="#" onsubmit="freqset_complete(0); return false;">' +
               w3_input('id-freq-input|padding:0 4px;max-width:74px|size=8 onkeydown="freqset_keydown(event)" onkeyup="freqset_keyup(this, event)"', '', 'freq-input') +
            '</form>'
         ),

         w3_div('|padding:0 0 0 3px',
            w3_icon('w3-show-block w3-text-orange||title="prev"', 'fa-arrow-circle-up', 15, '', 'freq_up_down_cb', 1) +
            w3_icon('w3-show-block w3-text-aqua||title="next"', 'fa-arrow-circle-down', 15, '', 'freq_up_down_cb', 0)
         ),

         w3_div('id-select-band-cell|padding:0 4px',
            '<select id="id-select-band" class="w3-pointer" onchange="select_band(this.value)">' +
               '<option value="0" selected disabled>select band</option>' +
               setup_band_menu() +
            '</select>'
         ),

         w3_div('id-select-ext-cell|padding:0',
            '<select id="id-select-ext" class="w3-pointer" onchange="freqset_select(); extint_select(this.value)">' +
               '<option value="-1" selected disabled>extension</option>' +
               extint_select_build_menu() +
            '</select>'
         )
      );

   // Because we don't know exactly when audio_init() will be called,
   // we create a new audio context here and check for the suspended state
   // if no-autoplay mode is in effect.
   // That determines if the "click to start" overlay is displayed or not.
   // If it is, then when it is clicked an attempt is made to resume() the
   // audio context that has most likely been setup by audio_init()
   // in the interim.
   try {
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      ac_play_button = new AudioContext();
      
      // Safari has to play something before audioContext.state is valid
      if (kiwi_isSafari()) {
         var bufsrc = ac_play_button.createBufferSource();
         bufsrc.connect(ac_play_button.destination);
         try { bufsrc.start(0); } catch(ex) { bufsrc.noteOn(0); }
      }
      
      setTimeout(test_audio_suspended, 500);    // check after a delay
   } catch(e) {
      console.log('#### no AudioContext?');
   }
	
	w3_el("id-control-freq2").innerHTML =
	   w3_inline('w3-halign-space-between w3-margin-T-4/',
         w3_div('id-mouse-freq',
            w3_div('id-mouse-unit', '-----.--')
         ),
         w3_div('id-link-cell',
            w3_div('id-freq-link|padding-left:0px')
         ),
         w3_div('id-9-10-cell',
            w3_div('id-button-9-10 class-button-small||title="LW/MW 9/10 kHz tuning step" onclick="button_9_10()"', '10')
         ),
         w3_div('id-step-freq',
            '<img id="id-step-0" src="icons/stepdn.20.png" onclick="freqstep(0)" />',
            '<img id="id-step-1" src="icons/stepdn.18.png" onclick="freqstep(1)" style="padding-bottom:1px" />',
            '<img id="id-step-2" src="icons/stepdn.16.png" onclick="freqstep(2)" style="padding-bottom:2px" />',
            '<img id="id-step-3" src="icons/stepup.16.png" onclick="freqstep(3)" style="padding-bottom:2px" />',
            '<img id="id-step-4" src="icons/stepup.18.png" onclick="freqstep(4)" style="padding-bottom:1px" />',
            '<img id="id-step-5" src="icons/stepup.20.png" onclick="freqstep(5)" />'
         ),
         w3_div('',
            w3_button('id-button-spectrum class-button', 'Spec', 'toggle_or_set_spec')
         ),
         w3_div('',
            w3_div('fa-stack||title="record"',
               w3_icon('id-rec1', 'fa-circle fa-nudge-down fa-stack-2x w3-text-pink', 22, '', 'toggle_or_set_rec'),
               w3_icon('id-rec2', 'fa-stop fa-stack-1x w3-text-pink w3-hide', 10, '', 'toggle_or_set_rec')
            )
         ),
         w3_div('|width:8%|title="mute"',
            // from https://jsfiddle.net/cherrador/jomgLb2h since fa doesn't have speaker-slash
            w3_div('id-mute-no fa-stack|width:100%; color:lime',
               w3_icon('', 'fa-volume-up fa-stack-2x fa-nudge-right-OFF', 24, 'inherit', 'toggle_or_set_mute')
            ),
            w3_div('id-mute-yes fa-stack w3-hide|width:100%;color:magenta;',  // hsl(340, 82%, 60%) w3-text-pink but lighter
               w3_icon('', 'fa-volume-off fa-stack-2x fa-nudge-left', 24, '', 'toggle_or_set_mute'),
               w3_icon('', 'fa-times fa-right fa-nudge-left-OFF', 12, '', 'toggle_or_set_mute')
            )
         )
      );
	
	if (!isNaN(override_9_10)) {
		step_9_10 = override_9_10;
		//console.log('STEP_9_10 init to override: '+ override_9_10);
	} else {
		var init_AM_BCB_chan = ext_get_cfg_param('init.AM_BCB_chan');
		if (init_AM_BCB_chan == null || init_AM_BCB_chan == undefined) {
			step_9_10 = 0;
			//console.log('STEP_9_10 init to default: 0');
		} else {
			step_9_10 = init_AM_BCB_chan? 0 : 1;
			//console.log('STEP_9_10 init from admin: '+ step_9_10);
		}
	}
	
	button_9_10(step_9_10);

	s = '';
   mode_buttons.forEach(
	   function(mba, i) {
	      var ms = mba.s[0];
	      var mslc = ms.toLowerCase();
	      var disabled = mba.dis || (mslc == 'drm' && !kiwi.DRM_enable);
	      var attr = disabled? '' : ' onclick="mode_button(event, this)"';
	      attr += ' onmouseover="mode_over(event, this)"';
	      s += w3_div('id-button-'+ mslc + ' id-mode-'+ mslc.substr(0,2) +
	         ' class-button'+ (disabled? ' class-button-disbled':'') +
	         ' ||id="'+ i +'-id-mode-col"' + attr + ' onmousedown="cancelEvent(event)"', ms);
	   });
	w3_el("id-control-mode").innerHTML = w3_inline('w3-halign-space-between/', s);

   var d = wf.audioFFT_active? ' w3-disabled' : '';
   var d2 = wf.audioFFT_active? ' w3-disabled||onclick="audioFFT_update()"' : '';

	w3_el("id-control-zoom").innerHTML =
	   w3_inline('w3-halign-space-between/',
         w3_div('id-zoom-in class-icon'+ d +'||onclick="zoom_click(event,1)" onmouseover="zoom_over(event)" title="zoom in"', '<img src="icons/zoomin.png" width="32" height="32" />'),
         w3_div('id-zoom-out class-icon'+ d +'||onclick="zoom_click(event,-1)" onmouseover="zoom_over(event)" title="zoom out"', '<img src="icons/zoomout.png" width="32" height="32" />'),
         w3_div('id-maxin'+ d2,
            w3_div('class-icon||onclick="zoom_click(event,8)" title="max in"', '<img src="icons/maxin.png" width="32" height="32" />')
         ),
         w3_div('id-maxin-nom w3-hide'+ d2,
            w3_div('class-icon||onclick="zoom_click(event,8)" title="max in"', '<img src="icons/maxin.nom.png" width="32" height="32" />')
         ),
         w3_div('id-maxin-max w3-hide'+ d2,
            w3_div('class-icon||onclick="zoom_click(event,8)" title="max in"', '<img src="icons/maxin.max.png" width="32" height="32" />')
         ),
         w3_div('id-maxout'+ d2,
            w3_div('class-icon||onclick="zoom_click(event,-9)" title="max out"', '<img src="icons/maxout.png" width="32" height="32" />')
         ),
         w3_div('id-maxout-max w3-hide'+ d2,
            w3_div('class-icon||onclick="zoom_click(event,-9)" title="max out"', '<img src="icons/maxout.max.png" width="32" height="32" />')
         ),
         w3_div('class-icon'+ d +'||onclick="zoom_click(event,0)" title="zoom to band"',
            '<img src="icons/zoomband.png" width="32" height="16" style="padding-top:13px; padding-bottom:13px;"/>'
         ),
         w3_div('class-icon'+ d +'||onclick="page_scroll_icon_click(event,'+ -page_scroll_amount +')" title="page down\nalt: label step"', '<img src="icons/pageleft.png" width="32" height="32" />'),
         w3_div('class-icon'+ d +'||onclick="page_scroll_icon_click(event,'+ page_scroll_amount +')" title="page up\nalt: label step"', '<img src="icons/pageright.png" width="32" height="32" />')
		);


   // optbar
   var optbar_colors = [
      'w3-pink',
      'w3-blue',
      'w3-purple',
      'w3-aqua',
      'w3-yellow',
      //'w3-grey-white',
      'w3-black',
      'w3-red',
      'w3-khaki',
      'w3-green',
      'w3-orange',
      'w3-lime',
      'w3-indigo',
      'w3-brown',
      'w3-teal'
   ];
	var ci = 0;
	
	var psa1 = ' w3-center|width:15.2%';
	var psa2 = psa1 + ';margin-right:6px';
	w3_el('id-optbar').innerHTML =
      w3_navbar('cl-optbar',
         // will call optbar_focus() optbar_blur() when navbar clicked
         w3_navdef(optbar_colors[ci++] + psa2, 'WF', 'optbar-wf', 'optbar'),
         w3_nav(optbar_colors[ci++] + psa2, 'Audio', 'optbar-audio', 'optbar'),
         w3_nav(optbar_colors[ci++] + psa2, 'AGC', 'optbar-agc', 'optbar'),
         w3_nav(optbar_colors[ci++] + psa2, 'Users', 'optbar-users', 'optbar'),
         w3_nav(optbar_colors[ci++] + psa2, 'Stats', 'optbar-status', 'optbar'),
         w3_nav(optbar_colors[ci++] + psa1, 'Off', 'optbar-off', 'optbar')
      );


	wf_filter = readCookie('last_wf_filter', wf_sp_menu_e.OFF);
	spec_filter = readCookie('last_spec_filter', wf_sp_menu_e.IIR);
	
   if (isString(spectrum_show)) {
      var ss = spectrum_show.toLowerCase();
      wf_sp_menu_s.forEach(function(e, i) { if (ss == e.toLowerCase()) spec_filter = i; });
   }
   
   wf.max_min_sliders =
      w3_col_percent('w3-valign/class-slider',
         w3_text(optbar_prefix_color, 'WF max'), 19,
         '<input id="id-input-maxdb" type="range" min="-100" max="20" value="'+ maxdb
            +'" step="1" onchange="setmaxdb(1,this.value)" oninput="setmaxdb(0,this.value)">', 60,
         w3_div('id-field-maxdb class-slider'), 19
      ) +
      w3_col_percent('w3-valign/class-slider',
         w3_text(optbar_prefix_color, 'WF min'), 19,
         '<input id="id-input-mindb" type="range" min="-190" max="-30" value="'+ mindb
            +'" step="1" onchange="setmindb(1,this.value)" oninput="setmindb(0,this.value)">', 60,
         w3_div('id-field-mindb class-slider'), 19
      );

   wf.floor_ceil_sliders =
      w3_col_percent('w3-valign/class-slider',
         w3_text(optbar_prefix_color, 'WF ceil'), 19,
         '<input id="id-input-ceildb" type="range" min="-30" max="30" value="'+ wf.auto_ceil.val
            +'" step="5" onchange="setceildb(1,this.value)" oninput="setceildb(0,this.value)">', 60,
         w3_div('id-field-ceildb class-slider'), 19
      ) +
      w3_col_percent('w3-valign/class-slider',
         w3_text(optbar_prefix_color, 'WF floor'), 19,
         '<input id="id-input-floordb" type="range" min="-30" max="30" value="'+ wf.auto_floor.val
            +'" step="5" onchange="setfloordb(1,this.value)" oninput="setfloordb(0,this.value)">', 60,
         w3_div('id-field-floordb class-slider'), 19
      );

   // wf
	w3_el("id-optbar-wf").innerHTML =
      w3_div('id-aper-data w3-hide w3-margin-B-5|left:0px; width:256px; height:16px; background-color:#575757; overflow:hidden; position:relative;',
   		'<canvas id="id-aper-canvas" width="256" height="16" style="position:absolute"></canvas>'
      ) +
      
      w3_col_percent('',
         w3_div('',
            w3_div('id-wf-sliders', wf.max_min_sliders),
            
            w3_col_percent('w3-valign/class-slider',
               w3_text(optbar_prefix_color, 'WF rate'), 19,
               '<input id="slider-rate" class="'+ d +'" type="range" min="0" max="4" value="'+
                  wf_speed +'" step="1" onchange="setwfspeed(1,this.value)" oninput="setwfspeed(0,this.value)">', 60,
               w3_div('slider-rate-field class-slider'), 19
            ),

            w3_col_percent('w3-valign/class-slider',
               //w3_text(optbar_prefix_color, 'SP parm'), 19,
               w3_button('id-wf-sp-button class-button w3-font-12px', 'Spec &Delta;', 'toggle_or_set_wf_sp_button'), 19,
               w3_slider('id-wf-sp-slider', '', 'wf_sp_param', wf_sp_param, 0, 10, 1, 'wf_sp_slider_cb'), 60,
               w3_div('id-wf-sp-slider-field class-slider'), 19
            )
         ), 85,
         
         w3_divs('/w3-tspace-4 w3-hcenter w3-font-11_25px',
            w3_button('id-button-wf-autoscale class-button', 'Auto<br>Scale', 'wf_autoscale_cb'),
            w3_button('id-button-slow-dev class-button', 'Slow<br>Dev', 'toggle_or_set_slow_dev'),
            w3_inline('',
               w3_button('id-button-spec-peak class-button', 'Pk', 'toggle_or_set_spec_peak'),
               w3_icon('id-wf-gnd w3-margin-L-4 w3-momentary', 'fa-caret-down', 22, 'white', 'wf_gnd_cb', 1)
            )
         ), 15
      ) +

      w3_inline('w3-halign-space-between w3-margin-T-2/',
         w3_select('|color:red', '', 'colormap', 'wf.cmap', wf.cmap, kiwi.cmap_s, 'wf_cmap_cb'),
         w3_select('|color:red', '', 'aperture', 'wf.aper', wf.aper, kiwi.aper_s, 'wf_aper_cb'),
         //w3_select('|color:red', '', 'contrast', 'wf.contr', W3_SELECT_SHOW_TITLE, wf_contr_s, 'wf_contr_cb'),
         w3_select('|color:red', '', 'wf', 'wf_filter', wf_filter, wf_sp_menu_s, 'wf_sp_menu_cb', 1),
         w3_select('|color:red', '', 'spec', 'spec_filter', spec_filter, wf_sp_menu_s, 'wf_sp_menu_cb', 0)
         //w3_div('w3-hcenter', w3_button('id-button-spec-peak class-button', 'Peak', 'toggle_or_set_spec_peak'))
         //w3_button('id-button-wf-gnd class-button w3-momentary', 'G', 'wf_gnd_cb', 1)
      );

   setwfspeed(1, wf_speed);
   toggle_or_set_slow_dev(toggle_e.FROM_COOKIE | toggle_e.SET, 0);
   toggle_or_set_spec_peak(toggle_e.FROM_COOKIE | toggle_e.SET_URL, peak_initially);
   toggle_or_set_wf_sp_button(toggle_e.FROM_COOKIE | toggle_e.SET, 0);

   // audio & nb
   var nb_algo_s = [ ['off',1], ['std',1], ['Wild',1] ];
   var nr_algo_s = [ ['off',1], ['wdsp',1], ['LMS',1], ['spec',1] ];
	de_emphasis = readCookie('last_de_emphasis', 0);
	pan = readCookie('last_pan', 0);

	w3_el('id-optbar-audio').innerHTML =
		w3_col_percent('w3-valign/',
			w3_div('w3-show-inline-block', w3_text(optbar_prefix_color +' cl-closer-spaced-label-text', 'Noise')), 17,
         w3_select_conditional('|color:red', '', 'blanker', 'nb_algo', 0, nb_algo_s, 'nb_algo_cb'), 24,
			w3_div('w3-hcenter', w3_div('class-button||onclick="extint_open(\'noise_blank\'); freqset_select();"', 'More')), 21,
         w3_select_conditional('|color:red', '', 'filter', 'nr_algo', 0, nr_algo_s, 'nr_algo_cb'), 23,
			w3_div('w3-hcenter', w3_div('class-button||onclick="extint_open(\'noise_filter\'); freqset_select();"', 'More')), 15
		) +
		w3_col_percent('w3-valign w3-margin-T-4/class-slider',
			w3_text(optbar_prefix_color, 'Volume'), 17,
			'<input id="id-input-volume" type="range" min="0" max="200" value="'+ volume +'" step="1" onchange="setvolume(1, this.value)" oninput="setvolume(0, this.value)">', 50,
         '&nbsp;', 8,
         w3_select('|color:red', '', 'de-emp', 'de_emphasis', de_emphasis, de_emphasis_s, 'de_emp_cb')
		) +
      w3_col_percent('id-pan w3-valign w3-hide/class-slider',
         w3_text(optbar_prefix_color, 'Pan'), 17,
         '<input id="id-pan-value" type="range" min="-1" max="1" value="'+ pan +'" step="0.01" onchange="setpan(1,this.value)" oninput="setpan(0,this.value)">', 50,
         '&nbsp;', 3, w3_div('id-pan-field'), 8, '&nbsp;', 7,
		   w3_button('id-button-compression class-button w3-hcenter||title="compression"', 'Comp', 'toggle_or_set_compression')
      ) +
      w3_col_percent('id-squelch w3-valign/class-slider',
			w3_text('id-squelch-label', 'Squelch'), 17,
         w3_slider('', '', 'squelch-value', squelch, 0, 99, 1, 'set_squelch_cb'), 50,
         '&nbsp;', 3, w3_div('id-squelch-field class-slider'), 14,
         w3_select('w3-hide|color:red', '', 'tail', 'squelch_tail', squelch_tail, squelch_tail_s, 'squelch_tail_cb')
	   ) +
      w3_col_percent('id-sam-carrier-container w3-valign w3-hide/class-slider',
         w3_text(optbar_prefix_color, 'SAM'), 17,
         w3_text('id-sam-carrier')
      );

   kiwi_load_js_dir('extensions/', ['noise_blank/noise_blank.js', 'noise_filter/noise_filter.js'],
      function() {
         noise_blank_init();
         noise_filter_init();
      }
   );

   //toggle_or_set_test(0);
   //toggle_or_set_audio(toggle_e.FROM_COOKIE | toggle_e.SET, 1);
   toggle_or_set_compression(toggle_e.FROM_COOKIE | toggle_e.SET, 1);
	squelch_setup(toggle_e.FROM_COOKIE);
   audio_panner_ui_init();


   // agc
	w3_el('id-optbar-agc').innerHTML =
		w3_col_percent('w3-valign/class-slider',
			'<div id="id-button-agc" class="class-button" onclick="toggle_agc(event)" onmousedown="cancelEvent(event)" onmouseover="agc_over(event)">AGC</div>', 13,
			'<div id="id-button-hang" class="class-button" onclick="toggle_or_set_hang();">Hang</div>', 17,
			w3_divs('w3-show-inline-block/id-label-man-gain cl-closer-spaced-label-text', 'Manual<br>gain'), 15,
			'<input id="input-man-gain" type="range" min="0" max="120" value="'+ manGain +'" step="1" onchange="setManGain(1,this.value)" oninput="setManGain(0,this.value)">', 40,
			w3_div('field-man-gain w3-show-inline-block', manGain.toString()) +' dB', 15
		) +
		w3_div('',
			w3_col_percent('w3-valign/class-slider',
				w3_div('label-threshold w3-show-inline-block', 'Threshold'), 18,
				'<input id="input-threshold" type="range" min="-130" max="0" value="'+ thresh +'" step="1" onchange="setThresh(1,this.value)" oninput="setThresh(0,this.value)">', 52,
				w3_div('field-threshold w3-show-inline-block', thresh.toString()) +' dB', 30
			),
			w3_col_percent('w3-valign/class-slider',
				w3_div('label-slope w3-show-inline-block', 'Slope'), 18,
				'<input id="input-slope" type="range" min="0" max="10" value="'+ slope +'" step="1" onchange="setSlope(1,this.value)" oninput="setSlope(0,this.value)">', 52,
				w3_div('field-slope w3-show-inline-block', slope.toString()) +' dB', 30
			),
			w3_col_percent('w3-valign/class-slider',
				w3_div('label-decay w3-show-inline-block', 'Decay'), 18,
				'<input id="input-decay" type="range" min="20" max="5000" value="'+ decay +'" step="1" onchange="setDecay(1,this.value)" oninput="setDecay(0,this.value)">', 52,
				w3_div('field-decay w3-show-inline-block', decay.toString()) +' msec', 30
			)
		);
	setup_agc(toggle_e.FROM_COOKIE | toggle_e.SET);

	
	// users
	
	
	// status
	
	
	// optbar_setup
	//console.log('optbar_setup');
   w3_click_nav(kiwi_toggle(toggle_e.FROM_COOKIE | toggle_e.SET, 'optbar-wf', 'optbar-wf', 'last_optbar'), 'optbar', 'init');
	

	//jksx XDLS pref button
	//if (dbgUs) w3_el('id-button-pref').style.visibility = 'visible';
	//if (dbgUs) toggle_or_set_pref(toggle_e.SET, 1);

	// id-news
	w3_el('id-news').style.backgroundColor = news_color;
	w3_el("id-news-inner").innerHTML =
		'<span style="font-size: 14pt; font-weight: bold;">' +
			'KiwiSDR now available on ' +
			'<a href="https://www.kickstarter.com/projects/1575992013/kiwisdr-beaglebone-software-defined-radio-sdr-with" target="_blank">' +
				'<img class="class-KS" src="icons/kickstarter-logo-light.150x18.png" />' +
			'</a>' +
		'</span>' +
		'';


	// id-readme
	
	el = w3_el('id-readme');
	el.style.backgroundColor = readme_color;

   // Allow a click anywhere in panel to toggle it.
	// Use a capturing click listener, then cancel propagation of the click
	// so vis handler doesn't call toggle_panel() twice.
	/*
	el.addEventListener("click", function(ev) {
	   //console.log('id-readme ev='+ ev);
	   cancelEvent(ev);
	   toggle_panel('id-readme');
	}, true);
	*/

	w3_el("id-readme-inner").innerHTML =
		'<span style="font-size: 15pt; font-weight: bold;">Welcome!</span>' +
		'&nbsp;&nbsp;&nbsp;Project website: <a href="http://kiwisdr.com" target="_blank">kiwisdr.com</a>&nbsp;&nbsp;&nbsp;&nbsp;Here are some tips:' +
		'<ul style="padding-left: 12px;">' +
		'<li> Windows: Firefox, Chrome & Edge work; IE does not work. </li>' +
		'<li> Mac & Linux: Safari, Firefox, Chrome & Opera should work fine. </li>' +
		'<li> Open and close the panels by using the circled arrows at the top right corner. </li>' +
		'<li> You can click and/or drag almost anywhere on the page to change settings. </li>' +
		'<li> Enter a numeric frequency in the box marked "kHz" at right. </li>' +
		'<li> Or use the "select band" menu to jump to a pre-defined band. </li>' +
		'<li> Use the zoom icons to control the waterfall span. </li>' +
		'<li> Tune by clicking on the waterfall, spectrum or the cyan/red-colored station labels. </li>' +
		'<li> Ctrl-shift or alt-shift click in the waterfall to lookup frequency in online databases. </li>' +
		'<li> Control or option/alt click to page spectrum down and up in frequency. </li>' +
		'<li> Adjust the "WF min" slider for best waterfall colors. </li>' +
		'<li> See the <a href="http://www.kiwisdr.com/quickstart/" target="_blank">Operating information</a> page' +
		     'and <a href="https://www.dropbox.com/s/i1bjyp1acghnc16/KiwiSDR.design.review.pdf?dl=1" target="_blank">Design review document</a>. </li>' +
		'</ul>';


	// id-msgs
	
	var contact_admin = ext_get_cfg_param('contact_admin');
	if (isUndefined(contact_admin)) {
		// hasn't existed before: default to true
		//console.log('contact_admin: INIT true');
		contact_admin = true;
	}

	var admin_email = ext_get_cfg_param('admin_email');
	//console.log('contact_admin='+ contact_admin +' admin_email='+ admin_email);
	admin_email = (contact_admin != 'undefined' && contact_admin != null && contact_admin == true && admin_email != 'undefined' && admin_email != null)? admin_email : null;
	
	// NB: have to double encode here because the "javascript:sendmail()" href below automatically undoes
	// one level of encoding causing problems when an email containing an underscore gets enc() to a backslash
	if (admin_email != null) admin_email = encodeURIComponent(encodeURIComponent(enc(admin_email)));

   w3_el('id-optbar-status').innerHTML =
		w3_div('id-status-msg') +
		w3_div('',
	      w3_text(optbar_prefix_color, 'Links'),
	      w3_text('',
            (admin_email? '<a href="javascript:sendmail(\''+ admin_email +'\');">Owner/Admin</a> | ' : '') +
            '<a href="http://kiwisdr.com" target="_blank">KiwiSDR</a> ' +
            '| <a href="http://valentfx.com/vanilla/discussions" target="_blank">Forum</a> ' +
            '| <a href="https://kiwiirc.com/client/chat.freenode.net/#kiwisdr" target="_blank">Chat</a> '
         )
		) +
		w3_div('id-status-adc') +
		w3_div('id-status-config') +
		w3_div('id-status-gps') +
		w3_inline('w3-valign',
		   w3_div('id-status-audio'), ' ',
		   w3_div('id-status-problems')
		) +
		w3_div('id-status-stats-cpu') +
		w3_div('id-status-stats-xfer');

	setTimeout(function() { setInterval(status_periodic, 5000); }, 1000);
}


////////////////////////////////
// option bar
////////////////////////////////

var prev_optbar = null;

function optbar_focus(next_id, cb_arg)
{
   writeCookie('last_optbar', next_id);
   
   var h;
   if (next_id == 'optbar-off') {
      if (cb_arg != 'init' && prev_optbar == 'optbar-off') toggle_or_set_hide_topbar();
      w3_hide('id-optbar-content');
      w3_el('id-control-top').style.paddingBottom = '8px';
   } else {
      w3_show_block('id-optbar-content');
      w3_el('id-control-top').style.paddingBottom = '';     // let id-optbar-content determine all spacing
   }
   w3_el('id-control').style.height = '';    // undo spec in index.html
   prev_optbar = next_id;
   freqset_select();
}

function optbar_blur(cur_id)
{
   //console.log('optbar_blur='+ cur_id);
}


function zoomCorrection()
{
	return 3/*dB*/ * zoom_level;
	//return 0 * zoom_level;		// gives constant noise floor when using USE_GEN
}


////////////////////////////////
// waterfall / spectrum controls
////////////////////////////////

var WF_SPEED_OFF = 0;
var WF_SPEED_1HZ = 1;
var WF_SPEED_SLOW = 2;
var WF_SPEED_MED = 3;
var WF_SPEED_FAST = 4;

var wf_speed = WF_SPEED_FAST;
var wf_speeds = ['off', '1 Hz', 'slow', 'med', 'fast'];

var wf = {
   no_wf: false,
   
   cmap: 0,
   cmap_override: -1,
   custom_colormaps: [ new Uint8Array(3*256), new Uint8Array(3*256), new Uint8Array(3*256), new Uint8Array(3*256) ],

   aper: 0,
   aper_algo: 3,     // OFF
   aper_param: 0,

   sqrt: 0,
   contr: 0,
   last_zoom: -1,
   need_autoscale: 0,
   
   auto_ceil: { min:0, val:5, max:30, def:5 },
   auto_floor: { min:-30, val:-10, max:0, def:-10 },
   auto_maxdb: 0,
   auto_mindb: 0,
   
   audioFFT_active: false,
   audioFFT_prev_mode: '',
   audioFFT_clear_wf: false,
};

var wf_contr_s = { 0:'normal', 1:'scheme 1', 2:'scheme 2', 3:'scheme 3', 4:'scheme 4' };

function wf_contr_cb(path, idx, first)
{
   //console.log('wf_contr_cb idx='+ idx +' first='+ first);
}

var wf_gnd = 0, wf_gnd_value_base = 150, wf_gnd_value = wf_gnd_value_base;

function wf_gnd_cb(path, idx, first)
{
   //console.log('wf_gnd_cb idx='+ idx +' first='+ first);
   idx = +idx;
   w3_color(path, idx? 'white':'lime');
   wf_gnd = !idx;
   if (idx == 0) freqset_select();
}


var wf_sp_param = 0;
var wf_param = 0, sp_param = 0;
var wf_sp_which = 0;   // 0 = spectrum, 1 = waterfall
var wf_filter = 0, spec_filter = 0;
var wf_sp_menu_s = [ 'IIR', 'MMA', 'EMA', 'off' ];
var wf_sp_menu_e = { IIR:0, MMA:1, EMA:2, OFF:3 };
var wf_sp_slider_s = [ 'gain', 'avgs', 'avgs', '' ];

var wf_sp_filter_p = [
   {  // spectrum
      IIR_min:0, IIR_max:1, IIR_step:0.1, IIR_def:0.2, IIR_val:undefined,
      MMA_min:1, MMA_max:32, MMA_step:1, MMA_def:8, MMA_val:undefined,
      EMA_min:1, EMA_max:32, EMA_step:1, EMA_def:8, EMA_val:undefined,
      off_min:0, off_max:0, off_step:0, off_def:0, off_val:undefined
   },
   {  // waterfall
      IIR_min:0, IIR_max:2, IIR_step:0.1, IIR_def:0.8, IIR_val:undefined,
      MMA_min:1, MMA_max:16, MMA_step:1, MMA_def:2, MMA_val:undefined,
      EMA_min:1, EMA_max:16, EMA_step:1, EMA_def:2, EMA_val:undefined,
      off_min:0, off_max:0, off_step:0, off_def:0, off_val:undefined
   }
];

function spec_show()
{
   toggle_or_set_spec(toggle_e.SET, 1);
   
   var sp = -1;
   spectrum_param = parseFloat(spectrum_param);
   if (!isNaN(spectrum_param) && spectrum_param != -1) sp = spectrum_param;
   
   wf_sp_which = 0;
   var f = wf_sp_menu_s[spec_filter];
   var f_p = wf_sp_filter_p[0];
   
   if (sp >= f_p[f+'_min'] && sp <= f_p[f+'_max']) {
      //console.log('spec_show sp='+ sp);
      wf_sp_slider_cb('id-wf-sp-slider', sp, /* done */ true, /* first */ false);
      toggle_or_set_wf_sp_button(toggle_e.SET, 0);
   }
}

function wf_sp_menu_cb(path, idx, first, param)    // param indicated which menu, wf or sp
{
   idx = +idx;
   //console.log('wf_sp_menu_cb ENTER path='+ path +' idx='+ idx +' first='+ first +' which='+ param);
   //kiwi_trace('wf_sp_menu_cb');
   wf_sp_which = +param;
   if (wf_sp_which) wf_filter = idx; else spec_filter = idx;

   var f_val = wf_sp_which? wf_filter : spec_filter;
   var f = wf_sp_menu_s[f_val];
   var f_p = wf_sp_filter_p[wf_sp_which];
   var val = f_p[f+'_val'];
   //console.log('wf_sp_menu_cb which='+ wf_sp_which +' f_val='+ f_val +' f_p='+ f_p +' val='+ val);
   
   // update button and slider to match which menu was changed
   wf_sp_slider_cb('id-wf-sp-slider', val, /* done */ true, /* first */ false);
   toggle_or_set_wf_sp_button(toggle_e.SET, wf_sp_which);
	writeCookie(wf_sp_which? 'last_wf_filter':'last_spec_filter', f_val.toString());

	if (wf_sp_which) need_clear_wfavg = true; else need_clear_specavg = true;
   freqset_select();
   //console.log('wf_sp_menu_cb EXIT path='+ path +' wf_filter='+ wf_filter +' wf_param='+ wf_param +' spec_filter='+ spec_filter +' sp_param='+ sp_param);
}

function spectrum_filter(filter)
{
   wf_sp_menu_cb('', filter, false, 0);
}

function toggle_or_set_wf_sp_button(set, val)
{
   //console.log('toggle_or_set_wf_sp_button ENTER set='+ set +' val='+ val);
   //kiwi_trace('toggle_or_set_wf_sp_button');
	if (isNumber(set))
		wf_sp_which = +kiwi_toggle(set, +val, +val, 'last_wf_sp_filter');
	else
		wf_sp_which ^= 1;

   //console.log('toggle_or_set_wf_sp_button new which='+ wf_sp_which);
	w3_innerHTML('id-wf-sp-button', wf_sp_which? 'WF &Delta;':'Spec &Delta;');

   // update slider 
   var f_val = wf_sp_which? wf_filter : spec_filter;
   var f = wf_sp_menu_s[f_val];
   var f_p = wf_sp_filter_p[wf_sp_which];
   wf_sp_slider_cb('id-wf-sp-slider', f_p[f+'_val'], /* done */ true, /* first */ false);
	freqset_select();
   //console.log('toggle_or_set_wf_sp_button EXIT');
}

function wf_sp_slider_cb(path, val, done, first)
{
   if (first) return;
   val = +val;
   //console.log('wf_sp_slider_cb ENTER path='+ path +' val='+ val +' which='+ wf_sp_which);
   //kiwi_trace('wf_sp_slider_cb');
	var f_val = wf_sp_which? wf_filter : spec_filter;
   var f = wf_sp_menu_s[f_val];
   var f_p = wf_sp_filter_p[wf_sp_which];

   if (val == undefined || isNaN(val)) {
      val = f_p[f+'_def'];
      //console.log('wf_sp_slider_cb using default='+ val +'('+ typeof(val) +') which='+ wf_sp_which);
      var lsf = parseFloat(readCookie(wf_sp_which? 'last_wf_filter':'last_spec_filter'));
      var lsfp = parseFloat(readCookie(wf_sp_which? 'last_wf_filter_param':'last_spec_filter_param'));
      if (lsf == f_val && !isNaN(lsfp)) {
         //console.log('wf_sp_slider_cb USING READ_COOKIE last_filter_param='+ lsfp);
         val = lsfp;
      }
   }

   if (wf_sp_which) wf_param = val; else sp_param = val;
	//console.log('wf_sp_slider_cb UPDATE slider='+ val +' which='+ wf_sp_which +' menu='+ f_val +' done='+ done +' first='+ first);
	f_p[f+'_val'] = val;

   // for benefit of direct callers
   w3_slider_setup('id-wf-sp-slider', f_p[f+'_min'], f_p[f+'_max'], f_p[f+'_step'], val);
   w3_el('id-wf-sp-slider-field').innerHTML = (f_val == wf_sp_menu_e.OFF)? '' : (val +' '+ wf_sp_slider_s[f_val]);

   if (done) {
	   //console.log('wf_sp_slider_cb DONE WRITE_COOKIE last_filter_param='+ val.toFixed(2) +' which='+ wf_sp_which);
	   writeCookie(wf_sp_which? 'last_wf_filter_param':'last_spec_filter_param', val.toFixed(2));
      freqset_select();
   }

   //console.log('wf_sp_slider_cb EXIT path='+ path);
}

function wf_cmap_cb(path, idx, first)
{
   if (first) return;      // colormap_init() handles setup
   idx = +idx;
   wf.cmap = w3_clamp(idx, 0, kiwi.cmap_s.length - 1, 0);
   //console_log_dbgUs('# wf_cmap_cb idx='+ idx +' first='+ first +' wf.cmap='+ wf.cmap +' audioFFT_active='+ wf.audioFFT_active);
   w3_select_value(path, idx, { all:1 });    // all:1 changes both menus together
   writeCookie('last_cmap', idx);
   mkcolormap();
   
   spectrum_dB_bands();
   update_maxmindb_sliders();
   wf_send('SET cmap='+ wf.cmap);
   w3_call('colormap_select');
   freqset_select();
}

function wf_aper_cb(path, idx, first)
{
   if (first) return;      // colormap_init() handles setup
   idx = +idx;
   wf.aper = w3_clamp(idx, 0, kiwi.aper_s.length - 1, 0);
   //console_log_dbgUs('# wf_aper_cb idx='+ idx +' first='+ first +' wf.aper='+ wf.aper +' audioFFT_active='+ wf.audioFFT_active);
   w3_select_value(path, idx);
   writeCookie('last_aper', idx);

   var auto = (wf.aper == kiwi.aper_e.auto);
   w3_set_innerHTML('id-wf-sliders', auto? wf.floor_ceil_sliders : wf.max_min_sliders);
   w3_color('id-button-wf-autoscale', null, auto? w3_selection_green : '');

   if (auto) {
      wf.save_maxdb = maxdb;
      wf.save_mindb_un = mindb_un;
      //console_log_dbgUs('# save maxdb='+ maxdb +' mindb='+ mindb);

      if (wf.audioFFT_active)
         wf.need_autoscale = 16;    // delay a bit before autoscaling
   } else {
      //console_log_dbgUs('# restore maxdb='+ wf.save_maxdb +' mindb='+ wf.save_mindb_un +' zcorr='+ zoomCorrection());
      setmaxdb(1, wf.save_maxdb);
      setmindb(1, wf.save_mindb_un - zoomCorrection());
   }

   spectrum_dB_bands();
   update_maxmindb_sliders();
   w3_show_hide_inline('id-cmap-maxmin', auto);
   w3_show_hide_inline('id-cmap-maxmin-empty', !auto);
   colormap_update();
   freqset_select();
}

function setwfspeed(done, str)
{
   if (wf.audioFFT_active) {
      freqset_select();
      return;
   }
   
	wf_speed = +str;
	//console.log('# setwfspeed '+ wf_speed +' done='+ done);
	w3_set_value('slider-rate', wf_speed)
   w3_el('slider-rate-field').innerHTML = wf_speeds[wf_speed];
   w3_el('slider-rate-field').style.color = wf_speed? 'white':'orange';
   wf_send('SET wf_speed='+ wf_speed.toFixed(0));
   if (done) freqset_select();
}

function setmaxdb(done, str)
{
	var strdb = parseFloat(str);
	var write_cookies = false;

   if (wf.aper == kiwi.aper_e.auto) {
      maxdb = strdb + wf.auto_ceil.val;
   } else {
      var input_max = w3_el('id-input-maxdb');
      var field_max = w3_el('id-field-maxdb');
      var field_min = w3_el('id-field-mindb');
      if (!input_max || !field_max || !field_min) return;
      write_cookies = true;

      if (strdb <= mindb) {
         maxdb = mindb + 1;
         html(input_max).value = maxdb;
         html(field_max).innerHTML = maxdb.toFixed(0) + ' dB';
         html(field_max).style.color = "red"; 
      } else {
         maxdb = strdb;
         html(field_max).innerHTML = strdb.toFixed(0) + ' dB';
         html(field_max).style.color = "white"; 
         html(field_min).style.color = "white";
      }
   }
	
	setmaxmindb(done, write_cookies);
}

function incr_mindb(done, incr)
{
   if (wf.aper != kiwi.aper_e.man) return;
   var incrdb = (+mindb) + incr;
   var val = Math.max(-190, Math.min(-30, incrdb));
   //console.log('incr_mindb mindb='+ mindb +' incrdb='+ incrdb +' val='+ val);
   setmindb(done, val.toFixed(0));
}

function setmindb(done, str)
{
	var strdb = parseFloat(str);
   //console.log('setmindb strdb='+ strdb +' maxdb='+ maxdb +' mindb='+ mindb +' done='+ done);
	var write_cookies = false;

   if (wf.aper == kiwi.aper_e.auto) {
      mindb = strdb + wf.auto_floor.val;
   } else {
      var input_min = w3_el('id-input-mindb');
      var field_max = w3_el('id-field-maxdb');
      var field_min = w3_el('id-field-mindb');
      if (!input_min || !field_max || !field_min) return;
      write_cookies = true;

      if (maxdb <= strdb) {
         mindb = maxdb - 1;
         html(input_min).value = mindb;
         html(field_min).innerHTML = mindb.toFixed(0) + ' dB';
         html(field_min).style.color = "red";
      } else {
         mindb = strdb;
         //console.log('setmindb SET strdb='+ strdb +' maxdb='+ maxdb +' mindb='+ mindb +' done='+ done);
         html(input_min).value = mindb;
         html(field_min).innerHTML = strdb.toFixed(0) + ' dB';
         html(field_min).style.color = "white";
         html(field_max).style.color = "white";
      }
   }

	mindb_un = mindb + zoomCorrection();
	setmaxmindb(done, write_cookies);
}

function setmaxmindb(done, write_cookies)
{
	full_scale = maxdb - mindb;
	full_scale = full_scale? full_scale : 1;	// can't be zero
	spectrum_dB_bands();
   wf_send("SET maxdb="+maxdb.toFixed(0)+" mindb="+mindb.toFixed(0));
	need_clear_wf_sp_avg = true;

   if (done) {
   	freqset_select();
   	if (write_cookies) {
   	   writeCookie(wf.audioFFT_active? 'last_AF_max_dB' : 'last_max_dB', maxdb.toFixed(0));
   	   writeCookie(wf.audioFFT_active? 'last_AF_min_dB' : 'last_min_dB', mindb_un.toFixed(0));	// need to save the uncorrected (z0) value
	   }
	}
}

function update_maxmindb_sliders()
{
	var auto = (wf.aper == kiwi.aper_e.auto);
	if (!auto) mindb = mindb_un - zoomCorrection();
	
	full_scale = maxdb - mindb;
	full_scale = full_scale? full_scale : 1;	// can't be zero
	spectrum_dB_bands();
   //console_log_dbgUs('# update_maxmindb_sliders: '+ (auto? 'AUTO':'norm') +' min/max='+ mindb +'/'+ maxdb +' ceil='+ wf.auto_ceil.val +' floor='+ wf.auto_floor.val);

   var db1, db2, db1_s, db2_s, field1, field2;
   
   if (auto) {
      db1 = wf.auto_ceil.val;
      db2 = wf.auto_floor.val;
      db1_s = db1.toFixed(0).positiveWithSign();
      db2_s = db2.toFixed(0).positiveWithSign();
      w3_el('id-input-ceildb').value = db1;     // update slider since called from wf_aper_cb()
      w3_el('id-input-floordb').value = db2;
      field1 = w3_el('id-field-ceildb');
      field2 = w3_el('id-field-floordb');
   } else {
      db1 = maxdb;
      db2 = mindb;
      db1_s = db1.toFixed(0);
      db2_s = db2.toFixed(0);
      w3_el('id-input-maxdb').value = db1;
      w3_el('id-input-mindb').value = db2;
      field1 = w3_el('id-field-maxdb');
      field2 = w3_el('id-field-mindb');
   }
   
   field1.innerHTML = db1_s + ' dB';
   field2.innerHTML = db2_s + ' dB';
}

function setceildb(done, str)
{
   var input_ceil = w3_el('id-input-ceildb');
   var field_ceil = w3_el('id-field-ceildb');
   if (!input_ceil || !field_ceil) return;

	var ceildb = parseFloat(str);
   w3_set_innerHTML(field_ceil, ceildb.toFixed(0).positiveWithSign() + ' dB');
   wf.auto_ceil.val = ceildb;
	set_ceilfloordb(done);
}

function setfloordb(done, str)
{
   var input_floor = w3_el('id-input-floordb');
   var field_floor = w3_el('id-field-floordb');
   if (!input_floor || !field_floor) return;

	var floordb = parseFloat(str);
   w3_set_innerHTML(field_floor, floordb.toFixed(0).positiveWithSign() + ' dB');
   wf.auto_floor.val = floordb;
	set_ceilfloordb(done);
}

function set_ceilfloordb(done)
{
   maxdb = wf.auto_maxdb + wf.auto_ceil.val;
   mindb = wf.auto_mindb + wf.auto_floor.val;
	mindb_un = mindb + zoomCorrection();
   //console_log_dbgUs('# set_ceilfloordb min/max='+ mindb +'/'+ maxdb +' min_un='+ mindb_un);
	setmaxmindb(done, false);
	w3_call('colormap_maxmin_cb');

   if (done) {
   	freqset_select();
   	writeCookie('last_ceil_dB', wf.auto_ceil.val.toFixed(0));
   	writeCookie('last_floor_dB', wf.auto_floor.val.toFixed(0));
	}
}

function wf_autoscale_cb()
{
   //console.log('wf_autoscale_cb');
   wf.need_autoscale = 1;
	colormap_update();
   freqset_select();
}

var spectrum_slow_dev = 0;

function toggle_or_set_slow_dev(set, val)
{
	if (isNumber(set))
		spectrum_slow_dev = kiwi_toggle(set, val, spectrum_slow_dev, 'last_slow_dev');
	else
		spectrum_slow_dev ^= 1;
	w3_color('id-button-slow-dev', spectrum_slow_dev? 'lime':'white');
	freqset_select();
	writeCookie('last_slow_dev', spectrum_slow_dev.toString());
	if (spectrum_slow_dev && wf_speed == WF_SPEED_FAST)
	   setwfspeed(1, WF_SPEED_MED);
}

var spectrum_peak = 0;
var spectrum_peak_clear = false;

function toggle_or_set_spec_peak(set, val)
{
	if (isNumber(set))
		spectrum_peak = kiwi_toggle(set, val, spectrum_peak, 'last_spec_peak');
	else
		spectrum_peak ^= 1;
	if (spectrum_peak) spectrum_peak_clear = true;
	w3_color('id-button-spec-peak', spectrum_peak? 'lime':'white');
	freqset_select();
	writeCookie('last_spec_peak', spectrum_peak.toString());
}


////////////////////////////////
// audio
////////////////////////////////

var muted_until_freq_set = true;
var muted = false;
var volume = 50;
var f_volume = 0;
var recording = false;

function setvolume(done, str)
{
   volume = +str;
   volume = Math.max(0, Math.min(200, volume));
   f_volume = muted? 0 : volume/100;
   if (done) {
      w3_set_value('id-input-volume', volume);
      freqset_select();
   }
}

function toggle_or_set_mute(set)
{
	if (isNumber(set))
      muted = set;
   else
	   muted ^= 1;
   //console.log('toggle_or_set_mute set='+ set +' muted='+ muted);
   w3_show_hide('id-mute-no', !muted);
   w3_show_hide('id-mute-yes', muted);
   f_volume = muted? 0 : volume/100;
   freqset_select();
}

var de_emphasis = 0;
var de_emphasis_s = [ 'off', '75us', '50us' ];

function de_emp_cb(path, idx, first)
{
   de_emphasis = +idx;
	snd_send('SET de_emp='+ de_emphasis);
   writeCookie('last_de_emphasis', de_emphasis.toString());
}

var pan = 0;

function setpan(done, str)
{
   var pan = +str;
   //console.log('pan='+ pan.toFixed(1));
   if (pan > -0.1 && pan < +0.1) pan = 0;    // snap-to-zero interval
   w3_set_value('id-pan-value', pan);
   w3_color('id-pan-value', null, (pan < 0)? 'rgba(255,0,0,0.3)' : (pan? 'rgba(0,255,0,0.2)':''));
   w3_set_innerHTML('id-pan-field', pan? ((Math.abs(pan)*100).toFixed(0) +' '+ ((pan < 0)? 'L':'R')) : 'L=R');
   audio_set_pan(pan);
   if (done) {
      writeCookie('last_pan', pan.toString());
      freqset_select();
   }
}

// called from both audio_init() and panels_setup() since there is a race setting audio_panner
function audio_panner_ui_init()
{
   if (audio_panner) {
      w3_show_block('id-pan');
      setpan(1, pan);
   }
}


var hide_topbar = 0;
function toggle_or_set_hide_topbar(set)
{
	if (isNumber(set))
      hide_topbar = set;
   else {
	   hide_topbar = (hide_topbar + 1) & 3;
	   
	   // there is no top container to hide if data container or spectrum in use
      if ((hide_topbar & 1) && (extint.using_data_container || spectrum_display))
	      hide_topbar = (hide_topbar + 1) & 3;
	}
   //console.log('toggle_or_set_hide_topbar set='+ set +' hide_topbar='+ hide_topbar);
   w3_set_props('id-top-container', 'w3-panel-override-hide', hide_topbar & 1);
   w3_set_props('id-band-container', 'w3-panel-override-hide', hide_topbar & 2);
   openwebrx_resize();
}

var hide_panels = 0;
function toggle_or_set_hide_panels(set)
{
	if (isNumber(set))
      hide_panels = set;
   else
	   hide_panels ^= 1;
   //console.log('toggle_or_set_hide_panels set='+ set +' hide_panels='+ hide_panels);
   w3_iterate_children('id-panels-container', function(el) {
      if (w3_contains(el, 'class-panel')) {
         w3_set_props(el, 'w3-panel-override-hide', hide_panels);
      }
   });
}

var test_button;
function toggle_or_set_test(set)
{
	if (isNumber(set))
      test_button = set;
   else
	   test_button ^= 1;
   console.log('toggle_or_set_test set='+ set +' test_button='+ test_button);
   w3_color('id-button-test', test_button? 'lime':'white');
	snd_send('SET test='+ (test_button? 1:0));
   freqset_select();
}

function toggle_or_set_rec(set)
{
   recording = !recording;
   //console.log('toggle_or_set_rec set=' + set + ' recording=' + recording);
   var el1 = w3_el('id-rec1');
   w3_show_hide('id-rec2', recording);
   if (recording) {
      w3_remove_then_add(el1, 'fa-circle', 'fa-circle-o-notch fa-spin');
   } else {
      w3_remove_then_add(el1, 'fa-circle-o-notch fa-spin', 'fa-circle');
      w3_remove_then_add('id-rec1', 'w3-text-white', 'w3-text-pink');
      w3_remove_then_add('id-rec2', 'w3-text-white', 'w3-text-pink');
   }
   if (recording) {
      // Start recording. This is a 'window' property, so audio_recv(), where the
      // recording hooks are, can access it.
      window.recording_meta = {
         buffers: [],         // An array of ArrayBuffers with audio samples to concatenate
         data: null,          // DataView for the current buffer
         offset: 0,           // Current offset within the current ArrayBuffer
         total_size: 0,       // Total size of all recorded data in bytes
         filename: window.location.hostname + '_' + new Date().toISOString().replace(/:/g, '_').replace(/\.[0-9]+Z$/, 'Z') + '_' + w3_el('id-freq-input').value + '_' + cur_mode + '.wav'
      };
      window.recording_meta.buffers.push(new ArrayBuffer(65536));
      window.recording_meta.data = new DataView(window.recording_meta.buffers[0]);
   } else {
      // Stop recording. Build a WAV file.
      var wav_header = new ArrayBuffer(44);
      var wav_data = new DataView(wav_header);
      wav_data.setUint32(0, 0x52494646);                                  // ASCII "RIFF"
      wav_data.setUint32(4, window.recording_meta.total_size + 36, true); // Little-endian size of the remainder of the file, excluding this field
      wav_data.setUint32(8, 0x57415645);                                  // ASCII "WAVE"
      wav_data.setUint32(12, 0x666d7420);                                 // ASCII "fmt "
      wav_data.setUint32(16, 16, true);                                   // Length of this section ("fmt ") in bytes
      wav_data.setUint16(20, 1, true);                                    // PCM coding
      var nch = (cur_mode === 'iq' || cur_mode === 'drm' || cur_mode === 'sas')? 2 : 1;   // Two channels for stereo modes, one channel otherwise
      wav_data.setUint16(22, nch, true);
      var srate = Math.round(audio_input_rate || 12000);
      wav_data.setUint32(24, srate, true);                                // Sample rate
      var bpsa = 16;                                                      // Bits per sample
      var Bpsa = bpsa/8;                                                  // Bytes per sample
      wav_data.setUint32(28, srate*nch*Bpsa, true);                       // Byte rate
      wav_data.setUint16(32, nch*Bpsa, true);                             // Block align
      wav_data.setUint16(34, bpsa, true);                                 // Bits per sample
      wav_data.setUint32(36, 0x64617461);                                 // ASCII "data"
      wav_data.setUint32(40, window.recording_meta.total_size, true);     // Little-endian size of all recorded samples in bytes
      window.recording_meta.buffers.unshift(wav_header);                  // Prepend the WAV header to the recorded audio
      var wav_file = new Blob(window.recording_meta.buffers, { type: 'octet/stream' });

      // Download the WAV file.
      var a = document.createElement('a');
      a.style = 'display: none';
      a.href = window.URL.createObjectURL(wav_file);
      a.download = window.recording_meta.filename;
      document.body.appendChild(a); // https://bugzilla.mozilla.org/show_bug.cgi?id=1218456
      a.click();
      window.URL.revokeObjectURL(a.href);
      document.body.removeChild(a);

      delete window.recording_meta;
   }
}

// squelch
var squelched = 0;
var squelch = 0;
var squelch_tail = 0;
var squelch_tail_s = [ '0', '.2s', '.5s', '1s', '2s' ];
var squelch_tail_v = [ 0, 0.2, 0.5, 1, 2 ];

function squelch_action(sq)
{
   squelched = sq;
   var sq_color = squelched? 'white':'lime';
   w3_color('id-squelch-label', sq_color);
   w3_color('id-mute-no', sq_color);
   
   if (recording) {
      sq_color = squelched? 'w3-text-white':'w3-text-pink';
      w3_remove_then_add('id-rec1', 'fa-spin', squelched? '':'fa-spin');
      w3_remove_then_add('id-rec1', 'w3-text-white w3-text-pink', sq_color);
      w3_remove_then_add('id-rec2', 'w3-text-white w3-text-pink', sq_color);
   }
}

function squelch_setup(flags)
{
   var nbfm = (cur_mode == 'nbfm');
   
   if (flags & toggle_e.FROM_COOKIE) { 
      var sq = readCookie('last_squelch'+ (nbfm? '':'_efm'));
      squelch = sq? +sq : 0;
      //console.log('$squelch_setup nbfm='+ nbfm +' sq='+ sq +' squelch='+ squelch);
      w3_el('id-squelch-value').max = nbfm? 99:40;
      w3_set_value('id-squelch-value', squelch);
   }
   
   set_squelch_cb('', squelch, true, false, true);

	if (nbfm) {
	   squelch_action(squelched);
   } else {
      w3_color('id-mute-no', 'lime');
   }

   //w3_show_hide('id-sq-thresh', !nbfm);
   w3_show_hide('id-squelch_tail', !nbfm);
   w3_show_hide('id-squelch', cur_mode != 'drm');
}

function send_squelch()
{
   var nbfm = (cur_mode == 'nbfm');
   snd_send("SET squelch="+ squelch.toFixed(0) +' param='+ (nbfm? squelch_threshold : squelch_tail_v[squelch_tail]).toFixed(2));
}

function set_squelch_cb(path, str, done, first, no_write_cookie)
{
   var nbfm = (cur_mode == 'nbfm');
   //console.log('$set_squelch_cb path='+ path +' str='+ str +' done='+ done +' first='+ first +' no_write_cookie='+ no_write_cookie +' nbfm='+ nbfm);
   if (first) return;

   squelch = parseFloat(str);
	w3_el('id-squelch-field').innerHTML = squelch? (str + (nbfm? '':' dB')) : 'off';
   w3_color('id-squelch-value', null, squelch? '' : 'rgba(255,0,0,0.3)');

   if (done) {
      send_squelch();
      if (no_write_cookie != true) {
         writeCookie('last_squelch'+ (nbfm? '':'_efm'), str);
      }
      freqset_select();
   }
}

function squelch_tail_cb(path, val, first)
{
   //console.log('squelch_tail_cb path='+ path +' val='+ val +' first='+ first);
   if (first) return;
   squelch_tail = +val;
   send_squelch();
}

// less buffering and compression buttons
var btn_less_buffering = 0;

function toggle_or_set_audio(set, val)
{
	if (isNumber(set))
		btn_less_buffering = kiwi_toggle(set, val, btn_less_buffering, 'last_audio');
	else
		btn_less_buffering ^= 1;

   var el = w3_el('id-button-buffering');
   if (el) {
      el.style.color = btn_less_buffering? 'lime':'white';
      el.style.visibility = 'visible';
      freqset_select();
   }
	writeCookie('last_audio', btn_less_buffering.toString());
	
	// if toggling (i.e. not the first time during setup) reinitialize audio with specified buffering
	if (!isNumber(set)) {
	   // haven't got audio_init() calls to work yet (other than initial)
	   //audio_init(null, btn_less_buffering, btn_compression);
      window.location.reload(true);
   }
}

var btn_compression = 0;

function toggle_or_set_compression(set, val)
{
   // Prevent compression setting changes while recording.
   if (recording) {
      return;
   }

	if (isNumber(set))
		btn_compression = kiwi_toggle(set, val, btn_compression, 'last_compression');
	else
		btn_compression ^= 1;

   var el = w3_el('id-button-compression');
   if (el) {
      el.style.color = btn_compression? 'lime':'white';
      el.style.visibility = 'visible';
      freqset_select();
   }
	writeCookie('last_compression', btn_compression.toString());
	//console.log('SET compression='+ btn_compression.toFixed(0));
	snd_send('SET compression='+ btn_compression.toFixed(0));
}


////////////////////////////////
// AGC
////////////////////////////////

function set_agc()
{
	snd_send('SET agc='+ agc +' hang='+ hang +' thresh='+ thresh +' slope='+ slope +' decay='+ decay +' manGain='+ manGain);
}

var agc = 0;

function toggle_agc(evt)
{
	if (any_alternate_click_event(evt)) {
		setup_agc(toggle_e.SET);
	} else {
		toggle_or_set_agc();
	}

	return cancelEvent(evt);
}

function agc_over(evt)
{
	w3_el('id-button-agc').title = any_alternate_click_event(evt)? 'restore AGC params':'';
}

var default_agc = 1;
var default_hang = 0;
var default_manGain = 50;
var default_thresh = -130;
var default_slope = 6;
var default_decay = 1000;

function setup_agc(toggle_flags)
{
	agc = kiwi_toggle(toggle_flags, default_agc, agc, 'last_agc'); toggle_or_set_agc(agc);
	hang = kiwi_toggle(toggle_flags, default_hang, hang, 'last_hang'); toggle_or_set_hang(hang);
	manGain = kiwi_toggle(toggle_flags, default_manGain, manGain, 'last_manGain'); setManGain(true, manGain);
	thresh = kiwi_toggle(toggle_flags, default_thresh, thresh, 'last_thresh'); setThresh(true, thresh);
	slope = kiwi_toggle(toggle_flags, default_slope, slope, 'last_slope'); setSlope(true, slope);
	decay = kiwi_toggle(toggle_flags, default_decay, decay, 'last_decay'); setDecay(true, decay);
}

function toggle_or_set_agc(set)
{
	if (set != undefined)
		agc = set;
	else
		agc ^= 1;
	
	html('id-button-agc').style.color = agc? 'lime':'white';
	if (agc) {
		html('id-label-man-gain').style.color = 'white';
		html('id-button-hang').style.borderColor = html('label-threshold').style.color = html('label-slope').style.color = html('label-decay').style.color = 'orange';
	} else {
		html('id-label-man-gain').style.color = 'orange';
		html('id-button-hang').style.borderColor = html('label-threshold').style.color = html('label-slope').style.color = html('label-decay').style.color = 'white';
	}
	set_agc();
	writeCookie('last_agc', agc.toString());
   freqset_select();
}

var hang = 0;

function toggle_or_set_hang(set)
{
	if (set != undefined)
		hang = set;
	else
		hang ^= 1;

	html('id-button-hang').style.color = hang? 'lime':'white';
	set_agc();
	writeCookie('last_hang', hang.toString());
   freqset_select();
}

var manGain = 0;

function setManGain(done, str)
{
   manGain = parseFloat(str);
   html('input-man-gain').value = manGain;
   html('field-man-gain').innerHTML = str;
	set_agc();
	writeCookie('last_manGain', manGain.toString());
   if (done) freqset_select();
}

var thresh = 0;

function setThresh(done, str)
{
   thresh = parseFloat(str);
   html('input-threshold').value = thresh;
   html('field-threshold').innerHTML = str;
	set_agc();
	writeCookie('last_thresh', thresh.toString());
   if (done) freqset_select();
}

var slope = 0;

function setSlope(done, str)
{
   slope = parseFloat(str);
   html('input-slope').value = slope;
   html('field-slope').innerHTML = str;
	set_agc();
	writeCookie('last_slope', slope.toString());
   if (done) freqset_select();
}

var decay = 0;

function setDecay(done, str)
{
   decay = parseFloat(str);
   html('input-decay').value = decay;
   html('field-decay').innerHTML = str;
	set_agc();
	writeCookie('last_decay', decay.toString());
   if (done) freqset_select();
}


////////////////////////////////
// users
////////////////////////////////

function users_setup()
{
   var s = '';
	for (var i=0; i < rx_chans; i++) {
	   s +=
	      w3_div('',
            w3_div('w3-show-inline-block w3-left w3-margin-R-5 ' +
               ((i == rx_chan)? 'w3-text-css-lime' : optbar_prefix_color), 'RX'+ i),
            w3_div('id-optbar-user-'+ i +' w3-show-inline-block')
         );
	}
	w3_set_innerHTML('id-optbar-users', w3_div('w3-nowrap', s));
}


////////////////////////////////
// control panel
////////////////////////////////

// Safari on iOS only plays webaudio after it has been started by clicking a button.
// Same now for Chrome and Safari 12 on OS X.
function play_button()
{
	try {
	   if (kiwi_is_iOS()) {
         var actx = audio_context;
         var bufsrc = actx.createBufferSource();
         bufsrc.connect(actx.destination);
         try { bufsrc.start(0); } catch(ex) { bufsrc.noteOn(0); }
	   } else {
	      try {
	         if (audio_context) audio_context.resume();
	      } catch(ex) {
	         console.log('#### audio_context.resume() FAILED');
	      }
      }
   } catch(ex) { add_problem("audio start"); }

   // CSS is setup so opacity fades
	w3_el('id-play-button-container').style.opacity = 0;
	setTimeout(function() { w3_hide('id-play-button-container'); }, 1100);
   freqset_select();
}

// icon callbacks
function freq_up_down_cb(path, up)
{
   freq_memory_up_down(+up);
	w3_field_select('id-freq-input', { focus_only:1 });
}

var spectrum_display = false;

function toggle_or_set_spec(set, val)
{
	if (isNumber(set) && (set & toggle_e.SET)) {
		spectrum_display = val;
	} else {
		spectrum_display ^= 1;
	}

	// close the extension first if it's using the data container and the spectrum button is pressed
	if (extint.using_data_container && spectrum_display) {
		extint_panel_hide();
	}

	html('id-button-spectrum').style.color = spectrum_display? 'lime':'white';
	w3_show_hide('id-spectrum-container', spectrum_display);
	w3_show_hide('id-top-container', !spectrum_display);
   freqset_select();
}

var band_menu = [];

function setup_band_menu()
{
	var i, op=0, service = null;
	var s="";
	band_menu[op++] = null;		// menu title
	for (i=0; i < bands.length; i++) {
		var b = bands[i];
		if (b.region != "*" && b.region.charAt(0) != '>' && b.region != 'm') continue;

		// FIXME: Add prefix to IBP names to differentiate from ham band names.
		// A software release can't modify bands[] definition in config.js so do this here.
		// At some point config.js will be eliminated when admin page gets equivalent UI.
		if ((b.s == svc.L || b.s == svc.X) && b.region == 'm') {
		   if (!b.name.includes('IBP'))
		      b.name = 'IBP '+ b.name;
		}

		if (service != b.s.name) {
			service = b.s.name; s += '<option value="'+op+'" disabled>'+b.s.name.toUpperCase()+'</option>';
			band_menu[op++] = null;		// section title
		}
		s += '<option value="'+op+'">'+b.name+'</option>';
		//console.log("BAND-MENU"+op+" i="+i+' '+(b.min/1000)+'/'+(b.max/1000));
		band_menu[op++] = b;
	}
	return s;
}

function mode_over(evt, el)
{
   var mode = el.innerHTML.toLowerCase();
   //console.log('mode_over mode='+ mode);
   var s;
   
   switch (mode) {
   
      case 'sam': s = 'synchronous AM'; break;
      case 'sal': s = 'synchronous AM LSB'; break;
      case 'sau': s = 'synchronous AM USB'; break;
      case 'sas': s = 'synchronous AM stereo'; break;
      
      default: s = ''; break;
   }

   el.title = evt.shiftKey? 'restore passband' : s;
}

function any_alternate_click_event(evt)
{
	return (evt && (evt.shiftKey || evt.ctrlKey || evt.altKey || evt.button == mouse.middle || evt.button == mouse.right));
}

function any_alternate_click_event_except_shift(evt)
{
	return (evt && (evt.ctrlKey || evt.altKey || evt.button == mouse.middle || evt.button == mouse.right));
}

function restore_passband(mode)
{
   passbands[mode].last_lo = passbands[mode].lo;
   passbands[mode].last_hi = passbands[mode].hi;
   //writeCookie('last_locut', passbands[mode].last_lo.toString());
   //writeCookie('last_hicut', passbands[mode].last_hi.toString());
   //console.log('DEMOD PB reset');
}

var mode_buttons = [
   { s:[ 'AM', 'AMN' ],                 dis:0 },    // fixme: add AMW dynamically if 20 kHz mode? would have to deal with last_mode=ANW cookie
   { s:[ 'SAM', 'SAL', 'SAU', 'SAS' ],  dis:0 },
   { s:[ 'DRM' ],                       dis:0 },
   { s:[ 'LSB', 'LSN' ],                dis:0 },
   { s:[ 'USB', 'USN' ],                dis:0 },
   { s:[ 'CW', 'CWN' ],                 dis:0 },
   { s:[ 'NBFM' ],                      dis:0 },
   { s:[ 'IQ' ],                        dis:0 },
];

function mode_button(evt, el, dir)
{
   var mode = el.innerHTML.toLowerCase();
   if (isUndefined(dir)) dir = 1;

	// Prevent going between mono and stereo modes while recording
	// FIXME: do something better like disable ineligible mode buttons and show reason in mouseover tooltip 
   var c_iq_drm_sas = (cur_mode == 'iq' || cur_mode == 'drm' || cur_mode == 'sas')? 1:0;
   var m_iq_drm_sas = (mode == 'iq' || mode == 'drm' || mode == 'sas')? 1:0;
	if (recording && (c_iq_drm_sas ^ m_iq_drm_sas)) {
		return;
	}

	// reset passband to default parameters
	if (any_alternate_click_event(evt)) {
	   if (evt.shiftKey || evt.button == mouse.middle) {
         restore_passband(mode);
         ext_set_mode(mode, null, { open_ext:true });
         return;
      }
      
      dir = -1;
	}

	// cycle button to next/prev value
	//console.log(el);
   var col = parseInt(el.id);

   if (isUndefined(owrx.last_mode_col)) {
      owrx.last_mode_col = parseInt(owrx.last_mode_el.id);
      //console.log('#### mode_button: last_mode_col UNDEF set to '+ owrx.last_mode_col);
   }
   
   if (owrx.last_mode_col != col) {
      //console.log('#### mode_button: col '+ owrx.last_mode_col +'>'+ col +' '+ mode);
      owrx.last_mode_col = col;
   } else {
      var sa = mode_buttons[col].s;
      mode = mode.toUpperCase();
      var i = sa.indexOf(mode) + dir;
      if (i <= -1) i = sa.length - 1;
      if (i >= sa.length) i = 0;
      mode = sa[i];
      el.innerHTML = mode;
      mode = mode.toLowerCase();
      //console.log('#### mode_button: col '+ col +' '+ mode);
   }

   ext_set_mode(mode, null, { open_ext:true });
}

var step_9_10;

function button_9_10(set)
{
	if (set != undefined)
		step_9_10 = set;
	else
		step_9_10 ^= 1;
	//console.log('button_9_10 '+ step_9_10);
	writeCookie('last_9_10', step_9_10);
	freq_step_update_ui(true);
	var el = w3_el('id-button-9-10');
	//el.style.color = step_9_10? 'red':'blue';
	//el.style.backgroundColor = step_9_10? kiwi_rgb(255, 255*0.8, 255*0.8) : kiwi_rgb(255*0.8, 255*0.8, 255);
	el.innerHTML = step_9_10? '9':'10';
   freqset_select();
}

function pop_bottommost_panel(from)
{
	min_order=parseInt(from[0].getAttribute('data-panel-order'));
	min_index=0;
	for (var i=0;i<from.length;i++)	
	{
		actual_order=parseInt(from[i].getAttribute('data-panel-order'));
		if (actual_order<min_order) 
		{
			min_index=i;
			min_order=actual_order;
		}
	}
	to_return=from[min_index];
	from.splice(min_index,1);
	return to_return;
}

function place_panels()
{
	var left_col = [];
	var right_col = [];
	var plist = html("id-panels-container").children;
	
	for (var i=0; i < plist.length; i++) {
		var c = plist[i];
		if (c.classList.contains('class-panel')) {
			var position = c.getAttribute('data-panel-pos');
			//console.log('place_panels: '+ c.id +' '+ position);
			if (!position) continue;
			var newSize = c.getAttribute('data-panel-size').split(",");
			if (position == "left") { left_col.push(c); }
			else if (position == "right") { right_col.push(c); }
			
			c.idName = c.id.replace('id-', '');
			c.style.width = newSize[0]+"px";
			c.style.height = newSize[1]+"px";
			c.style.margin = px(panel_margin);
			c.uiWidth = parseInt(newSize[0]);
			c.uiHeight = parseInt(newSize[1]);
			c.defaultWidth = parseInt(newSize[0]);
			c.defaultHeight = parseInt(newSize[1]);
			
			// Since W3.CSS includes the normalized use of "box-sizing: border-box"
			// style.width no longer represents the active content area.
			// So compute it ourselves for those who need it later on.
			var border_pad = html_LR_border_pad(c);
			c.activeWidth = c.uiWidth - border_pad;
			//console.log('place_panels: id='+ c.id +' uiW='+ c.uiWidth +' bp='+ border_pad + 'active='+ c.activeWidth);
			
			if (position == 'center') {
				//console.log('place_panels CENTER '+ c.id +' '+ px(window.innerHeight) +' '+ px(c.uiHeight));
				c.style.left = px(window.innerWidth/2 - c.activeWidth/2);
				c.style.bottom = px(window.innerHeight/2 - c.uiHeight/2);
				c.style.visibility = "hidden";
			}

			if (position == 'bottom-left') {
				//console.log("L/B "+ px(window.innerHeight).toString()+"px "+(c.uiHeight));
				c.style.left = 0;
				c.style.bottom = 0;
				c.style.visibility = "hidden";
			}
		}
	}
	
	y=0;
	while (left_col.length > 0) {
		p = pop_bottommost_panel(left_col);
		p.style.left = 0;
		p.style.bottom = px(y);
		p.style.visibility = "visible";
		y += p.uiHeight+3*panel_margin;
		w3_call('panel_setup_'+ p.idName, p);
	}
	
	y=0;
	while (right_col.length > 0) {
		p = pop_bottommost_panel(right_col);
		p.style.right = px(kiwi_scrollbar_width());		// room for waterfall scrollbar
		p.style.bottom = px(y);
		p.style.visibility = "visible";
		y += p.uiHeight+3*panel_margin;
		w3_call('panel_setup_'+ p.idName, p);
	}
}


// panel-specific setup

var divControl;

// fixed height instead of content dependent so height is constant between different optbar types
var OPTBAR_CONTENT_HEIGHT = 150;

// called indirectly by a w3_call()
function panel_setup_control(el)
{
	divControl = el;
	el.style.marginBottom = '0';

   var el2 = w3_el('id-control-inner');
   //el2.style.position = 'relative';
   //el2.style.paddingTop = px(8);
	el2.innerHTML =

	   // Workaround for Firefox bug:
	   //
	   // [Problem went away with larger panel height. Something still doesn't make sense.
	   // Relative div measuring from wrong parent in FF possibly?]
	   //
	   // Initially the upper (orange) freq history button is fine. But when you reload the page in
	   // FF the top of the icon gets chopped off. The entire innerHTML of id-control-inner seems to
	   // be shifted up a few pixels. Even the S-meter at the bottom is shifted up. No other browsers
	   // do this. The only way to fix it is to make the first table row position:relative and then
	   // shift it down via top:2px. This looks okay in the other browsers and in FF before any reloads.
	   //w3_table('id-control-freq1|position:relative; top:2px') +
	   //w3_table('id-control-freq1|position:relative;') +

      w3_div('id-control-top',
         w3_div('id-control-freq1'),
         w3_div('id-control-freq2'),
         w3_div('id-control-mode w3-margin-T-6'),
         w3_div('id-control-zoom w3-margin-T-6'),
         w3_div('id-control-squelch'),
         w3_div('id-optbar w3-margin-T-4')
      ) +
	   w3_div('id-optbar-content w3-margin-T-6 w3-scroll-y|height:'+ px(OPTBAR_CONTENT_HEIGHT),
	      w3_div('id-optbar-wf w3-hide'),
	      w3_div('id-optbar-audio w3-hide'),
	      w3_div('id-optbar-agc w3-hide'),
	      w3_div('id-optbar-users w3-hide w3-scroll-x'),
	      w3_div('id-optbar-status w3-hide')
	   ) +

	   w3_div('id-control-smeter');

	// make first line of controls full width less vis button
	w3_el('id-control-freq1').style.width = px(el.activeWidth - visIcon - 6);
	
	w3_show_hide('id-mute-no', !muted);
	w3_show_hide('id-mute-yes', muted);
}

function panel_set_vis_button(id)
{
	var el = w3_el(id);
	var vis = w3_el(id +'-vis');
	var visOffset = el.activeWidth - visIcon;
	//console.log('left='+ visOffset +' id='+ (id +'-vis') +' '+ el.activeWidth +' '+ visIcon +' '+ visBorder);
	vis.style.left = px(visOffset + visBorder);
}

function panel_set_width_height(id, width, height)
{
	var panel = w3_el(id);

   //console.log('panel_set_width_height '+ id +' w='+ width +' '+ panel.defaultWidth +' h='+ height +' '+ panel.defaultHeight);
	if (width == undefined)
		width = panel.defaultWidth;
	panel.style.width = px(width);
	panel.uiWidth = width;

	if (height == undefined)
		height = panel.defaultHeight;
	panel.style.height = px(height);
	panel.uiHeight = height;

	var border_pad = html_LR_border_pad(panel);
	panel.activeWidth = panel.uiWidth - border_pad;
	panel_set_vis_button(id);
}

////////////////////////////////
// misc
////////////////////////////////

function event_dump(evt, id, oneline)
{
   if (oneline) {
      var trel = (isDefined(evt.relatedTarget) && evt.relatedTarget)? (' Trel='+ evt.relatedTarget.id) : '';
      console.log('event_dump '+ id +' '+ evt.type +' T='+ evt.target.id +' Tcur='+ evt.currentTarget.id + trel);
   } else {
      console.log('================================');
      console.log('EVENT_DUMP: '+ id +' type='+ evt.type);
      console.log((evt.shiftKey? 'SFT ':'') + (evt.ctrlKey? 'CTL ':'') + (evt.altKey? 'ALT ':'') + (evt.metaKey? 'META ':'') +'key='+evt.key);
      console.log('this.id='+ this.id +' tgt.name='+ evt.target.nodeName +' tgt.id='+ evt.target.id +' ctgt.id='+ evt.currentTarget.id);
      console.log('button='+evt.button+' buttons='+evt.buttons+' detail='+evt.detail+' which='+evt.which);
      console.log('offX='+evt.offsetX+' pageX='+evt.pageX+' clientX='+evt.clientX+' layerX='+evt.layerX );
      console.log('offY='+evt.offsetY+' pageY='+evt.pageY+' clientY='+evt.clientY+' layerY='+evt.layerY );
      console.log('evt, evt.target, evt.currentTarget, evt.relatedTarget:');
      console.log(evt);
      console.log(evt.target);
      console.log(evt.currentTarget);
      console.log(evt.relatedTarget);
      console.log('----');
   }
}

function arrayBufferToString(buf) {
	//http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
	return String.fromCharCode.apply(null, new Uint8Array(buf));
}

function arrayBufferToStringLen(buf, num)
{
	var u8buf=new Uint8Array(buf);
	var output=String();
	num=Math.min(num,u8buf.length);
	for (var i=0;i<num;i++) output+=String.fromCharCode(u8buf[i]);
	return output;
}

// NB: use kiwi_log() instead of console.log() in here
function add_problem(what, append, sticky, el_id)
{
   var id = el_id? el_id : 'id-status-problems'
	//kiwi_log('add_problem '+ what +' sticky='+ sticky +' id='+ id);
	el = w3_el(id);
	if (!el) return;
	if (isDefined(el.children)) {
		for (var i=0; i < el.children.length; i++) {
		   if (el.children[i].innerHTML == what) {
		      return;
		   }
		}
		if (append == false) {
		   while (el.firstChild) {
		      el.removeChild(el.firstChild);
		   }
		}
	}
	var new_span = w3_appendElement(el, "span", what);
	if (sticky != true) {
		window.setTimeout(function(ps, ns) { try { ps.removeChild(ns); } catch(ex) {} }, 1000, el, new_span);
	}
}

function set_gen(freq, attn)
{
   //console.log('set_gen freq='+ freq +' attn='+ attn);
	snd_send("SET genattn="+ attn.toFixed(0));
	snd_send("SET gen="+ freq +" mix=-1");
}


////////////////////////////////
// websocket
////////////////////////////////

var bin_server = 0;
var zoom_server = 0;

function owrx_msg_cb(param, ws)
{
	switch (param[0]) {
		case "wf_setup":
			   waterfall_init();
			break;					
		case "extint_list_json":
			extint_list_json(param[1]);
			
			// now that we have the list of extensions see if there is an override
			if (override_ext)
				extint_open(override_ext, 3000);
			break;
		case "bandwidth":
			bandwidth = parseInt(param[1]);
			break;		
		case "center_freq":
			center_freq = parseInt(param[1]);
			break;
		case "wf_fft_size":
			wf_fft_size = parseInt(param[1]);
			break;
		case "wf_fps_max":
			wf_fps_max = parseInt(param[1]);
		   //console.log('# wf_fps_max='+ wf_fps_max);
			break;
		case "wf_fps":
			wf_fps = parseInt(param[1]);
		   //console.log('# wf_fps='+ wf_fps);
			break;
		case "start":
			bin_server = parseInt(param[1]);
			break;
		case "zoom":
			zoom_server = parseInt(param[1]);
			break;
		case "zoom_max":
			zoom_levels_max = parseInt(param[1]);
			zoom_nom = Math.min(ZOOM_NOMINAL, zoom_levels_max);
			break;
		case "audio_init":
         toggle_or_set_audio(toggle_e.FROM_COOKIE | toggle_e.SET, 1);
			audio_init(parseInt(param[1]), btn_less_buffering, kiwi_toggle(toggle_e.FROM_COOKIE | toggle_e.SET, 1, 1, 'last_compression'));
			break;
		case "audio_rate":
			audio_rate(parseFloat(param[1]));
			break;
		case "kiwi_up":
			kiwi_up(parseInt(param[1]));
			break;
		case "gps":
			toggle_or_set_spec(toggle_e.SET, 1);
			break;
		case "fft_mode":
			kiwi_fft_mode();
			break;
		case "maxdb":
		   wf.auto_maxdb = +param[1];
         setmaxdb(1, wf.auto_maxdb);
			break;
		case "mindb":
		   wf.auto_mindb = +param[1];
         setmindb(1, wf.auto_mindb);
	      w3_call('colormap_maxmin_cb');
         update_maxmindb_sliders();
			break;
		default:
		   return false;
	}

	return true;
}

function owrx_ws_open_snd(cb, cbp)
{
	ws_snd = open_websocket('SND', cb, cbp, owrx_msg_cb, audio_recv, on_ws_error);
	return ws_snd;
}

function owrx_ws_open_wf(cb, cbp)
{
	ws_wf = open_websocket('W/F', cb, cbp, owrx_msg_cb, waterfall_add_queue, on_ws_error);
	return ws_wf;
}

function on_ws_error()
{
	divlog("WebSocket error.", 1);
}

function snd_send(s)
{
	try {
		//console.log('WS SND <'+ s +'>');
		ws_snd.send(s);
		return 0;
	} catch(ex) {
		console.log("CATCH snd_send('"+s+"') ex="+ex);
		kiwi_trace();
		return -1;
	}
}

function wf_send(s)
{
	try {
		//console.log('WS W/F <'+ s +'>');
		ws_wf.send(s);
		return 0;
	} catch(ex) {
		console.log("CATCH wf_send('"+s+"') ex="+ex);
		kiwi_trace();
		return -1;
	}
}

var need_geo = true;
var need_status = true;

function send_keepalive()
{
	for (var i=0; i<1; i++) {
		if (!ws_snd.up || snd_send("SET keepalive") < 0)
			break;
	
		// these are done here because we know the audio connection is up and can receive messages
		if (need_geo && kiwi_geo() != "") {
			if (msg_send("SET geoloc="+kiwi_geo()) < 0)
				break;
			if (msg_send("SET geojson="+kiwi_geojson()) < 0)
				break;
			need_geo = false;
		}
		
		if (need_ident) {
			//console.log('need_ident: SET ident_user='+ ident_user);
			if (!ident_user) ident_user = '';
			if (snd_send("SET ident_user="+ encodeURIComponent(ident_user)) < 0)
				break;
			need_ident = false;
		}
	
		if (need_status) {
			if (snd_send("SET need_status=1") < 0)
				break;
			need_status = false;
		}
	}

	if (!ws_wf.up || wf_send("SET keepalive") < 0)
		return;
}





/* web/openwebrx/audio.min.js */
/*

OpenWebRX (c) Copyright 2013-2014 Andras Retzler <randras@sdr.hu>

This file is part of OpenWebRX.

    OpenWebRX is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenWebRX is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with OpenWebRX. If not, see <http://www.gnu.org/licenses/>.

*/

// Copyright (c) 2015 - 2016 John Seamons, ZL/KF6VO

// Note: we don't support older browsers using the Mozilla audio API since it is now depreciated
// see https://wiki.mozilla.org/Audio_Data_API

// constants
var audio_periodic_interval_ms = 1000; // the interval in which audio_periodic() is called

var audio_flags = {
   SND_FLAG_LPF:           0x01,
   SND_FLAG_ADC_OVFL:      0x02,
   SND_FLAG_NEW_FREQ:      0x04,
   SND_FLAG_MODE_IQ:       0x08,
   SND_FLAG_COMPRESSED:    0x10,
   SND_FLAG_RESTART:       0x20,
   SND_FLAG_SQUELCH_UI:    0x40,
   SND_FLAG_LITTLE_ENDIAN: 0x80
};

// init only once
var audio_ext_sequence = 0;
var audio_meas_dly_ena = 0;
var audio_initial_connect = false;
var audio_watchdog_restart = false;

// stats
var audio_stat_input_size = 0;
var audio_stat_total_input_size = 0;
var audio_reconnect = 0;
var audio_silence_count = 0;
var audio_restart_count = 0;
var audio_stat_output_bufs;
var audio_underrun_errors = 0;
var audio_overrun_errors = 0;
var audio_last_underruns = 0;
var audio_last_reconnect = 0;
var audio_last_restart_count = 0;
var audio_stat_last_time;

// set in audio_init()
var audio_running;
var audio_started;
var audio_last_output_offset;
var audio_mode_iq;
var audio_compression;
var audio_stat_input_epoch;
var audio_prepared_buffers;
var audio_prepared_buffers2;
var audio_prepared_seq;
var audio_prepared_flags;
var audio_prepared_smeter;
var audio_buffering;
var audio_convolver_running;
var audio_meas_dly;
var audio_meas_dly_start;
var resample_new_default = false;
var resample_new;
var resample_old;
var resample_init1;
var resample_init2;
var resample_input_buffer;
var resample_input_available;
var resample_input_processed;
var resample_last_taps_delay;
var resample_output_buffer;
var resample_output_buffer2;
var resample_output_size;
var resample_taps;
var resample_taps_length;
var resample_last;
var resample_last2;
var audio_adpcm = { index:0, previousValue:0 };
var audio_ext_adc_ovfl;
var audio_need_stats_reset;
var audio_change_LPF_latch;
var audio_change_freq_latch;
var audio_change_sq_UI_latch;
var audio_last_sq;
var audio_panner = null;
var audio_gain;

// LPF tap info for convolver when compression used
var comp_lpf_freq;
var comp_lpf_taps;
var comp_lpf_taps_length;

var audio_buffer_size;
var audio_buffer_min_length_sec; // actual number of samples are calculated from sample rate
var audio_buffer_max_length_sec; // actual number of samples are calculated from sample rate
var audio_data;
var audio_last_output_buffer, audio_last_output_buffer2;
var audio_silence_buffer;
var audio_stats_interval;
var audio_context;
var audio_output_rate;
var audio_last_is_local, audio_last_compression;

// set in audio_rate()
var audio_input_rate;
var audio_interpolation;
var audio_decimation;
var audio_resample_ratio;
var audio_transition_bw;
var audio_min_nbuf;
var audio_max_nbuf;

// set in audio_connect()
var audio_stat_output_epoch;
var audio_channels;
var audio_source;
var audio_watchdog;
var audio_firefox_watchdog = 0;
var audio_change_LPF_delayed;

// set in audio_disconnect()
var audio_disconnected;

// set in audio_prepare()
var audio_convolver;


/*
   init:
      rate()
      started = buffering = false
   rate:
      min_nbuf = , max_nbuf =
   start:
      started = true
      connect()
      setup periodic()
   disconnect:
      ...
   connect:
      if (reconnect) disconnect(), buffering = true
      setup onprocess()
   recv:
      if (->IQ || change comp) connect(reconnect=1)
      prepare()
      if (!started && prepared.len > min_nbuf) start()
   prepare:
      if () splice()
      resample()
      if () dopush: prepared.push()
      if (buffering && prepared.len > min_nbuf) buffering = false;
   onprocess:
      if (started && prepared.len == 0)
         underruns++
         buffering = true
      if (!started || buffering)
         play(silence)
      else
         play(prepared.shift())
   periodic:
      if (prepared.len > max_nbuf) trim(prepared)
      if (overran) overrun()
      if (underruns) underrun()

                  is called by:
audio_init()      when sound thread starts, rx_sound.cpp:c2s_sound_setup()
audio_rate()      right after above, rx_sound.cpp:c2s_sound_setup()
audio_recv()      web socket data received
audio_start()     audio_recv() when enough initially buffered
audio_connect()   audio_start() initially
                  audio_watchdog_process() to recover
                  audio_recv() IQ/comp change with new buf queues, resamp, comp etc.
audio_prepare()   audio_recv()

*/

function audio_init(is_local, less_buffering, compression)
{
   audio_running = false;
   
   console.log('--------------------------');
   //console.log('AUDIO audio_init CALLED is_local='+ is_local +' less_buffering='+ less_buffering +' compression='+ compression);

   less_buffering = false;    // DEPRECATED
   
   //console.log('AUDIO audio_init LAST audio_last_is_local='+ audio_last_is_local +' audio_last_compression='+ audio_last_compression);
   if (is_local == null) is_local = audio_last_is_local;
   audio_last_is_local = is_local;
   if (compression == null) compression = audio_last_compression;
   audio_last_compression = compression;

   console.log('AUDIO audio_init FINAL is_local='+ is_local +' less_buffering='+ less_buffering +' compression='+ compression);

   if (audio_source != undefined) {
      //console.log('AUDIO audio_init audio_disconnect');
      audio_disconnect();
   }

   // reset globals
   audio_started = false;
   audio_last_output_offset = 0;
   audio_mode_iq = false;
   audio_compression = compression? true:false;
   audio_stat_input_epoch = -1;
   audio_prepared_buffers = Array();
   audio_prepared_buffers2 = Array();
   audio_prepared_seq = Array();
   audio_prepared_flags = Array();
   audio_prepared_smeter = Array();
   audio_buffering = false;
   audio_convolver_running = false;
   audio_meas_dly = 0;
   audio_meas_dly_start = 0;
   resample_new = kiwi_isMobile()? false : resample_new_default;
   resample_old = !resample_new;
   resample_init1 = false;
   resample_init2 = false;
   resample_input_buffer = [];
   resample_input_available = 0;
   resample_input_processed = 0;
   resample_last_taps_delay = 0;
   resample_output_buffer = [];
   resample_output_buffer2 = [];
   resample_taps = [];
   resample_last = 0;
   resample_last2 = 0;
   comp_lpf_freq = 0;
   comp_lpf_taps = [];
   comp_lpf_taps_length = 255;
   audio_adpcm.index = 0;
   audio_adpcm.previousValue = 0;
   audio_ext_adc_ovfl = false;
   audio_need_stats_reset = true;
   audio_change_LPF_latch = false;
   audio_change_freq_latch = false;
   audio_change_sq_UI_latch = false;
   audio_last_sq = undefined;    // so set true/false first time
   
   var buffering_scheme = 0;
   var scheme_s;
	var a = kiwi_url_param('abuf', null, null);
   var abuf = 0;
   
   if (a != null) {
      var a2 = a.split(',');
      abuf = parseFloat(a2[0]);
      if (!isNaN(abuf) && abuf >= 0.25 && abuf <= 5.0) {
         console.log('AUDIO override abuf='+ a);
         var max = abuf * 3;
         if (a2.length >= 2) {
            var m = parseFloat(a2[1]);
            if (!isNaN(m) && m >= 0.25 && m <= 5.0 && m > abuf) {
               max = m;
            }
         } else {
            max = abuf * 3;
         }
         audio_buffer_min_length_sec = abuf;
         audio_buffer_max_length_sec = max;
         audio_buffer_size = 8192;
         buffering_scheme = 9;
         scheme_s = 'abuf=';
      } else {
         abuf = 0;
      }
   }
   
   if (abuf == 0) {
      if (less_buffering) {
         if (is_local)
            buffering_scheme = 2;
         else
            buffering_scheme = 1;
      } else {
         buffering_scheme = 0;
      }

      // 2048 =  46 ms/buf 21.5 /sec @ 44.1 kHz
      // 4096 =  93 ms/buf 10.8 /sec @ 44.1 kHz
      // 8192 = 186 ms/buf  5.4 /sec @ 44.1 kHz
   
      if (buffering_scheme == 2) {
         audio_buffer_size = 8192;
         audio_buffer_min_length_sec = 0.37;    // min_nbuf = 2 @ 44.1 kHz
         audio_buffer_max_length_sec = 2.00;
         scheme_s = 'less buf, local';
      } else
      
      if (buffering_scheme == 1) {
         audio_buffer_size = 8192;
         audio_buffer_min_length_sec = 0.74;    // min_nbuf = 4 @ 44.1 kHz
         audio_buffer_max_length_sec = 3.00;
         scheme_s = 'less buf, remote';
      } else
      
      if (buffering_scheme == 0) {
         audio_buffer_size = 8192;
         audio_buffer_min_length_sec = 0.85;    // min_nbuf = 5 @ 44.1 kHz
         audio_buffer_max_length_sec = 3.40;
         scheme_s = 'more buf';
      }
   }
   
	audio_data = new Int16Array(audio_buffer_size);
	audio_last_output_buffer = new Float32Array(audio_buffer_size)
	audio_last_output_buffer2 = new Float32Array(audio_buffer_size)
	audio_silence_buffer = new Float32Array(audio_buffer_size);
	console.log('AUDIO buffer_size='+ audio_buffer_size +' buffering_scheme: '+ scheme_s);
	
	kiwi_clearInterval(audio_stats_interval);
	audio_stats_interval = setInterval(audio_stats, 1000);

	//https://github.com/0xfe/experiments/blob/master/www/tone/js/sinewave.js
	try {
		window.AudioContext = window.AudioContext || window.webkitAudioContext;
		audio_context = new AudioContext();
		audio_context.sampleRate = 44100;		// attempt to force a lower rate
		audio_output_rate = audio_context.sampleRate;		// see what rate we're actually getting
		
		try {
		   audio_panner = audio_context.createStereoPanner();
		   audio_panner_ui_init();
		} catch(e) {
		   audio_panner = null;
		}
		
      if (kiwi_isSmartTV()) audio_gain = audio_context.createGain();
	} catch(e) {
		kiwi_serious_error("Your browser does not support Web Audio API, which is required for OpenWebRX to run. Please use an HTML5 compatible browser.");
		audio_context = null;
		audio_output_rate = 0;
		return true;
	}

setTimeout("snd_send('SET little-endian');   // we can accept arm native little-endian data", 10000);
   audio_running = true;
   return false;
}

function audio_rate(input_rate)
{
	audio_input_rate = input_rate;

	if (audio_input_rate == 0) {
		snd_send("SET x-DEBUG user's browser gave zero audio_input_rate?");
		kiwi_serious_error("Audio initialization problem.");
	} else
	if (audio_output_rate == 0) {
		snd_send("SET x-DEBUG user's browser doesn't support WebAudio");
		snd_send("SET x-DEBUG "+ navigator.userAgent);
		kiwi_serious_error("Browser doesn\'t support WebAudio:<br>"+ navigator.userAgent +"<br><br>"+
		   "Please update to the latest version of your browser.");
	} else {
		if (resample_old) {
			audio_interpolation = audio_output_rate / audio_input_rate;		// needed by rational_resampler_get_lowpass_f()
			audio_decimation = 1;
		} else {
			audio_interpolation = 0;
			
			// Try to find common denominators by brute force.
			if (audio_interpolation == 0) {
				var interp, i_decim;
				for (interp = 2; interp <= 1024; interp++) {
					var decim = (input_rate * interp) / audio_output_rate;
					i_decim = Math.floor(decim);
					var frac = Math.abs(decim - i_decim);
					if (frac < 0.00001) break;
				}
            //console.log('### input_rate='+ input_rate +' audio_output_rate='+ audio_output_rate +' interp='+ interp);
				if (interp > 1024) {
					//divlog("unsupported audio output rate: "+audio_output_rate, 1);
					snd_send("SET UAR in="+input_rate+" out="+audio_output_rate);
					kiwi_serious_error("Your system uses an audio output rate of "+audio_output_rate+" sps which we do not support.");
				} else {
					audio_interpolation = interp;
					audio_decimation = i_decim;
					//console.log("brute force calc: aor="+audio_output_rate+" interp="+interp+" decim="+i_decim);
				}
			}
		}
	}

	if (audio_interpolation != 0) {
		audio_transition_bw = 0.001;
		audio_resample_ratio = audio_output_rate / audio_input_rate;
		snd_send("SET AR OK in="+ input_rate +" out="+ audio_output_rate);
		//divlog("Network audio rate: "+audio_input_rate.toString()+" sps");
	} else {
	   audio_resample_ratio = 1;
	}

   audio_min_nbuf = Math.ceil((audio_buffer_min_length_sec * audio_output_rate) / audio_buffer_size);
   audio_max_nbuf = Math.ceil((audio_buffer_max_length_sec * audio_output_rate) / audio_buffer_size);
	console.log('AUDIO audio_input_rate='+ audio_input_rate +' audio_output_rate='+ audio_output_rate);
	console.log('AUDIO min_length_sec='+ audio_buffer_min_length_sec +'('+ audio_min_nbuf +' bufs) max_length_sec='+ audio_buffer_max_length_sec +'('+ audio_max_nbuf +' bufs)');
}

// audio_source.onaudioprocess() -> audio_convolver -> audio_context.destination
//                                                  -> audio_watchdog.audio_watchdog_process()
//
// called only once when enough network input has been received

function audio_start()
{
   //console.log('AUDIO audio_start');
	if (audio_context == null) return;

	audio_started = true;
	audio_connect(0);
	window.setInterval(audio_periodic, audio_periodic_interval_ms);

	try {
		demodulator_analog_replace(init_mode);		//needs audio_output_rate to exist
	} catch(ex) {
		snd_send("SET x-DEBUG audio_start.demodulator_analog_replace: catch: "+ ex.toString());

		// message too big -- causes server crash
		//snd_send("SET x-DEBUG audio_start.demodulator_analog_replace: catch: "+ ex.stack);
	}
}

function audio_disconnect()
{
   //console.log('AUDIO audio_disconnect');
   if (audio_source) {
      audio_disconnected = true;
      audio_source.disconnect(); audio_source.onaudioprocess = null;
   }
   if (audio_convolver_running) {
      audio_convolver.disconnect();
      audio_convolver_running = false;
   }
   if (audio_watchdog) {
      audio_watchdog.disconnect(); audio_watchdog.onaudioprocess = null;
   }
}

function audio_connect_destination(src)
{
   // SmartTV browser won't play audio unless there is a gain block in the chain!
   if (kiwi_isSmartTV()) {
      audio_gain.gain.value = 0.3;     // don't blow out the TV speakers when they're set at 50% volume
      src.connect(audio_gain);
      src = audio_gain;
	}
	
	if (audio_panner) {
      src.connect(audio_panner);
      audio_panner.connect(audio_context.destination);
	} else {
      src.connect(audio_context.destination);
   }
}

function audio_set_pan(pan)
{
   if (audio_panner) {
      try {
         audio_panner.pan.value = pan;
      } catch(ex) {}
   }
}

// NB: always use kiwi_log() instead of console.log() in here
function audio_connect(reconnect)
{
   //console.log('AUDIO audio_connect reconnect='+ reconnect);
	if (audio_context == null) return;
	if (!audio_initial_connect && reconnect) {
	   kiwi_log('AUDIO audio_connect reconnect attempt too early -- IGNORED');
	   return;
	}
	if (!reconnect) audio_initial_connect = true;
	
	if (reconnect) {
	   audio_disconnect();
	   resample_init1 = resample_init2 = false;     // make sure convolver gets restarted
		audio_reconnect++;
      kiwi_log('AUDIO reconnect BUFFERING true');
		audio_buffering = true;
	}
	
	audio_stat_output_epoch = -1;
   audio_change_LPF_delayed = false;

	audio_channels = audio_mode_iq? 2 : 1;
	kiwi_log('audio_connect: reconnect='+ reconnect +' audio_mode_iq='+ audio_mode_iq +' audio_channels='+ audio_channels +' audio_compression='+ audio_compression);
	audio_source = audio_context.createScriptProcessor(audio_buffer_size, 0, audio_channels);		// in_nch=0, out_nch=audio_channels
	audio_source.onaudioprocess = audio_onprocess;
   audio_disconnected = false;
	
	if (audio_convolver_running) {
		audio_source.connect(audio_convolver);
		audio_connect_destination(audio_convolver);
	} else {
		audio_connect_destination(audio_source);
	}
	
	// workaround for Firefox problem where audio goes silent after a while (bug seems less frequent now?)
	if (kiwi_isFirefox()) {
		audio_watchdog = audio_context.createScriptProcessor(audio_buffer_size, audio_channels, 0);	// in_nch=audio_channels, out_nch=0
		audio_watchdog.onaudioprocess = audio_watchdog_process;
		
		// send audio to audio_watchdog as well
		if (audio_convolver_running)
			audio_convolver.connect(audio_watchdog);
		else
			audio_source.connect(audio_watchdog);
	}
}

// NB: always use kiwi_log() instead of console.log() in here
function audio_watchdog_process(ev)
{
	if (muted || audio_buffering) {
		audio_silence_count = 0;
		return;
	}
	
	var silence_buf = ev.inputBuffer.getChannelData(0);
	var silent = (silence_buf[0] == 0);
	if (kiwi_gc_snd) silence_buf = null;	// gc
	audio_silence_count = silent? audio_silence_count+1 : 0;

	if (audio_silence_count > 16) {
		audio_connect(1);
		audio_silence_count = 0;
		audio_restart_count++;
      add_problem("FF silence");
      kiwi_log('AUDIO FF SILENCE');
	}
}

// NB: always use kiwi_log() instead of console.log() in here
function audio_onprocess(ev)
{
   audio_firefox_watchdog++;

   if (audio_disconnected) return;
   
   //if (!audio_started) { kiwi_log('audio_onprocess audio_started='+ audio_started +' ql='+ audio_prepared_buffers.length  +' ----------------'); }
	if (audio_stat_output_epoch == -1) {
		audio_stat_output_epoch = (new Date()).getTime();
		audio_stat_output_bufs = 0;
	}

	/*
	// simulate Firefox "goes silent" problem
	if (dbgUs && kiwi_isFirefox() && ((audio_stat_output_bufs & 0x1f) == 0x1f)) {
		ev.outputBuffer.copyToChannel(audio_silence_buffer,0);
      if (audio_channels == 2) ev.outputBuffer.copyToChannel(audio_silence_buffer, 1);
		return;
	}
	*/
	
	/*
	if (dbgUs && ((audio_stat_output_bufs & 0x1f) == 0x1f)) {
      kiwi_log('AUDIO force underrun');
	   audio_prepared_buffers = [];
	}
	*/

	audio_stat_output_bufs++;

	if (audio_started && audio_prepared_buffers.length == 0) {
		audio_underrun_errors++;
      //kiwi_log('AUDIO UNDERRUN BUFFERING');
      audio_buffering = true;
	}

	if (!audio_started || audio_buffering) {
		audio_need_stats_reset = true;
		ev.outputBuffer.copyToChannel(audio_silence_buffer, 0);
      if (audio_channels == 2) ev.outputBuffer.copyToChannel(audio_silence_buffer, 1);
		return;
	}

	ev.outputBuffer.copyToChannel(audio_prepared_buffers.shift(), 0);
	if (audio_channels == 2) ev.outputBuffer.copyToChannel(audio_prepared_buffers2.shift(), 1);
	
	audio_ext_sequence = audio_prepared_seq.shift();

	if (audio_change_LPF_delayed) {
		audio_recompute_LPF(0);
		audio_change_LPF_delayed = false;
	}
	
	sMeter_dBm_biased = audio_prepared_smeter.shift() / 10;
	
	var flags = audio_prepared_flags.shift();
	audio_ext_adc_ovfl = (flags & audio_flags.SND_FLAG_ADC_OVFL)? true:false;

	if (flags & audio_flags.SND_FLAG_LPF) {
		audio_change_LPF_delayed = true;
	}
	
	var sq = (flags & audio_flags.SND_FLAG_SQUELCH_UI)? true:false;
	if (sq != audio_last_sq && isDefined(squelch_action)) {
      setTimeout(function(sq) { squelch_action(sq); }, 1, sq);
	   audio_last_sq = sq;
	}
	
	if (audio_meas_dly_ena && audio_meas_dly_start && (flags & audio_flags.SND_FLAG_NEW_FREQ)) {
		audio_meas_dly = (new Date()).getTime() - audio_meas_dly_start;
      kiwi_log('AUDIO dly='+ audio_meas_dly);
		audio_meas_dly_start = 0;
	}
}

//setInterval(function() { audio_ext_adc_ovfl = audio_ext_adc_ovfl? false:true; }, 1000);

var audio_watchdog_restart_cnt = 0;

function audio_periodic()
{
   // Workaround for latest Firefox audio problem.
   // Detect when audio_onprocess() stops getting called and restart it. An audio_connect() alone is insufficient.
   // The entire audio connection must be rebuilt by also calling audio_init()
   // Because this discards input buffers the compression must be restarted to avoid a noise burst.
   // Do this by asking the server to restart the audio stream with a reset compression state.

   if (audio_firefox_watchdog == 0 && kiwi_isFirefox() && !cfg.disable_recent_changes) {
      add_problem("FF watchdog");
      console.log('AUDIO FF WATCHDOG ============================================');
      audio_init(null, false, null);
      audio_started = true;
      audio_initial_connect = true;
      audio_watchdog_restart = true;
      snd_send("SET reinit");
   } else {
      audio_firefox_watchdog = 0;
   }
   
   //if (audio_watchdog_restart) { console.log('audio_watchdog_restart '+ audio_watchdog_restart_cnt); audio_watchdog_restart_cnt++; }

   //console.log('AUDIO FLUSH');
	var overran = false;
	//var audio_buffer_mid_length_sec = audio_buffer_min_length_sec + ((audio_buffer_max_length_sec - audio_buffer_min_length_sec) /2);
	
	while (audio_prepared_buffers.length > audio_max_nbuf) {
		overran = true;
		audio_prepared_buffers.shift();
		if (audio_channels == 2) audio_prepared_buffers2.shift();
		audio_prepared_seq.shift();
		audio_prepared_flags.shift();
		audio_prepared_smeter.shift();
	}
	
	if (overran) {
		add_problem("audio overrun");
		audio_overrun_errors++;
	}
	
	if (audio_last_underruns != audio_underrun_errors) {
			add_problem("audio underrun");
			snd_send("SET underrun="+ audio_underrun_errors);
		audio_last_underruns = audio_underrun_errors;
	}
	
	/*
	if (dbgUs && kiwi_isFirefox()) {
		if (audio_last_reconnect != audio_reconnect) {
			console.log('FF audio_reconnect='+ audio_reconnect);
			audio_last_reconnect = audio_reconnect;
		}
		
		if (audio_last_restart_count != audio_restart_count) {
			console.log('FF restart_count='+ audio_restart_count);
			audio_last_restart_count = audio_restart_count;
		}

		var s = 'ob='+ audio_stat_output_bufs +' ab='+ audio_buffering +' len='+ audio_prepared_buffers.length +
			' recon='+ audio_reconnect +' resta='+ audio_restart_count + ' und='+ audio_underrun_errors + ' ovr='+ audio_overrun_errors;
		snd_send('SET FF-0 '+ s);
	}
	*/
}

function audio_recv(data)
{
   //if (!audio_running) console.log('AUDIO audio_recv running='+ audio_running);
   if (!audio_running) return;
   
	var h8 = new Uint8Array(data, 0, 8);   // data, offset, length
   var flags = h8[3];
   //console.log('AUDIO flags='+ flags.toHex(+4));
   
	var seq = (h8[7] << 24) | (h8[6] << 16) | (h8[5] << 8) | h8[4];
	
	var sm8 = new Uint8Array(data, 8, 2);
	var smeter = (sm8[0] << 8) | sm8[1];
	
	var isIQ = (flags & audio_flags.SND_FLAG_MODE_IQ);
	var offset = isIQ? 20 : 10;
	var data_view = new DataView(data, offset);
	var bytes = data_view.byteLength;
		
	var i, samps;
	
	if (audio_watchdog_restart) {
	   if (!(flags & audio_flags.SND_FLAG_RESTART)) return;
	   audio_watchdog_restart = false;
	   
      audio_prepared_buffers = [];
      audio_prepared_buffers2 = [];
      audio_prepared_seq = [];
      audio_prepared_flags = [];
      audio_prepared_smeter = [];
      
      if (audio_mode_iq) {
         // because we haven't figured out how to make rational_resampler_cc() work yet
         // punt and just use old resampler for IQ mode
         resample_new = false; resample_old = !resample_new;
      } else {
         audio_adpcm.index = audio_adpcm.previousValue = 0;
         resample_new = kiwi_isMobile()? false : resample_new_default; resample_old = !resample_new;
      }

      audio_connect(1);
	} else
	if (isIQ) {
	
	   // current buffer flag is IQ mode
	   if (!audio_mode_iq) {    // !IQ -> IQ transition
         audio_prepared_buffers = [];
         audio_prepared_buffers2 = [];
         audio_prepared_seq = [];
         audio_prepared_flags = [];
         audio_prepared_smeter = [];
         
         // because we haven't figured out how to make rational_resampler_cc() work yet
         // punt and just use old resampler for IQ mode
         resample_new = false; resample_old = !resample_new;
         audio_mode_iq = true;
         //console.log('AUDIO IQ mode');
         audio_connect(1);
	   }
	   audio_last_compression = audio_compression = false;
	   audio_mode_iq = true;
	} else {
	
	   // current buffer flag is not IQ mode
	   // need to restart audio in two cases:
	   //    transition from IQ -> !IQ
	   //    when in !IQ there is a change in compression flag
	   var compressed = (flags & audio_flags.SND_FLAG_COMPRESSED)? true:false;
	   if (audio_mode_iq || (audio_compression != compressed)) {
         audio_prepared_buffers = [];
         audio_prepared_buffers2 = [];
         audio_prepared_seq = [];
         audio_prepared_flags = [];
         audio_prepared_smeter = [];
         audio_adpcm.index = audio_adpcm.previousValue = 0;
         resample_new = kiwi_isMobile()? false : resample_new_default; resample_old = !resample_new;
         audio_mode_iq = false;
         //console.log('AUDIO compression change='+ (audio_compression != compressed) +' now='+ compressed);
         audio_last_compression = audio_compression = compressed;
         audio_connect(1);
	   }
	   
      audio_last_compression = audio_compression = compressed;
	   audio_mode_iq = false;
	}

	if (audio_compression) {
      //console.log('AUDIO COMP bytes='+ bytes);
		decode_ima_adpcm_e8_i16(data_view, audio_data, bytes, audio_adpcm);
		samps = bytes*2;		// i.e. 1024 8b bytes -> 2048 16b real samps, 1KB -> 4KB, 4:1 over uncompressed
	} else {
      //console.log('AUDIO NO_COMP bytes='+ bytes);
		samps = bytes/2;		// i.e. non-IQ: 1024 8b bytes ->  512 16b real samps,                     1KB -> 1KB, 1:1 no compression
		                     // i.e.     IQ: 2048 8b bytes -> 1024 16b  I,Q samps (512 IQ samp pairs), 2KB -> 2KB, 1:1 never compression
      for (i=0; i < samps; i++) {
         audio_data[i] = data_view.getInt16(i*2, (flags & audio_flags.SND_FLAG_LITTLE_ENDIAN)? true:false);   // convert from network byte-order
      }
	}
	
	audio_prepare(audio_data, samps, seq, flags, smeter);

	if (!audio_started) {
	   var enough_buffered = audio_prepared_buffers.length > audio_min_nbuf;
	   //console.log('ASTART eb='+ enough_buffered +' len='+ audio_prepared_buffers.length);
	   if (enough_buffered)
		   audio_start();
	}

	if (audio_need_stats_reset)
		audio_stats_reset();

	audio_stat_input_size += samps;
	audio_stat_total_input_size += samps;

	extint_audio_data(audio_data, samps);


   // audio FFT hook
   if (rx_chan >= wf_chans) {
      wf_audio_FFT(audio_data, samps);
   }


	// Recording hooks
	if (window.recording && audio_last_sq == false) {
		var samples = audio_mode_iq ? 1024 : (compressed ? 2048 : 512);

		// There are 2048 or 512 little-endian samples in each audio_data, the rest of the elements are zeroes
		for (var i = 0; i < samples; ++i) {
			window.recording_meta.data.setInt16(window.recording_meta.offset, audio_data[i], true);
			window.recording_meta.offset += 2;
		}
		window.recording_meta.total_size += samples * 2;

		// Check if it's time for a new buffer yet
		if (window.recording_meta.offset == 65536) {
			window.recording_meta.buffers.push(new ArrayBuffer(65536));
			window.recording_meta.data = new DataView(window.recording_meta.buffers[window.recording_meta.buffers.length - 1]);
			window.recording_meta.offset = 0;
		}
	}
}

var audio_push_ct = 0;

function audio_prepare(data, data_len, seq, flags, smeter)
{
	var resample_new_decomp = resample_new && audio_compression && comp_lpf_taps_length;

	//console.log("audio_prepare :: "+data_len.toString());
	//console.log("data.len = "+data_len.toString());

	var dopush = function()
	{
		audio_prepared_buffers.push(audio_last_output_buffer);
		if (audio_channels == 2) audio_prepared_buffers2.push(audio_last_output_buffer2);
		audio_prepared_seq.push(seq);

		// delay changing LPF until point at which buffered audio changed
		// don't miss any SND_FLAG_LPF flags because dopush() isn't invoked for every call to audio_prepare()
		if (audio_change_LPF_latch) {
		   audio_change_LPF_latch = false;
			flags |= audio_flags.SND_FLAG_LPF;
		}

		// don't miss any SND_FLAG_NEW_FREQ flags because dopush() isn't invoked for every call to audio_prepare()
		if (audio_change_freq_latch) {
		   audio_change_freq_latch = false;
			flags |= audio_flags.SND_FLAG_NEW_FREQ;
		}
		
		// don't miss any SND_FLAG_SQUELCH_UI flags because dopush() isn't invoked for every call to audio_prepare()
		if (audio_change_sq_UI_latch) {
		   audio_change_sq_UI_latch = false;
			flags |= audio_flags.SND_FLAG_SQUELCH_UI;
		}
		
		audio_prepared_flags.push(flags);
		audio_prepared_smeter.push(smeter);
		audio_last_output_offset = 0;
		audio_last_output_buffer = new Float32Array(audio_buffer_size);
		if (audio_channels == 2) audio_last_output_buffer2 = new Float32Array(audio_buffer_size);
		//if (audio_push_ct < 16) console.log('AUDIO push='+ audio_push_ct); audio_push_ct++;
	};

	var copy = function(d, di, s, si, len)
	{
		var i;
		for (i=0; i<len; i++) d[di+i] = s[si+i];
	};
	
	var idata, idata2, idata_length;
	if (data_len == 0) return;
	
	// --- Resampling ---
	
	if (audio_resample_ratio != 1) {
	
		// setup LPF for rational resampler
		if (!resample_init1) {
			resample_taps_length = Math.round(4.0/audio_transition_bw);
			if (resample_taps_length%2 == 0) resample_taps_length++;	// number of symmetric FIR filter taps should be odd
			rational_resampler_get_lowpass_f(resample_taps, resample_taps_length, audio_interpolation, audio_decimation);
			//console.log("audio_resample_ratio "+audio_resample_ratio+" resample_taps_length "+resample_taps_length+" osize "+data_len+'/'+Math.round(data_len * audio_resample_ratio));
			//var middle=Math.floor(resample_taps_length/2); for(var i=middle; i<=middle+64; i++) console.log("tap"+i+": "+resample_taps[i]);
			//console.log('AUDIO INIT rational resampler: resample_taps_length='+ resample_taps_length);

			resample_init1 = true;
		}

		// Need a convolver-based LPF in two cases:
		//		1) filter high-frequency artifacts from using decompression with new resampler
		//			(built-in LPF of new resampler without compression is, by definition, sufficient)
		//		2) filter high-frequency artifacts from using old resampler (interpolator), independent of decompression
		//       (old resampler is currently used with IQ mode)
		// LPF must track passband in all cases via audio_recompute_LPF().
		// Use the firdes_lowpass_f() routine of the new resampler code to construct the filter for the convolver.
	
		if (!resample_init2 && resample_init1 && (resample_new_decomp || resample_old) && (audio_source != undefined)) {
			var lpf_taps, lpf_taps_length;
			
         audio_recompute_LPF(1);
         lpf_taps = comp_lpf_taps;
         lpf_taps_length = comp_lpf_taps_length;
			//console.log('AUDIO INIT convolver: resample_new_decomp='+ resample_new_decomp +' lpf_taps_length='+ lpf_taps_length);
			audio_convolver = audio_context.createConvolver();
			audio_convolver.normalize = false;
			audio_reload_convolver_buffer(lpf_taps, lpf_taps_length);
			
			// splice the convolver in-between the audio source and destination
			//console.log(audio_source);
			//console.log(audio_convolver);
			//console.log(audio_context);
			//console.log('AUDIO splice in convolver');
			audio_source.disconnect();
			audio_source.connect(audio_convolver);
		   audio_connect_destination(audio_convolver);
			
			if (kiwi_isFirefox()) {
				//audio_source.connect(audio_watchdog);
				audio_convolver.connect(audio_watchdog);
			}
			
			audio_convolver_running = true;

			resample_init2 = true;
		}

		if (resample_old) {
		
			// Our traditional linear interpolator.
			// Because this is an interpolator, and not a decimator, the post-LPF is only needed
			// to clean up the high-frequency junk left above the input passband (input sample rate).
			if (audio_channels == 2) {
            resample_output_size = Math.round(data_len/2 * audio_resample_ratio);
            var incr = 1.0 / audio_resample_ratio;
            var di = 0;
            var frac = 0;
            var xc, xc2, xl;
            for (i=0; i < resample_output_size; i++) {
            
               // new = cur*frac + last*(1-frac)  [0 <= frac <= 1]  i.e. incr = old/new
               // new = cur*frac + last - last*frac
               // new = (cur-last)*frac + last  [only one multiply]
               //assert(di < data_len);
               xc = data[di*2];
               xl = resample_last;
               resample_output_buffer[i] = (xc-xl)*frac + xl;
               xc2 = data[di*2+1];
               xl = resample_last2;
               resample_output_buffer2[i] = (xc2-xl)*frac + xl;
               frac += incr;
               if (frac >= 1) {
                  frac -= 1;
                  resample_last = xc;
                  resample_last2 = xc2;
                  di++;
               }
            }
            resample_last = xc;
            resample_last2 = xc2;
			} else {
            resample_output_size = Math.round(data_len * audio_resample_ratio);
            var incr = 1.0 / audio_resample_ratio;
            var di = 0;
            var frac = 0;
            var xc, xl;
            for (i=0; i < resample_output_size; i++) {
            
               // new = cur*frac + last*(1-frac)  [0 <= frac <= 1]  i.e. incr = old/new
               // new = cur*frac + last - last*frac
               // new = (cur-last)*frac + last  [only one multiply]
               //assert(di < data_len);
               xc = data[di];
               xl = resample_last;
               resample_output_buffer[i] = (xc-xl)*frac + xl;
               frac += incr;
               if (frac >= 1) {
                  frac -= 1;
                  resample_last = xc;
                  di++;
               }
            }
            resample_last = xc;
         }
		} else {
			if (resample_input_processed != 0) {
				var new_available = resample_input_available - resample_input_processed;
				copy(resample_input_buffer, 0, resample_input_buffer, resample_input_processed, new_available);
				resample_input_available = new_available;
				resample_input_processed = 0;
			}
			copy(resample_input_buffer, resample_input_available, data, 0, data_len);
			resample_input_available += data_len;
			
			if (audio_channels == 2) {
			   rational_resampler_cc(resample_input_buffer, resample_output_buffer, resample_output_buffer2, resample_input_available,
			      audio_interpolation, audio_decimation, resample_taps, resample_taps_length, resample_last_taps_delay);
			} else {
			   rational_resampler_ff(resample_input_buffer, resample_output_buffer, resample_input_available,
			      audio_interpolation, audio_decimation, resample_taps, resample_taps_length, resample_last_taps_delay);
			}
		}
		
		idata = resample_output_buffer;
		idata2 = resample_output_buffer2;
		idata_length = resample_output_size;
	} else {
		idata = data;
		idata_length = data_len;
	}
	
   if (flags & audio_flags.SND_FLAG_LPF) {
      audio_change_LPF_latch = true;
   }

	// reduce latency during freq or mode change by trimming most recent buffers back to minimum
   if (flags & audio_flags.SND_FLAG_NEW_FREQ) {
      audio_change_freq_latch = true;
      //console.log('NEW_FREQ audio_meas_dly_ena='+ audio_meas_dly_ena +' audio_meas_dly_start='+ audio_meas_dly_start);
      var len = audio_prepared_buffers.length;
      var min = audio_min_nbuf;
      var pop = (len > min)? (len - min) : 0;
      //if (audio_meas_dly_ena) console.log('AUDIO NEW_FREQ Qlen='+ len +' min='+ min +' pop='+ pop);

      while (audio_prepared_buffers.length > min) {
         audio_prepared_buffers.pop();
		   if (audio_channels == 2) audio_prepared_buffers2.pop();
         audio_prepared_seq.pop();
         audio_prepared_flags.pop();
         audio_prepared_smeter.pop();
      }
   }
	
   if (flags & audio_flags.SND_FLAG_SQUELCH_UI) {
      audio_change_sq_UI_latch = true;
   }

	//console.log("idata_length "+ idata_length);
	if (audio_last_output_offset + idata_length <= audio_buffer_size) {
	   // array fits into output buffer
	   if (audio_channels == 2) {
         for (var i=0; i < idata_length; i++) {
            audio_last_output_buffer[i+audio_last_output_offset] = idata[i] / 32768 * f_volume;
            audio_last_output_buffer2[i+audio_last_output_offset] = idata2[i] / 32768 * f_volume;
         }
	   } else {
         for (var i=0; i < idata_length; i++)
            audio_last_output_buffer[i+audio_last_output_offset] = idata[i] / 32768 * f_volume;
      }
		audio_last_output_offset += idata_length;
		//console.log("fits into; offset="+ audio_last_output_offset.toString());
		if (audio_last_output_offset == audio_buffer_size) dopush();
	} else {
	   // array is larger than the remaining space in the output buffer
		var copied = audio_buffer_size - audio_last_output_offset;
		var remain = idata_length - copied;
	   if (audio_channels == 2) {
         for (var i=0; i < audio_buffer_size - audio_last_output_offset; i++) {  // fill the remaining space in the output buffer
            audio_last_output_buffer[i+audio_last_output_offset] = idata[i] / 32768 * f_volume;
            audio_last_output_buffer2[i+audio_last_output_offset] = idata2[i] / 32768 * f_volume;
         }
	   } else {
         for (var i=0; i < audio_buffer_size - audio_last_output_offset; i++)    // fill the remaining space in the output buffer
            audio_last_output_buffer[i+audio_last_output_offset] = idata[i] / 32768 * f_volume;
      }
		dopush();	// push the output buffer and create a new one

		//console.log("larger than; copied half: "+copied.toString()+", now at: "+audio_last_output_offset.toString());
		do {
			var i;
			for (i=0; i < remain; i++) {
			   // copy the remaining input samples to the new output buffer
				if (i == audio_buffer_size) {
					dopush();
					break;
				}
				audio_last_output_buffer[i] = idata[i+copied] / 32768 * f_volume;
				if (audio_channels == 2) audio_last_output_buffer2[i] = idata2[i+copied] / 32768 * f_volume;
			}
			remain -= i;
			copied += i;
		} while (remain);
		
		audio_last_output_offset += i;
		//console.log("larger than; remained: "+remain.toString()+", now at: "+audio_last_output_offset.toString());
	}

	if (audio_buffering) {
	   var enough_buffered = audio_prepared_buffers.length > audio_min_nbuf;
	   //console.log('BUFFERING eb='+ enough_buffered +' len='+ audio_prepared_buffers.length +' audio_started='+ audio_started);
	   if (enough_buffered) {
	      //console.log('AUDIO BUFFERING ('+ audio_min_nbuf +') complete');
		   audio_buffering = false;
		}
	}
}


try {
	if (!AudioBuffer.prototype.copyToChannel) { // Chrome 36 does not have it, Firefox does
		AudioBuffer.prototype.copyToChannel = function(input, channel) //input is Float32Array
			{
				var cd = this.getChannelData(channel);
				for (var i=0; i < input.length; i++) cd[i] = input[i];
			}
	}
} catch(ex) { console.log("CATCH: AudioBuffer.prototype.copyToChannel"); }

function audio_stats_reset()
{
	audio_stat_input_epoch = (new Date()).getTime();
	audio_stat_last_time = audio_stat_input_epoch;

	audio_stat_input_size = audio_stat_total_input_size = 0;
	audio_need_stats_reset = false;
}

function audio_stats()
{
	if (audio_stat_input_epoch == -1 || audio_stat_output_epoch == -1)
		return;

	var time_now = (new Date()).getTime();
	var secs_since_last_call = (time_now - audio_stat_last_time)/1000;
	var secs_since_reset = (time_now - audio_stat_input_epoch)/1000;
	var secs_since_first_output = (time_now - audio_stat_output_epoch)/1000;
	audio_stat_last_time = time_now;

	var net_sps = audio_stat_input_size / secs_since_last_call;
	var net_avg = audio_stat_total_input_size / secs_since_reset;
	var out_sps = (audio_stat_output_bufs * audio_buffer_size) / secs_since_first_output;
	
	var s = "Audio: network "+
		net_sps.toFixed(0) +" sps ("+
		net_avg.toFixed(0) +" avg), output "+
		out_sps.toFixed(0) +" sps";

	s += ', Qlen '+audio_prepared_buffers.length;
	if (audio_underrun_errors) s += ', underruns '+audio_underrun_errors.toString();
	if (audio_restart_count) s += ', restart '+audio_restart_count.toString();
   w3_innerHTML('id-msg-audio', s);
   
   if (isNaN(out_sps)) out_sps = 0;
   w3_innerHTML('id-status-audio',
      w3_text(optbar_prefix_color, 'WF'),
      w3_text('', kiwi.wf_fps.toFixed(0) +' fps'),
      w3_text(optbar_prefix_color, 'Audio'),
      w3_text('', (out_sps/1000).toFixed(1) +'k, Qlen '+ audio_prepared_buffers.length)
   );

	audio_stat_input_size = 0;
}

// FIXME
// To eliminate the clicking when switching filter buffers, consider fading between new & old convolvers.

// NB: always use kiwi_log() instead of console.log() in here
function audio_recompute_LPF(force)
{
	var lpf_freq = 4000;    // default if no modulator currently defined
	if (isDefined(demodulators[0])) {
		var hcut = Math.abs(demodulators[0].high_cut);
		var lcut = Math.abs(demodulators[0].low_cut);
		lpf_freq = Math.max(hcut, lcut);
	}
	
   if (force || lpf_freq != comp_lpf_freq) {
		var cutoff = lpf_freq / audio_output_rate;
		//kiwi_log('COMP_LPF force='+ force +' resample_new='+ resample_new +' cutoff: '+ comp_lpf_freq +' -> '+ lpf_freq +' '+ cutoff.toFixed(3) +'/'+ audio_output_rate +' ctaps='+ comp_lpf_taps_length);
		firdes_lowpass_f(comp_lpf_taps, comp_lpf_taps_length, cutoff);
		comp_lpf_freq = lpf_freq;

		// reload buffer if convolver already running
		if (audio_convolver_running) {
		   //kiwi_log('COMP_LPF force='+ force +' reload convolver running');
		   audio_reload_convolver_buffer(comp_lpf_taps, comp_lpf_taps_length);
		}
	} else {
		//kiwi_log('COMP_LPF no change required force='+ force +' lpf_freq='+ lpf_freq);
	}
}

// NB: always use kiwi_log() instead of console.log() in here
function audio_reload_convolver_buffer(lpf_taps, lpf_taps_length)
{
   // always using 2 channels of LPF data seems to work fine
   var audio_lpf_buffer = audio_context.createBuffer(2, lpf_taps_length, audio_output_rate);
   var audio_lpf = audio_lpf_buffer.getChannelData(0);
   audio_lpf.set(lpf_taps);
   audio_lpf = audio_lpf_buffer.getChannelData(1);
   audio_lpf.set(lpf_taps);
   audio_convolver.buffer = audio_lpf_buffer;
   //kiwi_log('audio_reload_convolver_buffer lpf_taps_length='+ lpf_taps_length);
}

function rational_resampler_ff(input, output, input_size, interpolation, decimation, taps, taps_length, last_taps_delay)
{
	// Theory: http://www.dspguru.com/dsp/faqs/multirate/resampling
	// oi: output index, i: tap index
	var output_size = Math.round(input_size * interpolation/decimation);
	var i, oi;
	var startingi, delayi, last_delayi = -1;

	for (oi=0; oi < output_size; oi++) //@rational_resampler_ff (outer loop)
	{
		startingi = Math.floor((oi*decimation + interpolation-1-last_taps_delay) / interpolation); //index of first input item to apply FIR on
		delayi = Math.floor((last_taps_delay + startingi*interpolation - oi*decimation) % interpolation); //delay on FIR taps

		if (startingi + taps_length/interpolation +1 > input_size)
		   break; //we can't compute the FIR filter to some input samples at the end

		var end = Math.floor((taps_length-delayi) / interpolation);

		var acc = 0;
		for (i=0; i < end; i++) {  //@rational_resampler_ff (inner loop)
			acc += input[startingi+i] * taps[delayi + i*interpolation];
		}
		output[oi] = acc*interpolation;
	}

	resample_input_processed = startingi;
	resample_output_size = oi;
	resample_last_taps_delay = delayi;
}

function rational_resampler_cc(input, outputI, outputQ, input_size, interpolation, decimation, taps, taps_length, last_taps_delay)
{
	// Theory: http://www.dspguru.com/dsp/faqs/multirate/resampling
	// oi: output index, i: tap index
	consoled.log('WARNING rational_resampler_cc() not working yet!');
   return;
/*
	input_size /= 2;
	var output_size = Math.round(input_size * interpolation/decimation);
	var i, oi;
	var startingi, delayi, last_delayi = -1;

	for (oi=0; oi < output_size; oi++) //@rational_resampler_ff (outer loop)
	{
		startingi = Math.floor((oi*decimation + interpolation-1-last_taps_delay) / interpolation); //index of first input item to apply FIR on
		delayi = Math.floor((last_taps_delay + startingi*interpolation - oi*decimation) % interpolation); //delay on FIR taps

		if (startingi + taps_length/interpolation +1 > input_size)
		   break; //we can't compute the FIR filter to some input samples at the end

		var end = Math.floor((taps_length-delayi) / interpolation);

		var accI = 0, accQ = 0;
		for (i=0; i < end; i++) {  //@rational_resampler_ff (inner loop)
			accI += input[(startingi+i)*2] * taps[delayi + i*interpolation];
			accQ += input[(startingi+i)*2+1] * taps[delayi + i*interpolation];
		}
		outputI[oi] = accI*interpolation;
		outputQ[oi] = accQ*interpolation;
	}

	resample_input_processed = startingi;
	resample_output_size = oi;
	resample_last_taps_delay = delayi;
*/
}

function rational_resampler_get_lowpass_f(output, output_size, interpolation, decimation)
{
	// See 4.1.6 at: http://www.dspguru.com/dsp/faqs/multirate/resampling
	var cutoff_for_interpolation = 1.0/interpolation;
	var cutoff_for_decimation = 1.0/decimation;
	var cutoff = (cutoff_for_interpolation < cutoff_for_decimation)? cutoff_for_interpolation : cutoff_for_decimation; //get the lower
	firdes_lowpass_f(output, output_size, cutoff/2);
}

function firdes_lowpass_f(output, length, cutoff_rate)
{
	//Generates symmetric windowed sinc FIR filter real taps
	//	length should be odd
	//	cutoff_rate is (cutoff frequency/sampling frequency)
	//Explanation at Chapter 16 of dspguide.com
	var i;
	var middle = Math.floor(length/2);
	output[middle] = 2*Math.PI*cutoff_rate * firdes_wkernel_hamming(0);
	for (i=1; i<=middle; i++) // calculate taps
	{
		output[middle-i] = output[middle+i] = (Math.sin(2*Math.PI*cutoff_rate*i)/i) * firdes_wkernel_hamming(i/middle);
		//printf("%g %d %d %d %d | %g\n",output[middle-i],i,middle,middle+i,middle-i,sin(2*Math.PI*cutoff_rate*i));
	}
	
	//Normalize filter kernel
	var sum=0;
	for (i=0; i<length; i++) // normalize pass 1
	{
		sum += output[i];
	}
	for (i=0; i<length; i++) // normalize pass 2
	{
		output[i] /= sum;
	}
}

function firdes_wkernel_hamming(rate)
{
	//Explanation at Chapter 16 of dspguide.com, page 2
	//Hamming window has worse stopband attentuation and passband ripple than Blackman, but it has faster rolloff.
	rate=0.5+rate/2;
	return 0.54-0.46*Math.cos(2*Math.PI*rate);
}





/* web/openwebrx/ima_adpcm.min.js */
var indexAdjustTable=[-1,-1,-1,-1,2,4,6,8,-1,-1,-1,-1,2,4,6,8],stepSizeTable=[7,8,9,10,11,12,13,14,16,17,19,21,23,25,28,31,34,37,41,45,50,55,60,66,73,80,88,97,107,118,130,143,157,173,190,209,230,253,279,307,337,371,408,449,494,544,598,658,724,796,876,963,1060,1166,1282,1411,1552,1707,1878,2066,2272,2499,2749,3024,3327,3660,4026,4428,4871,5358,5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,15289,16818,18500,20350,22385,24623,27086,29794,32767];function ImaAdpcmDecode(e,a){var p=stepSizeTable[a.index],d=p>>3;return 1&e&&(d+=p>>2),2&e&&(d+=p>>1),4&e&&(d+=p),8&e&&(d=-d),a.previousValue+=d,a.previousValue>a.pos_clamp?a.previousValue=a.pos_clamp:a.previousValue<a.neg_clamp&&(a.previousValue=a.neg_clamp),a.index+=indexAdjustTable[e],a.index<0?a.index=0:a.index>88&&(a.index=88),a.previousValue}function decode_ima_adpcm_e8_i16(e,a,p,d){d.pos_clamp=32767,d.neg_clamp=-32768;var c,i=0;for(c=0;c<p;c++){var m=e.getUint8(c);a[i++]=ImaAdpcmDecode(15&m,d),a[i++]=ImaAdpcmDecode(m>>4&15,d)}}function decode_ima_adpcm_e8_u8(e,a,p,d){d.pos_clamp=255,d.neg_clamp=0;var c,i=0;for(c=0;c<p;c++)a[i++]=ImaAdpcmDecode(15&e[c],d),a[i++]=ImaAdpcmDecode(e[c]>>4&15,d)}

/* web/pkgs/xdLocalStorage/xdLocalStorage.min.js */
"use strict";window.xdLocalStorage=window.xdLocalStorage||function(){var e,n="cross-domain-local-message",o={iframeId:"cross-domain-iframe",iframeUrl:void 0,initCallback:function(){}},t=-1,i={},a=!1,l=!1;function r(e){var t;try{t=JSON.parse(e.data)}catch(e){}t&&t.namespace===n&&("iframe-ready"===t.id?(l=!0,t.ip&&console.log("xdLocalStorage ip="+t.ip),o.initCallback()):function(e){i[e.id]&&(i[e.id](e),delete i[e.id])}(t))}function s(o,a,l,r){i[++t]=r;var s={namespace:n,etag:0,server:0,id:t,action:o,key:a,value:l};e.contentWindow.postMessage(JSON.stringify(s),"*")}function c(n){o=XdUtils.extend(n,o);var t=document.createElement("div");window.addEventListener?window.addEventListener("message",r,!1):window.attachEvent("onmessage",r),t.innerHTML='<iframe id="'+o.iframeId+'" src='+o.iframeUrl+' style="display: none;"></iframe>',document.body.appendChild(t),e=document.getElementById(o.iframeId)}function d(){return a?!!l||(console.log("You must wait for iframe ready message before using the api."),!1):(console.log("You must call xdLocalStorage.init() before using it."),!1)}return{init:function(e){if(!e.iframeUrl)throw"You must specify iframeUrl";a?console.log("xdLocalStorage was already initialized!"):(a=!0,"complete"===document.readyState?c(e):window.onload=function(){c(e)})},setItem:function(e,n,o){d()&&s("set",e,n,o)},getItem:function(e,n){d()&&s("get",e,null,n)},removeItem:function(e,n){d()&&s("remove",e,null,n)},key:function(e,n){d()&&s("key",e,null,n)},getSize:function(e){d()&&s("size",null,null,e)},getLength:function(e){d()&&s("length",null,null,e)},clear:function(e){d()&&s("clear",null,null,e)},wasInit:function(){return a}}}(),window.xdLocalStorageHA=window.xdLocalStorageHA||function(){var e="cross-domain-local-message",n={iframeId:"cross-domain-iframe",iframeUrls:void 0,initCallback:function(){}},o=-1,t=[],i=[],a=0,l={},r=[],s=!1,c=!1;function d(n){var o;try{o=JSON.parse(n.data)}catch(e){}o&&o.namespace===e&&("iframe-ready"===o.id?o.ip&&console.log("xdLocalStorage ip="+o.ip):"ping"===o.action?(i[o.server]=!0,a++,console.log("XDLS ping reply server="+o.server+" seen_ct="+a)):r[o.server]=o)}function u(n,a,s,c){l[++o]=c;for(var d={namespace:e,etag:Date.now(),id:o,action:n,key:a,value:s},u=0;u<t.length;u++)("ping"==n||i[u])&&(console.log("XDLS request id="+o+" server="+u+" action="+n+" etag="+d.etag),d.server=u,r[u]=null,t[u].contentWindow.postMessage(JSON.stringify(d),"*"));"ping"!=n&&setTimeout(function(){for(var e=-1,n=-1,o=0;o<t.length;o++){var i=r[o];if(null!=i){var a=i.etag?i.etag:0;console.log("XDLS response id="+i.id+" server="+i.server+" etag="+a),a>e&&(e=a,n=o)}}-1!=n?function(e){console.log("XDLS result id="+e.id+" server="+e.server),console.log(e),l[e.id]&&(l[e.id](e),delete l[e.id])}(r[n]):console.log("XDLS wait longer for response?")},250)}function f(e){n=XdUtils.extend(e,n),window.addEventListener?window.addEventListener("message",d,!1):window.attachEvent("onmessage",d);var o=0;n.iframeUrls.forEach(function(e){var i="id-"+n.iframeId+"-"+o,a=document.createElement("div");w3_add(a,"id-"+n.iframeId),a.innerHTML='<iframe id="'+i+'" src='+e+' style="display: none;"></iframe>',document.body.appendChild(a),t[o]=document.getElementById(i),o++})}function m(){return s?!!c||(console.log("You must wait for iframe ready message before using the api."),!1):(console.log("You must call xdLocalStorage.init() before using it."),!1)}return setTimeout(function(){u("ping",null,null,null),setTimeout(function(){console.log("XDLS seen servers="+a),c=!0,n.initCallback()},1e3)},5e3),{init:function(e){if(!e.iframeUrls)throw"You must specify iframeUrls";s?console.log("xdLocalStorage was already initialized!"):(s=!0,"complete"===document.readyState?f(e):window.onload=function(){f(e)})},setItem:function(e,n,o){m()&&u("set",e,n,o)},getItem:function(e,n){m()&&u("get",e,null,n)},removeItem:function(e,n){m()&&u("remove",e,null,n)},key:function(e,n){m()&&u("key",e,null,n)},getSize:function(e){m()&&u("size",null,null,e)},getLength:function(e){m()&&u("length",null,null,e)},clear:function(e){m()&&u("clear",null,null,e)},wasInit:function(){return s}}}();

/* web/pkgs/xdLocalStorage/xd-utils.min.js */
"use strict";window.XdUtils=window.XdUtils||function(){return{extend:function(n,t){var r,i=t||{};for(r in n)n.hasOwnProperty(r)&&(i[r]=n[r]);return i}}}();